---
title: 近期进展 (2020-11-15 ~ 2020-11-27)
index_img: /img/Pic/Recent.jpeg
date: 2020-11-27 14:45:21
category: [Summary]
tags: Summary
---

# 最近进展

近来比较忙，一直没时间写博客，就暂将这段时间的进展写作一个综述发在博客上

---

## **学业方面**
### 数据结构 - DataStructure
数据结构这几周以来都是学的树相关的操作, 对树的相关操作进行了学习和进一步的探究

#### 已经掌握

##### 树的储存
1. 邻接表形式
```cpp
std::vector<int> Tree[Max]
```

1. 链式前向星形式
```cpp
struct edge
{
    int v;
    int w;
    int nex;
};

edge e[Max];
int head[Max], cnt = 0; // init -1

void add_edge(int u, int v)
{
    e[cnt].v = v;
    e[cnt].w = w;
    e[cnt].nex = head[u];
    head[u] = cnt++;
}

//遍历方式
for(int i = head[u]; i != -1; i = e[i].nex)
```
> 邻接表相比链式前向星更为动态，但有些阴间题会卡掉邻接表

---

##### 深度优先搜索 (dfs)

基本原则是一种与广度优先搜索对立的，能搜到子节点就往子节点走的搜索方式，既“深度”优先，我们熟知的二叉树的前序和后序遍历都是深度优先搜索的一种。

1. 代码实现 (邻接表形式)
    ```cpp
    void dfs(int u, int fa)
    {
        for(auto& v : tree[u])
        {
            if(v == fa)
                continue;
            dfs(v, u)
        }
    }
    ```
    其中 dfs(v,u) 是 dfs 的精华， 指代如若没搜到叶节点那么则继续向深度搜索，这时候当前节点的子节点作为下一个节点，而当前节点成为其子节点的父节点，因而有从 dfs(u, fa) 到 dfs(v, u) 的向深度搜索

2. 前序遍历 - PreOrder (先出根再出子节点)
    ```cpp
    void preOrder(TreeNode* root)
    {
        if(!root)
            return;
        printf("%d\n", root->val);
        for(auto child : root->children)
            preOrder(root->child)    //递归子树
    }
    ```

3. 后序遍历 - PosOrder (先出子节点再出根)
    ```cpp
    void posOrder(TreeNode* root)
    {
        if(!root)
            return;
        for(auto child : root->children)
            preOrder(root->child)    //递归子树
        printf("%d\n", root->val);
    }
    ```

 通过两次 dfs 我们可以求树的直径，一次 dfs 到直径的端点，再一次求出直径长度。

dfs 所使用的数据结构是栈，这种数据结构隐含在函数的递归调用中，而对于 bfs 所使用的数据结构是队列，我们就需要

---

##### 广(宽)度优先搜索 (bfs)
bfs 不同于 dfs 是深度优先的搜索，bfs是将同层的节点全部搜索过后再进入到下一次，既注重 "广度" 的搜索模式

1. 代码实现 (邻接表形式)
```cpp
bfs(s) 
{
    q = new queue();
    q.push(s), visited[s] = true;
    while (!q.empty()) 
    {
        u = q.pop();
        for(auto& v : tree[u])
        {
            if (!visited[v]) 
            {
                q.push(v);
                visited[v] = true;
            }
        }
    }
}
```

1. 层序遍历
    层序遍历就是一种典型的 bfs，先将同层的打印出来之后再深入一层，代码同上。当然也可以通过 dfs 实现层序这时候就要区分节点的层数

```cpp
//dfs版本层序
vector<vector<int> > ans;
void dfs(int u, int fa, int level)
{
    if(level > ans.size())
        ans.emplace_back(vector<int>())
    ans[level - 1].emplace_back(u);
    for(auto& v : tree[u])
    {
        if(v == fa)
            continue;
        dfs(v, u, level + 1)
    }
}
```

---

##### 树形dp
树形dp，顾名思义是在树上进行的dp，在dfs或bfs的过程中进行动态更新。例如通过树形dp求树的直径

```cpp
int dfs(int u, int fa)
{
    vis[x] = 1;
    int d1 = 0, d2 = 0;
    int tmp = 0;
    for(auto& v : tree[u])
    {
        if(v == fa)
            continue;
        tmp = dfs(v, u) + 1;
        if(tmp > d1)
        {
            d2 = d1;
            d1 = tmp;
        }
        else if(tmp > d2)
            d2 = tmp;
        d = max(d, d1 + d2);
    }
    return max;
}
```

---

#### **尚未熟练 - TODO**
  1. LCA问题
  2. 树状数组
  3. 线段树
  4. 树链剖分

---

### 计算机系统 - ICS

最近布置了 y86-64 的 PJ，学习了 CPU 的顺序以及流水线设计模式，开始做PJ。

#### PJ进展:
##### 设计模式 - C with Class
在面向过程的 Fetch -> Decode -> Execute -> Memory -> WriteBack 基础上套instr的类壳

##### 后端进度
1. 完成了Prototype设计
    - 目前 CC 的 OF 有一点 BUG
2. 完成了 UniTest 的 Generater
    - 准备用宏改为 gtest 移植到cpp上
- TODO:
    1. 完成 python 到 cpp 的移植
    2. 尝试添加寄存器
    3. 实现硬件栈
  
##### 前端进度
TODO中，思考如何设计
- 可选方案:
  1. Python 作为中间件用 jinja 模板替换
  2. C++ 作为后端 js 前端接口（学习中）
  3. CGI

---

## 科研进度 - CNN

### 目前方向
3D Instance Segmentation

### 论文收集
 1. (RDCNet)mini ResNet in 2d Instance Seg
 2. Attention Based 3d instance segmentation
 3. Learning Gaussian Instance Segmentation in Point Clouds
 4. 3D Sementic & Instance Segmentation via Salient Point Clustering Optimization

### TODO
1. 实现 ResNet Backbone
2. 复现 Fast R-CNN & Mask R-CNN
