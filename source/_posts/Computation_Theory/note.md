---
title: 计算理论基础笔记
date: 2021-07-05 18:42:20
index_img: /img/PNP.webp
category: [Computation Theory]
tags: [P=NP?, Computation Complexity]
math: true
---

# 计算理论基础

## 第一章 预备知识

重点：
- 符号表示，可能在问答题里面出现

### 1.1 定理及其证明方法

- 形式系统
1. **基本符号** *（常量符号、变量符号、运算符等抽象字符）*
2. **形成规则** *(构造各种语言的方法规则)*
3. **公理** *（无需经过证明，正确性得到公认的语句）*
4. **推理规则** *（用于得到新的合法语句）*

- *如何证明一个语句为真*

1. 每个语句或者是公理，或者由前面的语句自然导出
2. 最后一个语句就是所要证明的语句

- **定理证明方法**

1. 演绎法
2. 反证法/归谬法
3. 归纳法、第二归纳法

### 1.2 集合及其基本运算

1. 集合描述方法

- 列举法 $A=\{a,b,c,d\}$
- 模式表示法 $\{x|P(x)\}$

2. 集合运算及定理

- 定理1.9 德摩根定理

$\quad \quad \bar{A \cap B} = \bar A \cup \bar B$
$\quad \quad \bar{A \cup B} = \bar A \cap \bar B$

### 1.3 图和树简介

- **图** ：顶点集合以及边集合
- 有向图、无向图
- 通路、回路
- 邻接矩阵

- **树** 
- 树中每一个顶点到另一个顶点均有一条通路，称该顶点为树的根
- 树中一定没有回路
- 仅一个顶点(根节点)没有前导顶点
- 一定存在没有后继的顶点

### 1.4 字母表、字符串和语言

- 自然语言
-- 人类彼此相互交流的工具，由基本符号构成，如日语俄语等
- **形式语言**
-- 用于需要严格描述的领域，构成基础为“符号”



- **字符表**是符号的集合，记为 $\Sigma$
- $\Sigma$ 上的符号串
-- $\Sigma$ 上的符号以任意顺序拼接起来构成
-- 任何符号可以重复出现
- **定义1.23**
-- 对于任何给定的字符表 $\Sigma$，$\Sigma$ 上的字符串集合称作 $\Sigma$ 上的语言
- **定义1.24**
-- 设$L$是某个字母表上的一个语言，若 $L$ 中任何字符串都不是另一个字符串的真前缀，则$L$ 具有**前缀性质**
- **定义1.25**
-- 设 $L_{1}$ 为 $\Sigma_{1}$ 的语言, $L_{2}$ 为 $\Sigma_{2}$ 的语言，则  $L_{1}$ 和 $L_{2}$ 的连接 $L_{1}L_{2} = \{xy | x \in L_{1} and \ y \in L_{2}\}$
- **定义1.26**
-- **语言 $L$ 的闭包 $L^{*}$ **
-- 以任意次序连接L中任意多个字符串所组成的集合
-- 只要 $L$ 中包含至少一个元素, $L^{*}$ 就为无穷集


---


## 第二章 文法理论
重点：
- ⽂法分类（给定⼀个语⾔集合，判定是0123型⽂法，熟悉每个⽂法的判定⽅法）（最重要） 
- 上下⽂有关⽂法上下⽂信息的获得,1'型⽂法如何转化为1型⽂法

### 2.1 文法定义
- 四元组 $G=(V,T,P,S)$
1. V是变元符有限集 Variables
2. T是终结符有限集 Termination
3. P是生成式有限集 (Production?)
4. S∈V，为文法G的开始符 Start

### 2.2 派生
**直接派生**
若 $\alpha = \alpha_{1} A \alpha_{2}, \ \gamma=\alpha_{1}\beta\alpha_{2}$ ，且 $A\to\beta$ 为P中一个生成式，则 $\alpha \mathop{\Rightarrow}\limits_{G}^{}\gamma$
，称由 $\alpha$ 直接派生出 $\gamma$

**派生**
将 $\mathop{\Rightarrow}\limits_{G}^{}$ 扩充为 $\hat{\mathop{\Rightarrow}\limits_{G}^{}}$，则为派生

$\quad (\hat{\mathop{\Rightarrow}\limits_{}} 表示多步直接派生)$



### 2.3 文法分类
**1. 短语结构文法 PSG (0型文法)**
- **特点：** 不加限制
- **对应语言：** 短语结构语言 PSL
- **对应自动机：** 图灵机 TM
- **形式：** $\alpha\to\beta,\ \alpha,\beta\in(V \cup T)^{*}$ 且 $\alpha\ne\epsilon$

**2. 上下文有关文法 CSG (1型文法)**
- **特点：** 每个终结符$\to$终结符，满足前者偏序后者 ($\leq$)
- **对应语言：** 上下文有关语言 CSL
- **对应自动机:** 线性有界自动机 LBA
- **形式：** $\forall \alpha\to\beta\in P$ , 满足 $|\alpha|\leq |\beta|$ 并且 $\alpha,\beta\in(V \cup T)^{*}$ 且 $\alpha\ne\epsilon$

**3. 上下文无关文法 CFG (2型文法)**
- **特点：** 都有变元推出变元或终结符或者变元与终结符的连接
- **对应语言：** 上下文无关语言 CFL
- **对应自动机：** 下推自动机 PDA
- **形式：** 对所有P中生成式都有，$A\to\beta \quad \beta\in(V \cup T)^{*},\ A \in V$

**4. 正规文法 RG (3型文法)**
- **特点 ：** 变元推出终结符或推出终结符+变元
- **对应语言：** 正规语言 RL
- **对应自动机：** 有穷自动机 DFA
- **形式：** 对所有P中生成式都有，$A\to a\ 或\ A\to aB \quad a\in T \cup {\epsilon},\ A,B \in V$




### 2.4 文法等价

对于两个文法 $G_{1}=(V_{1},\ T_1,\ P_1,\ S_1)$ 与 $G_{2}=(V_{2},\ T_2,\ P_2,\ S_2)$，若$L(G_1)=L(G_2)$，则文法等价


### 2.5 1°型文法
- **特点：** 看形式
- **形式：** 对文法 $G=(V,\ T,\ P,\ S)$，若P中每个生成式都有 $\alpha_1 A \alpha_2 \to \alpha_1 \beta \alpha_2$形式，$A \in V, \ \alpha_1,\alpha_2\in(V \cup T)^{*}$, $\beta \in {(V \cup T)}^{+}$ 


#### 1、 1型文法和1°型文法转换

- 定理：对于任何1型文法G，一定存在一个 $1^{°}$ 型文法G',使得L(G)=L(G') 反之亦然。

- $\Rightarrow$ 
对于任何生成式 $\alpha_1 A \alpha_2 \to \alpha_1 \beta \alpha_2$ ,恒有 $|\alpha_1 A \alpha_2| \leq |\alpha_1 \beta \alpha_2|$ 
即 $1^{°}$ 型文法一定是1型文法

- $\Leftarrow$ 
- 第一步：将G变为G''
    - 这一步构造出生成式只有两种形式的G''
    - 其中 $V^{''}=V \cup M, M=\{[a] | a\in T\}$
    - $P^{''}=\overline{P} \cup \{ [a] \to a | a \in T \}$

- 第二步：G'' 中生成式形式分类讨论
    - （1） $A\to\beta$ (A∈V，或为新引入变元[a])，其已经是1°文法
    - （2）$A_1A_2...A_n\to B_1B_2...B_n,\quad (n\ge 2,\ m\ge n)$ 
        - 解决方法：引入一组新变元用于过渡
        - 1. $A_1A_2...A_n \to C_1A_2...A_n$ 
        - 2. $C_1A_2...A_n \to C_1C_2...A_n$ 
        - 3. $C_1C_2...C_{n-1}A_n \to C_1C_2...C_n$ 
        - 4. $C_1C_2...C_n \to B_1C_2...C_n$ 
        - 5. $B_1C_2...C_n \to B_1B_2...C_n$ 
        - 6. $B_1B_2...B_{n-1}C_n \to B_1B_2...B_n$
        - 完成 $A_1A_2...A_n\to B_1B_2...B_n$



### 2.6 上下文在文法中的体现
#### 上下文有关文法（1型文法）的上下文
- 可用1°型文法解释，$\alpha_1 A \alpha_2 \to \alpha_1 \beta \alpha_2$，其中$\alpha_1\ 和\ \alpha_2$ 是A的上下文，在该上下文语境中A可替换为β
- 在另外上下文语境中可替换为别的字符串，例如另有生成式 $\alpha_{1'} A \alpha_{2'} \to \alpha_{1'} \gamma \alpha_{2'}$ 

#### 上下文无关文法（2型文法）的上下文
- $A\to \beta$ 变元A不管出现在任何地方都可替换为β，与上下文无关


### 2.7 语法分析树
- 定义：//TODO


#### 边缘
- 对于派生树，其叶节点标记从左到右收集起来的字符串，称为该派生树的边缘

- **相关定理：** G为上下文无关文法，那么S可以派生出α当且仅当在G中存在一颗边缘为α的派生树
证明: //TODO

#### 多义和固有多义
不重要 TODO


----


## 第三章 有穷自动机和正规表达式
重点
- 掌握⼏类⾃动机的特点（FM, NFM, 有空动作的FM），⼏种FM之间如何进⾏变换（等价性），例：如何进⾏ 空动作的消除（空闭包的转换） 
- 掌握正则表达式和正规集，正规集和有穷⾃动机的关系（实际上在第四章） 
- 了解摩尔机和米里机的定义和功能（⾮重点）



### 3.1 确定有穷自动机 DFA
#### 1. 定义
- 有穷自动机（FA or DFA）是一个五元组 $M=(Q,\ \Sigma, \delta,\ q_0, F)$
    - 1. Q是有穷状态集
    - 2. $\Sigma$ 是有穷的输入字符表
    - 3. $\delta$ 是转移函数，将 $Q\times \Sigma$ 映射到Q
    - 4. $q_0\in Q$ 是初始状态
    - 5. $F\subset Q 是终结状态$

#### 2.扩充转移函数
对于 FA $M=(Q,\ \Sigma, \delta,\ q_0, F)$ 其扩充转移函数是 $\hat\delta$ 是$Q\times\Sigma^*$ 到 Q 的映射
- 1. $\hat{\delta}(q,\epsilon) = q$ 
- 2. $\hat\delta(q,wa)=\delta(\hat\delta(q,w),a)$ 

- 递归定义
接受一个输入，然后进行状态转移，再接受下一个。输入一个串得到最后状态。

#### 3.有穷自动机接受语言

$L(M)=\{x| \delta(q_0,x)\in F\}$
若 $\delta(q_0,x)=p\in F$ ，则称字符串x，被M接受，意义上来理解，就是输入x，M从q0转移到终结状态F



### 3.2 非确定有穷自动机 NFA
#### 1. 定义
- 非确定的有穷自动机（NFA）五元组 $G=(Q,\Sigma,\delta,q_0,F)$
    - 1. Q是有穷状态集
    - 2. $\Sigma$ 是有穷输入字符表
    - 3. $\delta$ 是非确定的状态转移函数，$Q\times \Sigma$到$2^Q$ 上的映射
    - 4. $q_0\in Q$ 是初始状态
    - 5. $F \subset Q$ 是终结状态集

#### 2. 转移函数一般形式：
$\delta(q,a)=\{p_1,.....,p_k\} \quad p_i\in Q$ 或者 $\delta(q,a)=\emptyset$
    
#### 3. 扩充转移函数
类似有穷自动机定义，输入一个串，对每个字符进行状态转移，最后得出的最终状态**集合**

#### 4. 接受条件
如果 $\delta(q_0,\ x)\cap F$ 非空，则称字符串 $x$ 被 $M$ 接受



### 3.3 NFA与DFA的等价性
- 当给定某类中的一个有穷自动机，一定存在另一类中的一个有穷自动机，两者接受同样集合，则称二者等价。

#### 1. NFA与DFA等价
- 证明： 构造法 构造 DFA，其定义为
    - 对于Q',其将NFA中Q的每一个子集作为Q'中的一个状态，若子集为 $\{q_1,q_2,..,q_n\}$ ，则Q'中状态记为 $[q_1,q_2,..,q_n]$ 
    - 对于 $\delta^{'}$ ，定义为$$\delta^{'}([q_1,q_2,..,q_n],a) = p_1,p_2,..,p_n \\ iff \\ \delta(\{q_1,q_2,..,q_n\},a) = p_1,p_2,..,p_n $$ 

进一步证明 TODO

#### 2. NFA至DFA的转换
构造方法，从NFA出发，并不需要直接一步写出Q的幂集，而是看NFA中存在哪些状态。
例题3.4

#### 3. 具有$\epsilon$动作的有穷自动机
在不接受输入符号，输入为$\epsilon$ 时能做转移动作
即转移函数 $\delta$ 扩充至$Q\times (\Sigma \cup \{\epsilon\})$ 到 $2^Q$ 的映射

- $\epsilon -CLOSURE(q)$
直白的说，就是如果NFA只接受空动作能够到达的状态集合

- 定义
    - 1. $q\in \epsilon -CLOSURE(q)$
    - 2. 递归，若$p\in \epsilon -CLOSURE(q)$，则$\delta(q, \epsilon)\in \epsilon -CLOSURE(q)$
    - 规定：$\epsilon -CLOSURE(P) = \mathop{\cup}\limits_{q\in P}\epsilon -CLOSURE(q)$

- 扩充函数
非简单扩充，就是说 $\hat\delta(q,a) \neq \delta(q,a)$，因为空输入也可以转移状态，其他差不多

- 接受语言
$L(M)=\{w|\hat\delta(q_0,w) \cap F \}$ 非空
*增加空动作没有增加表达能力，即有空动作和没有空动作的NFA等价*

- 空动作NFA与NFA等价
构造法，对具有空动作的NFA M构造 $M'=(Q',\Sigma^{'},\delta^{'},q_0,F^{'})$，

$\hat \delta(q,a)$ 即 $\delta(\epsilon -CLOSURE(q), a)$
- $\delta^{'}(q,a) = \hat\delta(q,a)$
- $$ F^{'}=\left\{
    \begin{array}{rcl}
        F\cup \{q_0\} && {如果\epsilon-CLOSURE(q_0)\cap F非空}\\
        F && {否则}
    \end{array} \right. $$
证明对 |x| 进行归纳 TODO



### 3.4 正规表达式和正规集
- 正规表达式递归定义
    - 1. $\phi$ 是一个正规表达式，代表空集
    - 2. $\epsilon$ 是一个正规表达式，代表集合 $\{\epsilon\}$ 
    - 3. 对于 $\Sigma$ 中每个符号a，a是正规表达式，代表集合{a}
    - 4. 如果r和s是正规表达式，分别表示集合R和S，则(r+s),(rs)和(r*)是正规表达式，分别表示 $R \cup S$、$RS$ 和 $R^*$ 

正规表达式代表的集合称为正规集

<img src="/uploads/upload_e70fbfc8866d389b084873dd20ba2e72.png" style="height: 300px;">

- 运算优先级
$* > 连接 > +$

- 对应自动机
有穷自动机 DFA
有穷自动机所能接受的集合类和正规表达式所能表示的集合类统称为正规集类

- 定理3.3 r为正规表达式，则有一个具有空动作的NFA接受L(r)
归纳法证明，归纳r的构造次数
- 基础：r构造次数为0，即r是 $\epsilon$ 、$\phi$ 、$\Sigma$ 中某个元素a
- 归纳
    - r = r1 + r2
    归纳假设有 M1 接受 r1, M2 接受 r2
    则构造一个M将两个M1,M2并起即可，形式说明TODO
    - r = r1r2
    归纳假设有 M1 接受 r1, M2 接受 r2
    则构造一个M先过M1再过M2即可，形式说明TODO
    - r = r1*
    归纳假设有 M1 接受 r1,
    则扩展一下M1，让其终结状态可以回到开始状态重复判断即可，形式说明TODO
    
- 定理3.4 如果L被DFA接受，则L可用正规表达式表示
对各状态进行编号，记 $R_{ij}^k=\{x\mid \delta(q_i,x)=q_j，中间不经过编号大于k的状态 \}$ ，有递推式 $R_{ij}^k=R_{ik}^{k-1}(R_{kk}^{k-1})^*R_{kj}^{k-1}\cup R_{ij}^{k-1}$  ，然后归纳证明 $R_{ij}^k$ 可用正规表达式表示



### 3.5 具有输出的有穷自动机
1. 摩尔机
2. 米里机

非重点



---



## 第四章 正规文法与正规集的性质(重要)
- 缩胀定理（重点），反证法证明 
- 极⼩化的处理，掌握极⼩化的算法（过程）（明示了快背），如何优化有穷⾃动机 
- ⻨⻄尔-尼诺德定理，需要掌握 


### 4.1 正规文法与有穷自动机的关系

- **Th4.1**
-- 设 $L$ 被某个正规文法 $G$ 产生，则 $L$ 可被某个有穷自动机接受


- **Th4.2**
-- 设 $L$ 被某个DFA $M$ 接受， 则 $L$ 可被某个正规文法产生

构造方法：
- $A\to aB$ 对应 $\delta(A,a)=B$
- $A\to a$ 对应 $\delta(A,a)=f\in F$

### 4.2 正规集的缩胀定理

1. **有穷自动机表达能力有限**

2. **Th4.3 正规集的缩胀定理(pumping Lemma)：存在整数 $k \geq 0$ ，对于任意串 $x, y, z$ 这里 $xyz \in A$， 只要$|y| \ge k$ ，就可以将 $y$ 写成 $y=uvw, \quad v \ne \sigma$ ，并且对于任何 $i \ge 0$，都有 $xuv^{i}wz \in A$**
- 证明：定理的直观含义为：如果 $A$ 是正规集，那么当它的元素含有**足够长**的子串 $y$ 时（x与y的长短不重要）， $y$ 就一定包含一个非空的子串 $v$ （$u, w$ 的长短不重要），这个子串 $v$ 可以“膨胀”任意多次 （$i > 0$），或者被“删除” （$i = 0$），而 $xuv^{i}wz$ 仍然属于 $A$

- 设 $k$ 是接受正规集 $A$ 的 $DFA$ 状态数，因为 $y$ 的长度大于或等于k， 则 $DFA$ 在扫视 $y$ 的过程中，必然出现重复的状态，串 $v$ 就是该状态相邻的两次出现过程中扫视过的子串。

$$
\sigma(q_{1}, u)=p, \sigma(p, v)=p, \sigma(p, w)=q_2
$$

其余的推理过程与例2.10的分析相同

- *正规集的缩胀定理经常用来指明某些集合不是正规集，通常就是反证法，大家都懂的。*

### 4.3 正规集的封闭性质与判定算法

- 在并、连接和闭包运算下是封闭的
- 在补运算下封闭，即若 $L$ 是正规集，且 $L\subseteq\Sigma^{*}$ ， 则 $\Sigma^{*}-L$ 也是正规的
- 在交运算下封闭
- 在商运算下封闭（暂且理解：两个正规集做商运算，其结果必然是正规集）



- *Th4.9*
具有n个状态的有穷自动机具有如下性质：
    - 1)它接受的集合非空，当且仅当它接受一个长度小于n的字符串 
    - 2）它接受的集合是无穷的，当且仅当它接受一个长度为1的字符串，这里 $n \leq l < 2n$
- *两个有穷自动机是否等价是可判定的*

### 4.4 有穷自动机的最小化

**一个减少状态数的思路：给定 $DFA \ =(Q, \Sigma, \delta, q_{0}, F)$，根据等价关系构造出一个 $DFA M/ \equiv$，该 $DFA$称为 $M$的商自动机**

- **判断两个状态等价：** 对于 $p, q \in Q$， 若对于每个 $x \in \Sigma^{*}, \quad \delta(p, x) \in F$当且仅当 $\delta(q,x) \in F$， 就称 $p, q$ 等价，记作 $p \equiv q$

**极小化算法过程：**
-- *在 $DFA$ 的状态集上确定所有的状态对是否等价*
1. 对所有状态对 ${p, q}  (p, q \in Q)$画一张表，开始时中每个格子均为空白（未做标记）
2. 对一切 $p \in F, q \notin F$ 的 ${p, q}$，在相应格子上做标记（例如画一个X）
3. 重复下述步骤，直到表中内容不再改变为止：如果对于某个 $a \in \Sigma$， 存在一个未被标记的状态对 $\{p, q\}$，使得 $\{\delta(p,a),\delta(q,a)\}$已做标记，则将 $\{p, q\}$ 做标记
4. 完成1，2，3之后，所有未被标记的状态对都是等价的，即 $p \equiv q$

### Myhill-Nerode 关系
**判定方式**
- 对某个集合$A \subset \Sigma^*,\quad$ R为$\Sigma^*$上的等价关系。若R满足
    - 1. 是右不变的
    - 2. 细分A
    - 3. 具有有穷指数

- 则称R为A的 Myhill-Nerode 关系

### Myhill-Nerode 定理
- A是一个正规集
- $\Sigma^*上存在关于A的MN关系$
- $R_A$ 具有有穷指数



---


## 第五章 上下文无关文法与下推自动机
重点:
- 了解化简（作业题） 
- ⼀定要会两种范式（乔姆斯基范式&葛雷巴赫范式） 
- 构造下推⾃动机（作业题）

### 5.1 上下文无关文法的化简
检验文法$G=(V, T, P, S)$中是否有无用符号 （变元或终结符），若有，则将其消除。
#### 无用符号
- $X \in V \cup T$ 但X不出现在任何由S派生出的字符串中。
- $X \in V$ 但X不能派生出任何终结符号串

- Th5.1 不带无用符号的CFG可生成所有非空CFL
 
    化简思路
    - 1. 找到无用符号（一类二类）
    - 2. 删除无用符号
    - 3. 返回1继续检查，直到不产生无用符号为止
    
    PPT思路
    - 1. 首先删除二类无用符号 
    - 2. 接着删除一类无用符号
    - 3. 返回1检查，直到不产生无用符号


#### $\epsilon$ -生成式
形如 $A \to \epsilon$ 的生成式，如果 $\epsilon \in L(G)$ 那么不能删，其余都可以删除。
- 可为零
如果在CFG中，A属于变元集合，如果有A派生出$\epsilon$则称A为可为零的。

- Th5.3 可为零的可判定性
对于CFG中任意变元是否可为零是可判定的
判定思路：

-  1. 对$A \to \epsilon$ 即trivial的本来就可为零的，将A加入Z
- 2. 对于一切生成式 B，有$B \to \alpha$ 如果 $\alpha \in V^+$在中所有变元均在Z中，将B加入Z
- 3. 重复1，直至没有元素加入Z为止
    
Z 中元素均为可为零的元素

- Th5.2 不带无用符号且没有$\epsilon$-生成式的CFG可以生成所有不包含空串的CFL
**不会证 ；）**


#### 单一生成式
形如 $A \to B$ （A、B皆为变元）的生成式

#### 结论
上面说的三个都可以消掉



### 5.2 上下文无关文法的范式

#### 乔姆斯基范式 Chomsky （CNF定理）
任何不包含$\epsilon$的CFL，都可由生成式仅为 $A \to BC$ 或 $A \to a$ （A，B，C为变元，a为终结符）形式的文法产生
（化为乔姆斯基范式，例题5.3）
a

#### 格雷巴赫范式 Greibach (GNF定理)
任何不包含$\epsilon$的CFL，都可由生成式仅为$A \to a\alpha$ (a为终结符,$\alpha$ 为变元串，包含空串）形式的文法产生

//TODO



### 5.3 下推自动机
下推自动机（简称PDA）是一个七元组 $M=(Q,\Sigma,\Gamma, \delta, q_0, Z_0, F)$
- Q是有穷状态集
- $\Sigma$是有穷的输入字母表
- $\Gamma$是有穷的栈符号表
- $\delta$是转移函数，将$Q \times (\Sigma \cup \{epsilon\} \times \Gamma)$ 映射到$(Q\times \Gamma^*)$ 的有穷子集
- $q_0 \in Q$ 是初始状态
- $Z_0 \in \Gamma$ 是栈底符号
- $F \subset Q$ 是终结状态集

#### 转移函数
三元组 $\delta(q,a,Z) = \{(p_1,\gamma_1), (p_2, \gamma_2),...,(p_m, \gamma_m)\}$ 其中 q, a 一个状态一个输入字符，Z为栈顶符号

状态由 $q \to p$，栈顶符号由 $Z \to \gamma$
转移动作不确定
- 函数值有m种选择 （m可以为0）
- 读头不动也可以有函数值

#### 瞬时描述

$(q_0,w,Z_0) \mathop{\vdash}\limits_{M}^*\ (p, \epsilon, \gamma)$ 表示从状态 $(p, \gamma) \in \delta(q_o, w, Z_0)$，上一个字符为w，下一个字符为 $\epsilon$

即由一个瞬时描述 ID 转移到下一个 ID

#### 按终结方式接受

若M是一个PDA，集合$L(M)=\{w|(q_0,w,Z_0) \mathop{\vdash}\limits_{M}^*\ (p, \epsilon, \gamma)\}$
则称M按终结状态方式接受的语言

- 接受状态
还是由初始状态到接受状态，和栈中符号没什么关系，栈符号只影响状态转移
*不过如果输入串未读完栈就变空，无法进行状态转移，则w不可能被接受。*


#### 按栈空方式接受
- 接受状态
顾名思义，读完之后栈空了就接受了，终结状态则不影响是否接受。

构造PDA接受$0^n1^n$，例题5.5
- 例题 5.6、5.7




### 5.4 下推自动机与上下文无关文法的关系
- 下推自动机接受的语言类是上下文无关文法 CFL (2型文法)




---


## 第六章 上下文无关语言的性质
重点
- 缩胀定理/ogden定理（尤其考察后者）
- 考察给⼀个语⾔判断是否是上下⽂⽆关语⾔ 封闭属性 
- 成员资格判定问题（PPT）,CYK算法

### 6.1 CFL缩胀定理
回忆一下正规集缩胀定理
正规集中每个足够长的字符串，都包含一个短子串可扩张任意多次，所得字符串仍然属于该正规集

- CFL 缩胀定理
在CFL中，每个足够长的字符串，都包含两个相距不远的短子串，两个子串可以扩充任意多次，所得子串仍然属于CFL

**形式描述：**
对于每个CFL，都存在正整数 $k \ge 0$ 使得对每个$z \in L$ 只要 $|z| \ge k$ 就可将z划分为5个子串，
满足以下三个条件
1. 对任何的$i \ge 0$ 都有$uv^iwx^iy \in L$
2. $|vx| \ge 1$
3. $|vwx| \le k$

（其中 k = $b^{|V| + 1}$，其中b是生成式右侧符号数的最大值）
看计算理论导引P77，写的很清楚


### 6.2 Ogden定理
**形式描述：**
L为CFL，存在整数$k \ge 0$，使得对每个$z \in L$，并且在z中标出k个或多于k个特别符号，将z写成z=uvwxy，且满足
1. v和x一起至少包含一个特别符号
2. vwx之多包含k个特别符号
则对任何$i \ge 0,\ uv^iwx^iy \in L$

例题6.4 


### 6.3 CFL封闭性质

回忆一下RL的封闭性质，RL在以下运算下封闭
- 交并补
- 连接
- 闭包
- 商

**CFL在以下运算下封闭**
- 并 
对G1,G2，生成式的开始元S1，S2
构造 G3 $S \to S1 | S2$

- 连接
对G1,G2，生成式的开始元S1，S2
构造 G3 $S \to S1S2$

- 闭包
对G1,G2，生成式的开始元S1
构造 G3 $S \to S1S|\epsilon$

**注意 CFL 在 *交* $\cap$ 和 *补* $\hat{ }$ 运算下不封闭**
- 交
$L1= {a^ib^ic^j|i \ge 1, j \ge 1}$, $L2= {a^ib^jc^j|i \ge 1, j \ge 1}$
两者是CFL
但其交集$L1 \cap L2= {a^ib^ic^i|i \ge 1}$ 不是CFL，可由Pumping LEmma 证得

- 补运算
交运算，可化为补+并的形式，若补运算封闭，则由于并运算封闭，可证得交运算封闭，推出矛盾。

#### CFL和正规集的交是CFL
- 定理6.6 若L是CFL，R是正规集，则$L\cap R$是CFL


### 6.4 CFL判定算法

#### 给出CFG G=(V, T, P, S), L(G)是否为空和是否有穷问题是可判定的
- L(G) 是否为空
    - 检验S是否能派生出终结符号串
    - 若能，则L(G)非空；不能则为空
- L(G)是否有穷
    - 对G的Chomsky范式，以变元为顶点画出有向图
    - 原问题 $\Leftrightarrow$ 该有向图是否有回路
    - 即X的最长路径长度为l，则从X派生出的终结符号串长度不超过$2^l$ (归纳假设)

图论算法判定一个有向图是否有回路，所以L(G')是否有穷，是可判定的

### 6.5 成员资格问题
**给定一个CFG G和一个终结符串x，问x是否属于L(G)**
暴力算法思想，对于G的Greibach范式文法，从S生成式推出右侧的第一个终结变元和x串的第一个符号比较，如果对应就把右侧第二个变元的推出式拿出重复上述操作，直到接受或拒绝为止，时间复杂度$O(m^n)$

#### CYK算法
时间复杂度 $O({|x|}^3)$
倒着的树，看Vij表，懂的都懂
（区间DP）
![](/uploads/upload_e2b3e93174f7cd571038ce381a21f95c.png)


---


## 第七章 图灵机
重点
- 构造语⾔的图灵机（会考的稍微复杂）
- 图灵机构造技术 其他类型的图灵机（多带的、⾮确定、双栈机） 
- 枚举器，正则次序，对偶产生器

### 7.1 图灵机基本模型
确定单带图灵机是一个9元组 $M=(Q,\Sigma,\Gamma,\vdash, \diamond,\delta,s,t,r)$
- 1. Q有穷状态集
- 2. $\Sigma$有穷输入字母表
- 3. $\Gamma$有穷的带字母表
- 4. $\vdash$ 左端标记
- 5. $\diamond$ 空白符号
- 6. $\delta$ 转移函数
- 7. $s \in Q$ 开始状态
- 8. $t \in Q$ 接受状态
- 9. $r \in Q$ 拒绝状态

L 表示读写头左移，R表示右移，对于左端标记，永远有$\delta(p,\vdash)=(q,\vdash,R)$

- 递归可枚举集
TM M接受的语言，称为递归可枚举集

- 递归集
被完全 TM M 接受的语言，称为递归集

- 完全TM
对一切输入均能停机（达到接受或拒绝状态）

例题做做做


### 7.2 图灵机构造技术

#### 有限控制器中的存储
- 元组表示状态，将带上符号吸收到状态中

#### 移动
- 将带上符号不断吸收到状态中，不断写下，达到整体移动的目的

#### 多道技术
- 保存处理更复杂的数据，例如计算$n^2$

#### 查讫符号
- 即给带上符号打标记，利用到多道技术
- 常用于区分某个符号是否查过
- 例7.7 构造一个识别 $l={wcw|w \in \{a,b\}^+}$的 $TM$

#### 子程序技术
- 懂的都懂，大概不考
构造TM M实现乘法运算


### 7.3 图灵机的变型

#### 双向无限带
- 将图灵机的单向无限延伸扩大到双向无限延伸
    - 无左端标记$\vdash$
    - 其余符号和功能均与单向无限带TM相同

并没增加其表达能力，和单带相同
- 可以构造一个双带单向无限图灵机，识别能力与双向无限图灵机相同（定理7.1）

#### 多带
- 用一个控制器控制k条带，在每条带上有独立的读写头
**和多道技术的区别**
多道技术是一个控制器多个带，这个是多个控制器多个带。
- 给一些证明带来许多方便
- 并没增加其表达能力，和单带相同


#### 非确定图灵机
**确定的图灵机 $\delta$ 是单值函数，非确定性图灵机增加非确定性动作，并未改变其识别能力**
- 可以证明确定型图灵机与非确定型图灵机的等价性
定理7.3 若L被一个非确定的TM $M_1$ 接受，则L也被某个确定的TM $M_2$ 接受。

#### 双栈机
其是特殊的三带图灵机
一个带用于输入，只读不写
另外两个用来模拟栈
- 读头右移，可写任意符号 （进栈）
- 读头左移，只能写空白符 （退栈）
读头指向为栈顶，左端标记右边那个为栈底

- 任意的单带图灵机能被双栈机给模拟
右移时，右栈弹栈，左栈压栈。反之类似

**下推自动机是单栈机，所以其能力比图灵机小， 即$PDA < TM$**
**图灵机是下推自动机的扩充，能接受其不能接受的语言**

#### 带字母最少的图灵机
- 限制带字母表上只有 $0,\ 1,\ \diamond$ 三个符号
- 和任何TM等价

#### 作为枚举器的图灵机
- 用一条带专门作为输出带，带上符号一旦写上就不改动，带头一直往右，永不回头。

#### 枚举器和TM的等价
- 设对某个枚举器 $M_1,\ L=G(M_1)$, 则存在TM $M_2$ 使得 $L(M_2) = L$
    - 构造M2，M2比M1多一条输入带，比较M2的输入和M1产生的串，如果相等则接受，不相等则与M1产生的下一个串继续比较，这样进行。
    - 因为M1产生的串都是M2能接受的，M1不能产生的串都是M2不能接受的（不停机）所以 L(M2)=G(M1)=L

#### 对偶产生器
- 一个过程，以i+j不减的顺序列出正整数对(i,j)

#### 字母表 $\Sigma$ 上串的正则次序
- 先按长度排序
- 再按字典序


### 7.4 图灵机与0型文法的关系
图灵机对应0型文法



---


## 第八章 不可判定性
重点
- 递归集和递归可枚举集的属性 
- 两个不可判定问题（停机问题+成员资格问题） 
- 通⽤图灵机的概念，图灵机的⼆进制编码 
- Rice定理

### 8.1 递归集和递归可枚举集性质
#### **补集**
- 一个递归集的补集仍然是递归集
因为完全TM
调换接受拒绝状态

#### **并集**
- 递归集的并是递归的，递归可枚举集的并是递归可枚举的
    - 对于递归集，其是由完全TM生成的语言集合那么对于输入串，可先经M1进行验证，若接受则接受，若不接受则进第二个M2，重复上述过程。 （这里的保证是因为他们是完全TM，可以停机）
    - 对于递归可枚举集，构造非确定M3',对输入分别在M1，和M2上验证，如果有一个接受则接受，可见M3‘的停机问题也是不可判定的，为一般TM。

#### **交集**
- 递归集的交是递归的，递归可枚举集的交是递归可枚举的

看ppt的图，应该很清楚

- 若语言 L 和 L补 都是递归可枚举的，则L（和L补）是递归的



### 8.2 通用图灵机和两个不可判定问题

#### 通用图灵机
模拟任何图灵机的图灵机，将某个TM作为通用图灵机的输入来看待
- 需要对TM有统一的、合理的编码
- 在给定输入串上，模拟TM的动作
- 给定TM接受，则该TM接受这个TM和这个输入的二元组

#### 图灵机编码
M#w

#### 关于停机问题的不可判定性
- 没有一个算法在有限步之内能够判断一个TM M在给定的输入串x上是否能停机。
    -  1. 接受状态
    -  2. 拒绝状态
    -  3. 无限循环

- **任意给定TM M对任意给定输入串x是否停机的问题是不可判定的**
自指悖论（类似**罗素悖论**的方法）

**证明**

- **Step 1 TM编码**
    - 由于可对TM进行编码，所以任何TM可以表示为01串
    - 而我们可以把任何零一串看作一个TM
    - 在上述规定下，可按正则次序列出所有TM 
    $M_{\epsilon},\ M_0,\ M_1\ ,M_{00},\ M_{01}...$
    显然真正的TM一定出现在此序列中至少一次
    

- **Step 2 二维表标记**
    - 考虑无穷维的二维表，其顶端遍历 $\{0, 1\}^*$ 的正则序列，左端遍历 TM，用H (Halt) 表示停机，用L (Loop) 表示不停机，在对应位置做上标记

- **Step 3 开始证明**
    - 假设存在完全TM K，以Mx#y为输入，能够判断Mx在y上是否能够停机。如果停机，则 K 接受 Mx#y；否则，拒绝
    - 构造另一个TM N，其输入为 $x \in \{0, 1\}^*$ 其完成以下任务
        - 从x找到Mx，将Mx#x写到其带上
        - 在 Mx#x 上模拟K的动作，如果K接受，则其就进入循环（不停机），如果K拒绝，他就接受。
    - 那么根据N的定义，如果N在x上停机，则代表K拒绝，则代表Mx在y上不停机。

- **Step 4 推出矛盾**
    - 因为N也是图灵机，假设其编码为y，在正则序列中出现为My，如果N在y上停机，则代表My在y上不停机，而My就是N，导致矛盾。矛盾起因是K的存在性
所以不存在这样的TM能够判断M在任何输入下是否停机，即停机问题是不可判定的

#### 成员资格问题的不可判定性
- **对于任意给定 TM M 和输入串x，M是否接受x的问题是不可判定的**

    - 1. 存在完全的 TM K，它能对任意的M和x，判断x是否属于L(M)。若$x \in L(M)$，则K接受$M\#x$；否则拒绝

    - 2. 构造N，使得如果x在M上达到接受或拒绝的停机状态，则N接受。可以看出N是判断M在x上是否停机的TM。

    - 3. 现在对M输入N#x，则N是否接受x等价于x在M上是否停机，而停机问题是不可判定的，所以成员资格问题也不可判定。




### 8.3 归约方法和Rice定理
- **给定TM M其是否接受空串的问题是不可判定的**

将HP的不可判定性导出问题B的不可判定性
- HP Halt Problem 停机问题
- B 其他问题


#### Rice定理
- r.e.集合类的任何一个非平凡性质都是不可判定的

- **Step 1 准备** 
    - 设 P 是 r.e. 集合类上的一个非平凡性质，不失一般性，假设空集不具有性质P，则因为P的非平凡性，必定存在一个集合A满足P，即P(A) = T设K是接受A的TM

- **Step 2 归约HP到集合 $\{M|P(L(M)) = T\}$**
    给定M#x, 构造TM M'，其按以下步骤进行
    - 对于TM的输入y，将其放在一个道上
    - 将x写在另一个道上
    - 在M上模拟x的动作
    - 如果M在x上停机，则在K上模拟y的动作
    - 如果K接受y，则M'接受y

- **Step 3 推出矛盾**
    - 显然，M和M'的停机问题相关联，如果停机有 M' 和 K 接受一样的集合。
    - 所以有 M 在 x 上停机，可推出，L(M') = A，可推出 P(L(M')) = T
    - 反之则不停机，P(L(M')) = F
    - 这就得出了停机问题到该问题的归约，但停机问题不可判定，所以其非平凡性质也不可判定。




### 8.4 关于CFL的不可判定问题


### 8.5 Post对应问题的不可判定性及其应用



---


## 第九章 线性有界自动机和上下文有关语言
重点
- 给定语⾔，构造LBA 
- LBA对停机问题的判定问题

各种机器对应的不同⽂法，⽐如FA对应CFG，图灵机对应0型，PDA对应CFL

### 9.1 线性有界自动机 LBA
- 对TM的读写头范围加以限制
- 左右端都有标记
- 接收机和小于TM接受的集合类

线性有界自动机 LBA 是9元组 $M=(Q,\ \Sigma, \Gamma, \vdash,\ \dashv, \delta,\ s,\ t,\ r)$
- 1. Q 有穷状态集
- 2. $\Sigma$ 有穷输入字母表
- 3. $\Gamma$ 有穷带上字母表
- 4. $\vdash$ 左端符号
- 5. $\dashv$ 右端符号
- 6. $\delta$ 状态转移函数
- 7. s 开始状态
- 8. t 接受状态
- 9. r 拒绝状态

***例题9.1***
思路：
- 1. 查讫符号打标记后找到中心
- 2. 对消

### 9.2 LBA 和 CSL 的关系
- 若L是CSL，则L可被某个LBA接受

将S派生出来的各种字符串（在下道），与上道的w比较，若相等则接受

### 9.3 CSL的性质及其和递归集的关系
#### CSL封闭性
- 并
- 连接
- 正闭包（因为CSL不包含 $\epsilon$，所以L1为CSL则其闭包 $L_1^*$ 不是CSL）
- 交运算

#### 每个CSL都是递归的
思路：
因为输入串长度有限，并且两端封闭，所以总的情况数是有限的为$k(n+2)l^n$ 种，那么用双带，一带正常执行，令一带计算执行步数，如果超出则说明进入循环，则拒绝。所以有CSL是递归的

#### 存在递归集，不是CSL


### 9.4 语言类之间的关系

1. RL(3型文法RG)
2. DCFL
3. CFL(2型文法CFG)
4. CSL∪\{ε\}(1型文法CSG)
5. 递归集
6. r.e.集（递归可枚举集）(0型文法PSG),如成员问题所对应的字符串
7. 非r.e.集，如FIN



---



## 第十一章
重点
- 给定语⾔：判断是P还是NP
- P与NP的封闭性证明 常⻅的NPC问题的推导和证明(重点)
    - 证NP问题
    - 证归约性 
- P NP NPC NPHARD的概念 
- PSPACE==NPSPACE-NPSPACEhard 
- L-NL（构造：利⽤指针） 
- 后⾯的层次定理&布尔电路不考

### 层次概览

![](https://codimd.s3.shivering-isles.com/demo/uploads/upload_81564f07be5cb20ec62f5761169626dc.png)

![](https://codimd.s3.shivering-isles.com/demo/uploads/upload_aeeccf9bef7be94af30f6875bdf5d5e1.png)

$$L \subset NL = coNL \subset P \subset NP \subset PSPACE = NPSPACE \subset EXPTIME$$

### P类
- 定义： P是确定型单带图灵机在多项式时间内可判定的语言类

$$P = \mathop\cup\limits_{k} TIME(n^k)$$

#### **PATH $\in$ P**
PATH 问题，即G（有向图）中两点判定是否存在有向路径
用BFS算法，O(m)
或者dijkstra算法

#### **RELPRIME $\in$ P**
RELPRIME 问题，即判定两数互素
辗转相除法（欧几里得算法）

#### **每个CFL都是P**
CYK 复杂度$O(n^3)$

### NP类

#### **引理：NP是具有多项式时间验证机的语言**
- 用于验证该问题的额外信息称为证书
    - HAMPATH 中两点之间的哈密顿路径
    - COMPOSITES 中 x 一个不等于1的因子

#### **一个语言在NP中，当且仅当其能够被某个非确定型多项式时间图灵机判定**

#### **NTIME(t(n)) = {L| L 是一个被O(t(n))时间的非确定型图灵机判定的语言}**
$$NP = \cup_k NTIME(n^k)$$


#### **CLIQUE $\in$ NP**
CLIQUE = {(G,k)| G是包含k团的无向图}
- 验证机角度
        证书：团，记为c
        V为CLIQUE的验证机
        V = 对输入((G,k), c)
        1. 检查c是否是G中k个点的集合
        2. 检查G是否包含连接c中节点的所有边
        3. 若均通过则接受，否则拒绝
        
- 非确定型TM角度
        N = 对于输入(G,k)
        1. 非确定的选择G中k个节点的子集c
        2. 检查G是否包含连接c中节点的所有边
        3. 若是则接受，否则拒绝


#### **SUBSET-SUM $\in$ NP**
SUBSET-SUM，给定集合s和t，判定是否有s的子集y，使得子集y中元素之和等于t
- 验证机角度
        证书：子集
        V = 对输入((s,t),c)
        1. 验证c中元素之和是否等于t
        2. 验证s是否包含c中所有元素
        3. 若均通过则接受，否则拒绝
        
- 非确定型TM角度
        N = 对于输入(s,t)
        1. 非确定的选择s中的子集c
        2. 验证c的元素之和是否等于t
        3. 若是则接受，否则拒绝
        
- co-NP

### P与NP问题
- P = NP ?
$$NP \subset EXPTIME = \mathop\cup\limits_{k} TIME(2^{n^k})$$

### NP完全性

- 定义
    - 1. B属于NP（多项式时间内被非确定图灵机判定）
    - 2. NP中每一个A都可在多项式时间内归约到B（归约，重要步骤）
    - 则称B为NP完全问题


- 证明P=NP的一类思路
    - 证明某个NPC $\in$ P

#### **库克-列文定理**
SAT 问题，给定一个布尔公式$\phi$判断其是否可满足
$$SAT \in P，当且仅当 P=NP$$

证明：
- 第一步：非确定图灵机可以在多项式时间内猜测变量的赋值，然后判断其是否可满足，因此 $SAT \subset NP$
- 第二步：
    - 假设从$NP$取出任意语言$A$，非确定$TM N$在$n^k-3$判定
    - 考虑$N$对应的$n^k\times n^k$画面$\omega$
    - 设计一个$\phi$,使得变量的一个满足赋值确实对应$N$在$\omega$上的接受画面
    - //todo

#### **SAT $\in$ NPC**

为NP中的每一个语言A，构造一个到SAT的多项式时间归约
书P170~173

#### **3SAT $\in$ NPC**

#### **CLIQUE $\in$ NPC**

- **证明NPC**
    - 先证明NP
    - 再证明某个已知NPC问题可在多项式时间内归约到他


#### 顶点覆盖问题 VERTEX-COVER
VERTEX-COVER 判定G是具有k个顶点的顶点覆盖的无向图
NP完全
3SAT 到 VERTEX-COVER 的归约
书P174
- 证明思路：将一个$3nf$公式$\phi$转化成一个图$G$和数值$k$，只要能找到覆盖，$\phi$就被相应地满足

#### 哈密顿路径问题 HAMPATH
HAMPATH $\in$ NPC
3SAT 到 HAMPATH 的归约

书p175~177

#### 子集和问题 SUBSET-SUM
SUBSET-SUM $\in$ NPC
3SAT 到 SUBSET-SUM 的归约

书p178~180

---

### 萨维奇定理
任何消耗$f(n)$空间的非确定型TM都可以转变为仅消耗$f^2(n)$空间的确定型TM

$$NSPACE(f(n)) \subset SPACE(f^2(n))$$

方法：利用中间格局递归二分
CANYIELD = 对于输入 c1，c2，t
1. t=1 直接检查是否有c1 = c2 或根据N规则，检查c1是否能够一步只能产生c2，其中之一成立则接受，否则拒绝
2. 若 t > 1，则对于N在w上消耗空间f(n)的每一个格局cm
3. 运行CANYIELD(c1, cm, t/2)
4. 运行CANYIELD(cm, c2, t/2)
5. 两个都接受则接受，否则拒绝

对输入 $c_{start}$，$c_{accept}$，$2^{df(n)}$

递归深度$O(log2^{df(n)})$，所以总消耗空间$O(f^2(n))$

### PSPACE类
PSPACE是在确定型图灵机上，在多项式空间内可判定的语言类
$$PSPACE = \mathop\cup\limits_{k}SPACE(n^k)$$

- SAT $\in$ SPACE(n)
- $ALL_{NFA} \in coNSPACE(n) \Rightarrow ALL_{NFA} \in SPACE(n^2)$
- 其都在PSPACE中

- $P \subset PSPACE$
因为运行n步的程序，最多消耗n的空间

- $NP \subset NPSPACE$
同理

由于 NPSPACE = PSPACE
所以有 $NP \subset PSPACE$


### PSPACE完全性
定义 若B是PSPACE-C则其满足以下两个条件
- 1. $B \in PSPACE$
- 2. PSPACE中每个语言A可多项式时间内归约到B
- 只满足2类似NP难称其为PSPACE难的


#### TQBF问题
判定$\phi$是真的全量词化布尔公式
其是PSPACE完全的
- 先给出一个线性空间的复杂度算法，证明其属于PSPACE
- 再给出归约方式，类似萨维奇定理证明方法
书 P192

#### 博弈必胜
$FORMULA_GAME = {<\phi> | 在与\phi相关联的公式博弈中选手E有必胜策略}$
其是PSPACE完全的
**因为其等价于TQBF**

#### 广义地理学
$GG = {<G,b> | 在图G上以结点b起始的广义地理学游戏中，选手I有必胜策略}$
其是PSPACE完全的
证明方法类似TQBF的递归算法

### L和NL类
亚线性空间界限，类似工作主存上是亚线性空间，其余放在外存（只读）。

#### L类
- L是确定型图灵机在对数空间内可判定的语言类
$$L=SPACE(logn)$$

#### NL类
- NL是非确定性图灵机在对数空间内可判定的语言类集合
$$NL=NSPACE(logn)$$

- 例题 8.13
$A = \{0^k1^k| k \ge 0\} \in L$
在工作带上用二进制数0、1的数目，两个计数器消耗对数级别空间，所以$A \in L$

- $PATH \in NL$
非确定的猜测从s到t的每一步，工作带上只记录每一步当前节点的位置，非确定的选择下一个节点，反复执行，直到到达t接受。或执行m步后拒绝，m是节点数。由此得到了PATH的被非确定型图灵机在亚线性空间内接受。

### NL完全性
定义 若语言B是NL完全的，则其满足
- 1. $B \in NL$ 
- 2. NL中的每个A**对数空间**内可归约到B


#### PATH是NL完全的
证明方法，把输入字符串w对应为图，图中节点对应NTM在输入w上的一个格局。一个结点能指向另一个结点的调节时，其对应的格局能在NTM的一步内产生第二个结点对应的格局，因此，NTM对输入w是否接受就对应着初始格局到接受格局的PATH
更详细的对数空间归约证明情况书 p199~200


#### $NL \subset P$
- 1. 因为PATH是NL完全的，所以NL中任何语言可对数空间内归约到PATH
- 2. 由此，NL中任何语言也可对数时间内归约到PATH
- 3. 因为多项式时间内归约到P中语言的语言本身也属于P
- 4. 所以 $NL \in P$

### NL = coNL








