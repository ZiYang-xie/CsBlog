---
title: 数据结构笔记 (2020-11-30 ~ 2020-12-05)
index_img: /img/Pic/DS.png
date: 2020-12-05 10:10:02
category: [DataStructure]
tags: [LCA,UFS]
math: true
---

# 数据结构 - DataStructure

数据结构这周依然是树上操作，课上学了AVL树，然后讲了之前用过的Hash，然后作业里面主要学会了LCA的倍增和不太熟练的欧拉序RMQ，最后学会了并查集的使用（就可以学最后的Tarjan LCA算法了) ，然后这周作业题主要是并查集，带有一道树上差分算法。

---

## LCA 问题

LCA (Least Common Ancestors) 最近公共祖先问题，顾名思义既要找到两个节点最近的公共祖先，朴素做法是，两个节点中深的那个节点向上跳，直到两个节点深度相同，两个节点再同时向上跳（询问父节点）如果他们跳到最后的父节点是同一个那么这个节点就是他们的最近公共祖先。

这种朴素的算法很好思考，但复杂度也是很高的，单次询问时间复杂度 O(n) 因为最坏要把所有节点都跳一遍。

![](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1414039454,330983716&fm=26&gp=0.jpg)

### **LCA - 倍增算法**

倍增算法是LCA的经典算法，如同二分算法的本质一样，都是通过每次尽量把问题规模缩减2的幂次，从而达到 O(lgn) 的时间复杂度。

我们简单讲解一下，倍增算法就是我不再像朴素算法一样一个个往上跳，我直接跳2的幂次，从大到小枚举，如果符合题意就跳，直到 2^0 跳一个节点，这样一次遍历下来，总能覆盖所有情况而满足题意跳到要跳的地方，但复杂度却大大降低减为 O(lgn)

- 代码实现
```cpp
void dfs(int u, int fa)
{
    up[u][0] = fa;  // 预处理父亲
    dep[u] = dep[fa] + 1;
    for(auto& v : tree[u])
    {
        if(v == fa)
            continue;
        dfs(v, u);
    }
}

void pre()
{
    for(int k = 1; (1 << k) <= n; ++k)
        for(int i = 1; i <= n; ++i)
            up[i][k] = up[up[i][k - 1]][k - 1]; 
            // 预处理所有的上跳
            // 状态转移方程 跳 2^k 步，等于先跳2^k-1步再往上跳2^k-1步
            // 2 ^ k = 2 ^ (k - 1) + 2 ^ (k - 1)
}   

int lca(int x, int y)
{
    if(dep[x] < dep[y])
        swap(x, y); // 让深度大的为x
    if(dep[x] != dep[y])
    {
        for(int k = 31; k >= 0; --k)
        {
            if(dep[up[x][k]] >= dep[y])
                x = up[x][k];   // 调整为同一深度
        }
    }

    if(x == y)
        return x;   
        // 如果一个是另外一个的长辈那么这时候两个直接就相等了，直接返回

    for(int k = 31; k >= 0; --k)
    {
        if(up[x][k] != up[y][k])    // 同时上跳不过头
        {
            x = up[x][k];   
            y = up[y][k];
        }
    }

    return up[x][0];    // 最后 lca 就是里面任意一个的父亲
}
```

---

### **LCA - 欧拉序RMQ算法**

这边涉及到RMQ问题，我们就先来讲一讲RMQ问题。

- *RMQ 问题*
RMQ 是英文 Range Maximum/Minimum Query 的缩写，表示区间最大（最小）值。

RMQ问题一般可以使用单调栈、ST表、线段树来解决

通过欧拉序将LCA问题转为RMQ问题后，我们一般使用ST表来解决RMQ问题。因为ST表在时间复杂度上表现优秀，需要 O(nlgn)的预处理，就能做到O(1)的询问。而写起来又较为简单，不像线段树一样复杂。可以处理大部分不需要在线修改的 RMQ 问题。

另一方面如果我们使用单调栈和线段树在单次询问的时间复杂度仍然是 O(lgn) 级别的本没有做到比倍增算法更优，但在代码方面却比倍增算法更为复杂，因而我们选择ST表进行处理。


### **ST表 - Sparse table**

我们说 ST 表可以用来解决可重复贡献问题，因为ST表涉及到区间重叠，我们要保证区间重叠不会影响到我们要求的问题。所以ST表只能解决可重复贡献问题，例如最值和gcd。

ST表运用的也是倍增的思想，通过倍增区间覆盖来解决问题。

```cpp
// ST表
int f[Max][lgn], Logn[Max], a[Max];
// f[i][k] 表示区间 i ~ i + 2^k - 1 的最值

void pre()
{
    Logn[1] = 0;
    for(int i = 2; i < Max; ++i)
        Logn[i] = Logn[i / 2] + 1;
}

// 状态转移：
    // 前者表示 i ~ i + 2^(k - 1) - 1 的区间最值
    // 后者表示 i + 2^(k - 1) ~ i + 2^k - 1 的区间最值
    // 合并即为 i ~ i + 2^k - 1的区间最值
void preSet()
{
    for(int i = 1; i <= n; ++i)
        f[i][0] = a[i]; // 显然 f[i][0] = a[i]

    for(int k = 1; k < lgn; ++k)
        for(int i = 1; i + (1 << (k - 1)) <= n; ++i)
            f[i][k] = max(f[i][k - 1], f[i + (1 << (k - 1))][k - 1]);
}

// 查询操作：
    // 如果我们要查询 区间 l ~ r 的最值, 我们根据ST表性质知道
    // f[i][k] 表示 l ~ l + 2^k - 1 的区间最值
    // r - 2^k + 1 ~ r 的区间最值就可以用 f[r - 1 << k + 1][k] 表示
    // 那么我们需要这两个区间覆盖整个查询区间且不超过
    // 则 l + 2^k - 1 >= r - 2^k + 1 且 l + 2^k - 1 <= r 且 r - 2^k + 1 >= l
    // 则 k >= lg(r - l + 2) - 1 且 k <= floor(lg(r - l + 1));
    // 我们直接取 k == floor(lg(r - l + 1))

int find(int l, int r)
{
    int k = Logn[r - l + 1];
    return max(f[i][k], f[r - (1 << k) + 1][k]); // O(1) 查询
}

```

这样一个ST表就写好了，回到正题，我们是通过欧拉序把 LCA问题转换为RMQ问题，我们现在来看这是如何进行的。

在看欧拉序之前我们先看一看基本的 dfs 序是怎么做的（真就递归学习呗）

![dfs序](https://img-blog.csdnimg.cn/20191008210415266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3djeHlreQ==,size_16,color_FFFFFF,t_70)

正常的dfs序是深度优先不记录回溯的，如上图 dfs 序就是 
**A->B->D->E->G->C->F->H**
每个节点在dfs序中出现且仅出现一次

而我们再来看欧拉序

![欧拉序](https://img-blog.csdnimg.cn/20191008210445328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3djeHlreQ==,size_16,color_FFFFFF,t_70)

它不同于dfs序将栈pop的元素也加入队列中，从而就形成了上图“逆时针”的模式
上图欧拉序就是
**A->B->D->B->E->G->E->B->A->C->F->H->F->C->A**
一种intuition就是欧拉序是一种正常人走路遍历所有节点的顺序，只要叶节点大于2个的树就不可能是欧拉图或半欧拉图，那么必然要走回头路，在dfs序的基础上将回头路线画出就是欧拉序。

我们来观察欧拉序可以发现，其首尾必然是根节点，然后除了叶节点仅出现一次，其余点出现2次以上(取决于是几叉树)，如果我们默认是二叉树，那么欧拉序的大小就不会超过 2n - 1 (考虑单链或就两叉到底的最坏情况)

如果我们在欧拉序节点旁配上它的深度再结合图来观察
**A(0)->B(1)->D(2)->B(1)->E(2)->G(3)->E(2)->B(1)->A(0)->C(1)->F(2)->H(3)->F(2)->C(1)->A(0)**
我们根据欧拉序的性质不难发现一个节点的左右子树必然夹在其在欧拉序中第二次出现的位置的左右两边，例如 B 的 左右子树 D, E 出现在B第二次出现位置[3]的两边[2]、[4]。
那么我们想如果我们找，两个节点的 LCA 就直接找两个节点第一次出现的位置，将其作为区间左右，在中间找深度最小的点就行了，这样找到的一定就是他们的LCA (不可能找到更浅的祖先) 。 当然其中包含了左边一个节点的子树，但为了方便我们就统一取第一次出现的位置即可。

这样我们就在线性的时间内将LCA问题转化成了RMQ问题，然后通过之前O(nlgn)的预处理我们可以做到 O(1)的询问，这样LCA问题的总复杂度就是ST表预处理的 O(nlogn) 的复杂度。

似乎总体没有比倍增更优，但单次询问比倍增快了很多，适合需要及时快速反馈的应用场景。

- 代码实现

```cpp
// get eula array
void dfs(int u, int fa, int level)
{
    pos[u] = cnt_2;
    find_u[cnt_2++] = u;
    dep[u] = level;
    
    for(int i = head[u]; i != -1; i = e[i].nex)
    {
        int v = e[i].v;
        
        // 欧拉序，回溯也放入
        pos[v] = cnt_2;
        find_u[cnt_2++] = v;
        dep[v] = level + 1;
        dfs(v, u, level + 1);
    }
}

void ST()
{
    // Preset Log
    Logn[1] = 0;
    for(int i = 2; i <= n; ++i)
        Logn[i] = Logn[i >> 1] + 1;
    
    for(int i = 1; i <= n; ++i)
        f[i][0] = find_u[i];

    for(int j = 1; j <= logn; ++j)
        for(int i = 1; i <= n; ++i)
            f[i][j] = dep[f[i][j - 1]] < dep[f[i + (j << 1)][j - 1]] ? f[i][j - 1] : f[i + (j << 1)][j - 1];

}

int lca(int u, int v)
{
    int l = pos[u], r = pos[v];
    int j = Logn[r - l + 1];
    // 直接找区间最小深度的节点
    int ans = min(f[l][j], f[r - (1 << j) + 1][j]);
    return pos[ans];    // 返回节点位置...
}
```

---

## 并查集

再来讲讲这周学的并查集

并查集顾名思义支持且仅支持两种操作
1. 合并两个集合
2. 查询元素所在的集合

并查集是一种树上的操作，通过根节点直接代表整棵树，初始化的时候根节点父节点为自身。

- 合并操作

合并操作相对比较简单，由于我们通过根节点来代表这个集合，那么合并两个集合只需要将其中一个的根节点作为另一个的子节点连接上即可。但同时我们要注意整棵树的深度会影响我们的时间复杂度，因而我们要尽可能不加深或是少加深树的深度，所以我们采用将深度较小的树连接到深度较大的树上，每次这样操作，树深度每次至多 +1，这种策略称之为**按秩合并（启发式合并）**

![](https://oi-wiki.org/ds/images/dsu1.png)

- 代码

```cpp
void unionSet(int x, int y)
{
    int tmp_x = find(x);
    int tmp_y = find(y);
    if(tmp_x == tmp_y)  // 本来就在同一集合中
        return; 
    if(sz[tmp_x] > sz[tmp_y])
        swap(tmp_x, tmp_y); // 让 tmp_x 是深度小的集合
    fa[tmp_x] = tmp_y; // 将 tmp_x 连接到 tmp_y 上
}
```

- 查询操作

我们来讲并查集关键的查询操作，并查集的查询操作给出一个节点，我们查询其父节点，如若其父节点不是自身就继续向上查询，直到查询到根节点（父节点为自身）返回根节点作为这个集合的代表。

我们不难看出这样的查询操作单次是 $O(n)$ 的，原因是我们每次查询都要走完完整的一条链，但是其实我们并不关心该节点的父节点是谁，我们只想知道其根节点是什么。所以我们可以直接让它的父节点直接是根节点，这样虽然在第一次操作的时候，我们还是要走完一条链，但之后该节点的父节点直接就是根节点。这种操作称为**路径压缩**

![](https://oi-wiki.org/ds/images/dsu2.png)

```cpp

int find(int x)
{
    if(fa[x] == x)
        return x;
    return fa[x] = find(fa[x]); // 路径压缩
}
```

- **复杂度分析**

我们现在来分析一下复杂度，朴素算法毫无疑问单次操作是 $O(mn)$ 的
如果我们使用了路径压缩，在Tarjan大神的论文[1] 中给出了复杂度的证明，只使用路径压缩不使用按秩合并的最坏时间复杂度是 $O(mlogn)$ 已经满足大部分题的需求，所以一般只需要路径压缩就能过题。
在姚期智的论文 [2] 中，证明了只路径压缩的平均复杂度为 $O(m\alpha{(m,n)})$
*注： $\alpha$ 是阿克曼函数的反函数，其增长极其缓慢，也就是说其单次操作的平均运行时间可以认为是一个很小的常数。*

如果我们同时使用了路径压缩和按秩合并，那么我们可以做到 $O(m\alpha{(m,n)})$ 的最坏时间复杂度。相当于单次询问是常数级别复杂度。

Ackermann 函数
$$
A(m,n) =\left\{
\begin{array}{l}
    n + 1, \; m = 0 \\
    A(m - 1, 1), m > 0 \;and\; n = 0 \\
    A(m - 1, A(m, n - 1)),\;othercases
\end{array}
\right.
$$

$A(4, 3)$ 大的惊人，其反函数增长就相对应慢的惊人，直接可看为常数

---

## 树上差分算法

讲一下这周作业题里涉及到的树上差分算法
树上差分问题可以用树链剖分解决，但我目前还不太会，就写一下现在会一点的树上差分。

树上差分分为两种，边差分和点差分。

- 边差分
考虑一个经典问题，**给出两点x, y 将其路径上的边权加1，最后给出所有边权。**

![图源:https://www.cnblogs.com/zhwer/p/12800475.html](https://s3.ax1x.com/2020/12/08/r99w60.png)

我们看这张图，数组 c[k] 是差分数组只不过我们是自下而上加的，为不影响其他子树的结果，我们的统计在回溯过程中完成，因而是自下而上的，那么这个边权修改过程就可以看做是 c[x]++, c[y]++, 然后 根节点到lca(x, y)被加了两次，我们都要减去 c[lca(x, y)] -= 2

既然是差分那么对于权值的更新，我们就可以如同前缀和一样计算，这不过这里的"前缀"是所有的子树权值，我们将所有子树权值收集起来到父节点上。

- 代码实现

```cpp
// 已求出差分数组c
void getAns(int u, int fa)
{  
    for(int i = head[u]; i != -1; i = e[i].nex)
    {
        int v = e[i].v;
        if(v != fa)
        {
            getAns(v, u);
            c[u] += c[v] // 收集子树权值更新c为原本数组
            // 更新后的c就代表其和其父节点连接边的边权
        }
    }
}
```

- 点差分
点差分和边差分差不多，但这回每个点都代表的是自己了。
![图源:https://www.cnblogs.com/zhwer/p/12800475.html](https://s3.ax1x.com/2020/12/08/r990XV.png)

和边差分不同的是，这回lca不需要减2了，因为每个点代表的就是自己，在统计的时候 x, y 路径上是有 lca(x, y) 的，因而只需要减去一次重复计算即可。但这边lca在计算"前缀和"的时候会 +1，差分数组某一地方值的变动会影响到后面所有的值（这就是差分数组的精髓和意义所在）但lca的父亲并不应该 +1 所以我们要将 c[fa[lca(x,y)]]-- 这个过程之后，我们的差分数组就完成了。
最后自下而上的收集一下，就能得到所有节点的权值了。

- 思想总结

差分的思想就是将原来本不相干的值联系到了一起，把后面点的部分信息移到了前面的点中，形成了区间的覆盖，这种效果正好能够用于解决区间修改问题，避免了暴力算法对每个点都进行操作，很巧妙的思想。

---

## 最后总结

本周DS主要学习这些内容，AVL树很惭愧虽然上课讲了但还没有深入去看，线段树和树链剖分还不太会，树状数组也快忘记了。最近又重新听到了《蜗牛》这首歌，隔了这么多年，再听还是很感动。“历经的伤都不感觉疼”，“任风吹干流过的泪和汗，总有一天我有属于我的天。” 
每周都在不断吸收新知识，很充实也很疲倦，每天都学到12点之后。就是希望能够在未来有一片自己的天。科研也在不断做，但进度很慢，时间分配越来越不够了，最近越来越感到拔尖班的藏龙卧虎，个个都是人才，让我感到了很大的压力。但就像《蜗牛》中说的即使我很慢，拖着重重的壳，只要我每天一步一步的向上爬，我总能触碰到那片属于我的蓝天。

---

## Reference
[1]Tarjan, R. E., & Van Leeuwen, J. (1984). Worst-case analysis of set union algorithms.
[2]Yao, A. C. (1985). On the expected performance of path compression algorithms. SIAM Journal on Computing, 14(1), 129-133.