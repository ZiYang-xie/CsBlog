<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ICS-Lab4.2 各种链接姿势</title>
    <link href="/CsBlog/2020/11/15/ICS_Lab3/"/>
    <url>/CsBlog/2020/11/15/ICS_Lab3/</url>
    
    <content type="html"><![CDATA[<h3 id="Task0-简单链接"><a href="#Task0-简单链接" class="headerlink" title="Task0 - 简单链接"></a>Task0 - 简单链接</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;some.h&quot;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    testPrint();    testPrint(<span class="hljs-number">5</span>);    notATest();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li><strong>错误分析</strong></li></ul><blockquote><p>我们可以看到main函数中调用了三个函数，全是外部的，在链接时，符号表会进行搜索匹配。我们再来看some.h中定义了哪些函数.</p></blockquote><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testPrint</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testPrint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>;</code></pre><blockquote><p>发现只有两个test函数,而没有notATest定义的函数，根据这个离谱的名字我们可以断定在cstdio中也没有同名函数。<br>所以最后符号表中没有匹配上，会引发链接错误。</p></blockquote><ul><li><strong>解决方法</strong></li></ul><blockquote><p>直接将 notATest() 注释掉, 再在 makefile 中使用 </p></blockquote><pre><code class="hljs css"><span class="hljs-selector-tag">g</span>++ <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> <span class="hljs-selector-tag">some</span><span class="hljs-selector-class">.cpp</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">main</span></code></pre><hr><h3 id="Task1-链接与重复包含问题"><a href="#Task1-链接与重复包含问题" class="headerlink" title="Task1 - 链接与重复包含问题"></a>Task1 - 链接与重复包含问题</h3><ul><li><strong>解题过程</strong></li></ul><p>通过阅读代码，我们可以发现改题的代码会根据宏DEBUG是否被定义而有不同的行为，决定是否打印更加详细的内容</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;function0.h&quot;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func0</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-meta"># <span class="hljs-meta-keyword">ifdef</span> DEBUG</span>    printDebug(); <span class="hljs-comment">//打印debug信息 (详细操作在shared.cpp中)</span>    <span class="hljs-meta"># <span class="hljs-meta-keyword">else</span></span>    print(); <span class="hljs-comment">//打印正常信息</span>    <span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span>&#125;</code></pre><blockquote><p>根据题意，我们需要在 Makefile 中,对于要求的 main1 需要做一个相等的条件判断</p></blockquote><pre><code class="hljs makefile"><span class="hljs-section">main0:</span>    g++ main0.cpp function0.cpp function1.cpp shared.cpp -o main0debug = False<span class="hljs-section">main1:</span><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(debug)</span>,True) g++ main1.cpp -DDEBUG function0.cpp function1.cpp shared.cpp -o main1<span class="hljs-keyword">else</span>g++ main1.cpp function0.cpp function1.cpp shared.cpp -o main1<span class="hljs-keyword">endif</span></code></pre><p><em>值得注意的是，makefile中 if 语句前不能有 tab 或者空格</em></p><p><strong>Include 路径</strong><br><img src="https://s3.ax1x.com/2020/11/15/DFeVyt.png"></p><ul><li><strong>问题</strong></li></ul><ol><li>为什么两个function.h都引⽤了shared.h⽽没有出问题？本来有可能出什么问题。</li></ol><blockquote><p>因为 shared.h 中仅包含函数声明，而不包含函数的定义，因而不会有重定义问题。如果 #include shared.cpp 则会出现重定义问题。</p></blockquote><ol start="2"><li>如果把shared.h中注释掉的变量定义取消注释会出什么问题？为什么？</li></ol><blockquote><p>会出现变量重定义问题，由于全局变量 string 被两次 include 到func0 和 func1 中，最后被同时引用至 main 中，导致重定义。在符号表中产生冲突，报错。</p></blockquote><ol start="3"><li>通常使⽤shared.h中另外被注释掉的宏命令(#开头的那些⾏)来规避重复引⽤的⻛险，原理是什么？取消这些注释之后上⼀题的问题解除了吗？背后的原因是什么？</li></ol><blockquote><p>通过宏定义，在第一次 include 的时候定义宏为函数名，之后再次include 的时候由于已经 define 就不再次 include。这种方式的缺点是如果有已有宏名与函数名重复时，将会报错。使用 #pragama once 则是由c++编译器保证 include 一次，不会有宏名重复问题。</p></blockquote><blockquote><p>上题的问题并没有解决，因为FOO是全局变量，其赋了初值，被链接器标记为strong，被重复 include 到了 main 中，两个 strong 标记冲突报错。</p></blockquote><hr><h3 id="Task2-静态链接库"><a href="#Task2-静态链接库" class="headerlink" title="Task2 - 静态链接库"></a>Task2 - 静态链接库</h3><p>在这个 Task 中我们需要编译2个静态链接库，并链接3个静态链接库，完成编译。</p><p><strong>A Makefile</strong></p><pre><code class="hljs makefile"><span class="hljs-section">libA:</span>g++ -c A.cpp ar -r libA.a A.o</code></pre><blockquote><p>先用g++ -c编译出A.o可重定位目标文件，再通过 ar 命令编译静态链接库。（libC 同理）</p></blockquote><p><strong>Main Makefile</strong></p><pre><code class="hljs makefile">main : cd A &amp;&amp; make libAcd C &amp;&amp; make libCg++ main.cpp B/libB.a A/libA.a C/libC.a -o main</code></pre><blockquote><p>再 CD 入每个目录进行 make 编译， 最后把静态链接库进行链接。 </p></blockquote><ul><li><strong>静态库链接搜索路径顺序：</strong></li></ul><ol><li>ld会去找GCC命令中的参数-L</li><li>再找gcc的环境变量LIBRARY_PATH</li><li>再找内定目录 /lib /usr/lib /usr/local/lib </li></ol><ul><li><strong>问题</strong></li></ul><ol><li><p>若有多个静态链接库需要链接，写命令时需要考虑静态链接库和源⽂件在命令中的顺序吗？是否需要考虑是由什么决定的？</p><blockquote><p><strong>需要考虑</strong>，链接器在链接过程中按命令中输入的顺序进行符号表匹配，可以将这个匹配过程抽象的看作链接器在维护三个集合 E(待合并文件), U(被引用且尚未匹配), D（已匹配），根据顺序动态更新E, 和U,D, 最后如果 U 为空则正常整合 E 生成可执行文件，不然则报错有符号被引用了但未能匹配。所以如果我们的静态库都是相互独立的，那么顺序是没关系的。但如果互相依赖，那么我们必须保证在对某个符号的引用的库后，必然有一个库中存在对其的定义，不然则会报错。</p></blockquote></li><li><p>可以使⽤size main命令来查看可执⾏⽂件所占的空间，输出结果的每⼀项是什么意思？</p></li></ol><table><thead><tr><th align="center">text</th><th align="center">data</th><th align="center">bss</th><th align="center">dec</th><th align="center">hex</th><th align="center">filename</th></tr></thead><tbody><tr><td align="center">22721</td><td align="center">712</td><td align="center">288</td><td align="center">23721</td><td align="center">5ca9</td><td align="center">main</td></tr></tbody></table><ul><li><strong>text:</strong> 机器代码字节</li><li><strong>data:</strong> 包含静态变量和已经初始化的全局变量的数据段字节数大小</li><li><strong>bss:</strong> Block Started by Symbol (better save space) 存放程序中未初始化的全局变量的字节数大小，BBS段属于静态内存分配, 不占真实内存空间（仅占位符）</li><li><strong>dec:</strong> = test + data + bss</li><li><strong>hex:</strong> 16进制的dec</li><li><strong>filename:</strong> 顾名思义，文件名</li></ul><hr><h3 id="Task3-动态链接库"><a href="#Task3-动态链接库" class="headerlink" title="Task3 - 动态链接库"></a>Task3 - 动态链接库</h3><p>整体操作和上一个Task很像，只是链接的是动态链接库 .so</p><p><strong>A Makefile</strong></p><pre><code class="hljs makefile"><span class="hljs-section">libA:</span>g++ -fPIC -c A.cppg++ -shared -fPIC A.o -o libA.so</code></pre><blockquote><p>在 A 中先编译出 A.o 再用 -shared 编译出动态链接库 .so</p></blockquote><p><strong>Main Makefile</strong></p><pre><code class="hljs makefile">main : cd A &amp;&amp; make libAcd C &amp;&amp; make libCg++ main.cpp A/libA.so ./libB.so C/libC.so -o main</code></pre><blockquote><p>直接 cd 进去 make 出动态链接库后，再进行链接。</p></blockquote><ul><li><strong>问题</strong></li></ul><ol><li><p>动态链接库在运⾏时也需要查找库的位置，在Linux中，运⾏时动态链接库的查找顺序是怎样的？</p><blockquote><p><strong>动态链接时、执行时搜索路径顺序:</strong></p><ol><li>编译目标代码时指定的动态库搜索路径</li><li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</li><li>配置文件/etc/ld.so.conf中指定的动态库搜索路径</li><li>默认的动态库搜索路径/lib</li><li>默认的动态库搜索路径/usr/lib</li></ol></blockquote></li><li><p>使⽤size main查看编译出的可执⾏⽂件占据的空间，与使⽤静态链接库相⽐占⽤空间有何变化？哪些部分的哪些代码（也要具体到本task）会导致编译出⽂件的占⽤空间发⽣这种变化？</p></li></ol><table><thead><tr><th align="center">text</th><th align="center">data</th><th align="center">bss</th><th align="center">dec</th><th align="center">hex</th><th align="center">filename</th></tr></thead><tbody><tr><td align="center">3089</td><td align="center">720</td><td align="center">96</td><td align="center">3905</td><td align="center">f41</td><td align="center">main</td></tr></tbody></table><blockquote><p><strong>占用空间变小了</strong>，因为不同于静态链接库将所有的静态库都整合入可执行文件中，动态链接库是在程序开始或正在运行时被链接加载的，所有可执行文件本身的空间占用会大幅缩小。</p></blockquote><blockquote><p>main 中调用了 A, B, C 函数，所以其中的函数以及静态全局变量 A_name, B_name 会被被置于动态链接库.so中动态加载</p></blockquote><ol><li>编译动态链接库时-fPIC的作⽤是什么，不加会有什么后果？</li></ol><p>-fPIC 含义是 Generate position-independent code (PIC)，例如在汇编的 jmp 语句中通常使用的是固定的内部地址</p><pre><code class="hljs angelscript"><span class="hljs-number">100</span>: COMPARE REG1, REG2<span class="hljs-number">101</span>: JUMP_IF_EQUAL <span class="hljs-number">111</span>...<span class="hljs-number">111</span>: NOP</code></pre><blockquote><p>而通过 -fPIC 参数 jmp 语句所指向的是相对地址<br>使用的是代码段和数据段的OFFSET，从而实现位置无关，可以动态加载到内存中，不同进程可以共享。</p></blockquote><pre><code class="hljs angelscript"><span class="hljs-number">100</span>: COMPARE REG1, REG2<span class="hljs-number">101</span>: JUMP_IF_EQUAL CURRENT+<span class="hljs-number">10</span>...<span class="hljs-number">111</span>: NOP</code></pre><blockquote><p>如果不加，在某些系统下不会有很大的问题，但一般在 -shared 后面最好加上 -fPIC 来保证动态链接库是位置无关的，不然无法实现动态链接（由于位置相关即分配绝对内存地址，导致多个副本存在于内存中，无法实现动态链接）</p></blockquote><p><strong>info in gcc manual</strong></p><ul><li><strong>-shared:</strong>  Produce a shared object which can then be linked with other objects to forman executable. Not all systems support this option. For predictable results,<br>you must also specify the same set of options used for compilation (‘-fpic’,‘-fPIC’, or model suboptions) when you specify this linker option.*</li></ul><ol start="4"><li>现在被⼴泛使⽤的公开的动态链接库如何进⾏版本替换或共存（以linux系统为例）？</li></ol><blockquote><p>通过动态链接，如果开发者需要维护程序的某一部分（某几个功能的函数），仅需要维护修改所在的动态链接库即可，然后将其发布。用户只需要替换动态链接库，在程序运行的时候自然会动态链接到新的链接库，<strong>在接口保持不变</strong>的情况下完成很自然流畅的版本更新。</p></blockquote><hr><h3 id="Task4-ld手动链接"><a href="#Task4-ld手动链接" class="headerlink" title="Task4 - ld手动链接"></a>Task4 - ld手动链接</h3><ul><li><strong>解题过程</strong><br>这题要求我们用ld链接器，进行手动链接，我们先试一下直接链接会发生什么</li></ul><pre><code class="hljs makefile"><span class="hljs-comment">#链接代码</span>ld -o main main.o some.o</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">//报错信息</span>ld: warning: cannot find entry symbol _start; defaulting to <span class="hljs-number">00000000004000b</span>0some.o: In function `notATest()<span class="hljs-string">&#x27;:</span>some.cpp:(.text+0xc): undefined reference to `puts&#x27;some.o: In function `testPrint()<span class="hljs-string">&#x27;:</span>some.cpp:(.text+0x1f): undefined reference to `puts&#x27;some.o: In function `testPrint(<span class="hljs-keyword">int</span>)<span class="hljs-string">&#x27;:</span>some.cpp:(.text+0x52): undefined reference to `printf&#x27;Makefile:2: recipe for target &#x27;main&#x27; failedmake: *** [main] Error <span class="hljs-number">1</span></code></pre><blockquote><p>发现主要报错信息是 undefined reference to ‘puts’, ‘printf’, 说明标准库中的函数符号没有被成功匹配，我们需要把 stdc 加进去</p></blockquote><pre><code class="hljs makefile"><span class="hljs-comment"># 链接代码</span>ld -o main main.o some.o -lc<span class="hljs-comment"># 通过 -lc 命令直接添加标准库，也可以自行指定libc.so路径</span></code></pre><blockquote><p>可以发现main被成功编译出来，但运行时候发现bash报目录中无此文件</p></blockquote><pre><code class="hljs bash">bash: ./main: No such file or directory</code></pre><blockquote><p>也就是我们并不能运行这个可执行文件，查找资料之后我们尝试指定使用的动态链接器再进行编译，就可以运行了</p></blockquote><pre><code class="hljs makefile">ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o main main.o some.o -lc</code></pre><blockquote><p>我查询了ld的手册试图查找原因，但并未发现为什么必须要使用–dynamic-linker指令</p></blockquote><div style="page-break-after: always;"></div><ul><li><strong>–dynamic-linker=file</strong><blockquote><p>   Set the name of the dynamic linker.  This is only meaningful when generating dynamically linked ELF executables.  <strong>The default dynamic linker is normally correct; don’t use this unless you know what you are doing.</strong></p></blockquote></li></ul><blockquote><p>接下去，我们的程序虽然能够运行起来了，但在 main 函数跑完之后会出现 <em>Segmentation fault (core dumped)</em> 提示，这也提示了我们对于 main 函数的初始化和结束可能并未正常执行。</p></blockquote><ul><li><strong>GDB查看正常程序</strong></li></ul><p><img src="https://s3.ax1x.com/2020/11/15/DFeZOP.png"></p><blockquote><p>通过 gdb 查看正常程序我们发现，正常的 main 函数执行栈中需要有两个函数为其保证环境 <em>__lib_csu_init</em> 和 <em>__libc_start_main</em></p></blockquote><ul><li><strong>__libc_start_main</strong><br>我们需要知道，在linux中，main函数的初始化环境和参数传递以及返回值处理工作是由 __libc_start_main 来保证的。一个正常的程序执行需要包含以下要素。</li></ul><ol><li>performing any necessary security checks if the effective user ID is not the same as the real user ID.</li><li>initialize the threading subsystem.</li><li>registering the <em>rtld_fini</em> to release resources when this dynamic shared object exits (or is unloaded).</li><li>registering the <em>fini</em> handler to run at program exit.</li><li>calling the initializer function *(<em>init)()</em>.</li><li>calling <em>main()</em> with appropriate arguments.</li><li>calling <em>exit()</em> with the return value from <em>main()</em>.</li></ol><blockquote><p>具体的初始化和结束调用路径异常复杂，在此不多赘述，放一张图有待进一步研究。</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/15/DFemef.png"></p><p><em>图片来源: <a href="https://luomuxiaoxiao.com/?p=516">https://luomuxiaoxiao.com/?p=516</a></em></p><hr><p>然后介绍完了主函数的初始化和返回，我们需要知道保证上述的两个函数在哪个动态链接库中，这就涉及到了 <em>crt1.o, crti.o, crtbegin.o, crtend.o, crtn.o</em> 这几个库<br><em>参考： <a href="https://blog.csdn.net/farmwang/article/details/73195951">https://blog.csdn.net/farmwang/article/details/73195951</a></em></p><blockquote><p><strong>crt是c runtime 的缩写</strong>,用于执行进入main之前的初始化和退出main之后的扫尾工作。</p></blockquote><table><thead><tr><th align="center">目标文件</th><th align="center">crt1.o</th><th align="center">crti.o</th><th align="center">crtbegin.o</th><th align="center">crtend.o</th><th align="center">crtn.o</th></tr></thead><tbody><tr><td align="center">作用</td><td align="center">启动</td><td align="center">初始化</td><td align="center">构造</td><td align="center">析构</td><td align="center">结束</td></tr></tbody></table><blockquote><p>在标准的linux平台下,link的顺序是</p></blockquote><pre><code>ld crt1.o crti.o [user_objects] [system_libraries] crtn.o</code></pre><p>所以我们按照顺序进行链接有如下命令</p><pre><code class="hljs makefile"><span class="hljs-comment"># 链接指令</span>ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o main /usr/lib/x86_64-linux-gnu/crt1.o main.o some.o -lc /usr/lib/x86_64-linux-gnu/crti.o /usr/lib/x86_64-linux-gnu/crtn.o</code></pre><blockquote><p>成功的手动完成了程序的链接工作。</p></blockquote><p>以上艰苦的工作告诉我们，不要轻易尝试手动链接，除非你知道你在干什么。平时好好用 gcc。</p><ul><li>动态链接器⼀个操作系统中只需要⼀个吗？为什么？<blockquote><p>一般来说只要有一个支持的动态链接器即可，完成程序的动态链接工作。 但linux中可能有两个 ld 的版本</p></blockquote></li></ul><ol><li>ld.so针对a.out格式的二进制可执行文件</li><li>ld-linux.so针对ELF格式的二进制可执行文件</li></ol><p>a.out是旧版类Unix系统中用于执行档、目的码和后来系统中的函数库的一种文件格式，该版本的链接器仍被保留用以向前支持。</p><hr><h3 id="Task5-运行时打桩"><a href="#Task5-运行时打桩" class="headerlink" title="Task5 - 运行时打桩"></a>Task5 - 运行时打桩</h3><p>Task5 是一个典型的运行时打桩的 task，给了我们编译好的login程序，让我们改变其行为，让它能够输出 login_success.</p><blockquote><p>阅读源码，我们可以发现，login将我们输入的字符串做了hash，与已有某不明hash值，进行比较，如果相等则登陆成功。根据本 lab 的内容主要是讲 make 和链接的，让我们碰撞这个hash显然不是本意。那另一种方法就是通过运行时打桩，改变标准库的链接方式，让strcmp 链接到我们自己写的 strcmp 版本上去，从而我们可以控制其返回值让其返回0使得登陆成功。</p></blockquote><p><em>首先要注意 strcmp 并非只有判断密码时的一次唯一调用，在别处还有调用，所以我们要保证 strcmp 函数的基本功能正确</em></p><pre><code class="hljs cpp"><span class="hljs-comment">// mystrcmp.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;dlfcn.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *lhs, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *rhs)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span>(*strcmpp)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *lhs, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *rhs);    strcmpp = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;strcmp&quot;</span>);    <span class="hljs-keyword">char</span> tmp[] = <span class="hljs-string">&quot;3983709877683599140&quot;</span>;    <span class="hljs-keyword">if</span>(strcmpp(tmp, rhs) == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> strcmpp(lhs, rhs);&#125;</code></pre><blockquote><p>我们直接写一个自己的 strcmp 版本，用 dlsym 可以获取在运行时 strcmp 函数的指针 <em>（不这样做也可以，可以直接自己重写一遍strcmp程序）</em>，相当于可以直接使用 <strong>真实的标准库中的 strcmp</strong>，然后我们稍微改写一下，让它和我们的hash值比较的时候直接返回0，能够让我们不管输入什么密码都能够 login_success。</p></blockquote><p>接下来我们先将我们写的strcmp编译成动态链接库</p><pre><code class="hljs shell">gcc -shared -fpic -o mystrcmp.so mystrcmp.c -ldl</code></pre><blockquote><p>然后使用 <strong>LD_PRELOAD=”./mystrcmp.so”</strong> 指令，从而在 strcmp 动态链接到标准库之前让其优先匹配我们写的动态链接库中的 strcmp 符号。</p></blockquote><p>这里需要注意由于是要直接运行 ./login, 所以我们需要把LD_PRELOAD的效果全局化，也既在前面加上 export 标记。</p><pre><code class="hljs shell">export LD_PRELOAD=&quot;./mystrcmp.so&quot;</code></pre><p>最后注意不要忘记卸载全局 preload， 不然之后所有程序都 preload 这个strcmp。</p><pre><code class="hljs shell">export LD_PRELOAD=NULL</code></pre>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Training Neural Networks II 06</title>
    <link href="/CsBlog/2020/11/13/CS231n-06-Training-Neural-Networks-II/"/>
    <url>/CsBlog/2020/11/13/CS231n-06-Training-Neural-Networks-II/</url>
    
    <content type="html"><![CDATA[<h3 id="PreView"><a href="#PreView" class="headerlink" title="PreView"></a>PreView</h3><ul><li>Fancier optimization</li><li>Regularization</li><li>Transfer Learning</li></ul><hr><h3 id="Problem-with-SGD"><a href="#Problem-with-SGD" class="headerlink" title="Problem with SGD"></a>Problem with SGD</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9JOns.png"></p><blockquote><p>The zig-zag path reveal the drawbacks of SGD</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9JbcQ.png"></p><blockquote><p>Stuck in the local minima.</p></blockquote><ul><li>Saddle points much more common in high dimension.</li></ul><p><strong>Add an Momentum term may solve these problems</strong></p><p><img src="https://s3.ax1x.com/2020/11/13/D9JqXj.png"></p><p><img src="https://s3.ax1x.com/2020/11/13/D9JXBn.png"></p><blockquote><p>Owing to the exsistance of momentum we can training more faster and overcome the problems mentioned before.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9JH1g.png"></p><ul><li><strong>Nesterov Momentum</strong></li></ul><p>$$v_{t+1} = \rho{v_t}-\alpha{\nabla{f(x_t+\rho{v_t})}}<br>\<br>x_{t+1} = x_t + v_{t+1}<br>$$</p><p><img src="https://s3.ax1x.com/2020/11/13/D9Jj7q.png"></p><blockquote><p>some kind error correcting term of present v and the previous v</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9JzNV.png"></p><hr><h3 id="AdaGrad"><a href="#AdaGrad" class="headerlink" title="AdaGrad"></a>AdaGrad</h3><pre><code class="hljs python">grad_squared = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    dx = compute_gradient(x)    grad_squared += dx * dx    x -= learning_rate * dx / (np.sqrt(grad_squared) + <span class="hljs-number">1e-7</span>)</code></pre><blockquote><p>The basic idea about AdaGrad algorithm is that the step of dimention with smaller gradients will be divided by small vals and make it move faster, while greater one slower to avoid zig-zag behavior.</p></blockquote><blockquote><p>while the step will become smaller and smaller while you get closer to the minima, but in turn with higher risks to stuck in the local minima.</p></blockquote><hr><h3 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9JxA0.png"></p><blockquote><p>With a decay rate to make a smooth stop the reducing of steps.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9Y99U.png"></p><hr><h3 id="Adam-almost"><a href="#Adam-almost" class="headerlink" title="Adam (almost)"></a>Adam (almost)</h3><pre><code class="hljs python">first_moment = <span class="hljs-number">0</span>second_moment = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    dx = compute_gradient(x)    first_moment = beta1 + first_moment + (<span class="hljs-number">1</span> - beta1) * dx    <span class="hljs-comment"># Momentum</span>    second_moment = beta2 * second_moment + (<span class="hljs-number">1</span> - beta2) * dx * dx    <span class="hljs-comment"># AdaGrad / RMSProp</span>    x -= learning_rate * first_moment / (np.sqrt(second_moment) + <span class="hljs-number">1e-7</span>)</code></pre><blockquote><p>It combine the two methods, but with a little bug of the first step, which gonna be super large.</p></blockquote><h3 id="Adam-full-form"><a href="#Adam-full-form" class="headerlink" title="Adam (full form)"></a>Adam (full form)</h3><pre><code class="hljs python">first_moment = <span class="hljs-number">0</span>second_moment = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_iterations):    dx = compute_gradient(x)    first_moment = beta1 + first_moment + (<span class="hljs-number">1</span> - beta1) * dx    <span class="hljs-comment"># Momentum</span>    second_moment = beta2 * second_moment + (<span class="hljs-number">1</span> - beta2) * dx * dx    <span class="hljs-comment"># AdaGrad / RMSProp</span>    first_unbias = first_moment / (<span class="hljs-number">1</span> - beta1 ** t)    second_unbias = second_moment / (<span class="hljs-number">1</span> - beta2 ** t)    x -= learning_rate * first_unbias / (np.sqrt(second_unbias) + <span class="hljs-number">1e-7</span>)</code></pre><blockquote><p>Bias correction for the fact that first and second moment estimates start at zero</p></blockquote><ul><li>Great starting point</li></ul><ol><li>beta1 = 0.9</li><li>beta2 = 0.999</li><li>learning_rate = 1e-3 or 5e-4</li></ol><hr><h3 id="Decay-the-learning-rate-to-make-it-finer"><a href="#Decay-the-learning-rate-to-make-it-finer" class="headerlink" title="Decay the learning rate to make it finer"></a>Decay the learning rate to make it finer</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9YShT.png"></p><p><img src="https://s3.ax1x.com/2020/11/13/D9YPc4.png"></p><hr><h3 id="little-bit-Fancier-Optimization"><a href="#little-bit-Fancier-Optimization" class="headerlink" title="little bit Fancier Optimization"></a>little bit Fancier Optimization</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9YC3F.png"></p><blockquote><p>First derivative optimization</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9YijJ.png"></p><blockquote><p>Second derivative optimization, direct to the mini</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9Yku9.png"></p><blockquote><p>Don’t need learning rate, but impractical for Hessian has O(N^2) elements and Inverting takes O(N^3)</p></blockquote><h4 id="Quasi-Newton-methods-BGFS"><a href="#Quasi-Newton-methods-BGFS" class="headerlink" title="Quasi - Newton methods (BGFS)"></a>Quasi - Newton methods (BGFS)</h4><p><img src="https://s3.ax1x.com/2020/11/13/D9YABR.png"></p><p><img src="https://s3.ax1x.com/2020/11/13/D9YEH1.png"></p><hr><h3 id="In-Practice"><a href="#In-Practice" class="headerlink" title="In Practice:"></a>In Practice:</h3><ul><li>Using Adam</li><li>If full batch updates can be afforded, try out <strong>L-BFGS</strong></li></ul><hr><h3 id="Reduce-the-gap-between-train-and-unseen-data"><a href="#Reduce-the-gap-between-train-and-unseen-data" class="headerlink" title="Reduce the gap between train and unseen data"></a>Reduce the gap between train and unseen data</h3><h4 id="Model-Ensembles"><a href="#Model-Ensembles" class="headerlink" title="Model Ensembles"></a>Model Ensembles</h4><ol><li>Train multiple independent models</li><li>At test time average their results</li></ol><p>2% improvement maybe</p><p><img src="https://s3.ax1x.com/2020/11/13/D9YeN6.png"></p><blockquote><p>Instead of using actual parameter vector, keep a moving average of the para vector and use that at test time</p></blockquote><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    data_batch = dataset.sample_data_batch()    loss = network.forward(data_batch)    dx = network.backward()    x += - learning_rate * dx    x_test = <span class="hljs-number">0.995</span>*x_test + <span class="hljs-number">0.005</span>*x</code></pre><h4 id="Regularization-to-make-single-model-performs-better"><a href="#Regularization-to-make-single-model-performs-better" class="headerlink" title="Regularization to make single model performs better"></a>Regularization to make single model performs better</h4><ul><li>Dropout</li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9Ym4K.png"></p><p><img src="https://s3.ax1x.com/2020/11/13/D9YK3D.png"></p><blockquote><p>Another interpretation is that you can percive each binary mask as a single model, so it just like dropout is training a large ensemble of models with shared paras.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9Yu9O.png"></p><p><img src="https://s3.ax1x.com/2020/11/13/D9YMge.png"></p><h4 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h4><blockquote><p>Which can achieve the same effect as the Dropout, for it includes some noises.</p></blockquote><h4 id="Data-Augmentation"><a href="#Data-Augmentation" class="headerlink" title="Data Augmentation"></a>Data Augmentation</h4><blockquote><p>To introduce noise to make it performs better on unseen data.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9YQjH.png"></p><h4 id="Stochastic-Depth"><a href="#Stochastic-Depth" class="headerlink" title="Stochastic Depth"></a>Stochastic Depth</h4><blockquote><p>Randomly drop layers during training.<br>Use the full networks during testing.</p></blockquote><hr><h3 id="Transfer-Learning"><a href="#Transfer-Learning" class="headerlink" title="Transfer Learning"></a>Transfer Learning</h3><blockquote><p>There is no need for huge amount of data.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9Y1ud.png"></p>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Training Neural Networks I 05</title>
    <link href="/CsBlog/2020/11/13/CS231n-05-Training-Neural-Networks-I/"/>
    <url>/CsBlog/2020/11/13/CS231n-05-Training-Neural-Networks-I/</url>
    
    <content type="html"><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><ol><li>One time setup</li><li>Training dynamics</li><li>Evaluation</li></ol><h3 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h3><ul><li>Activation Functions</li><li>Data Preprocessing</li><li>Weight initialization</li><li>Batch Normalization</li><li>Babysitting the Learning Process</li><li>Hyperparameter Optimization</li></ul><hr><h3 id="Activation-Functions"><a href="#Activation-Functions" class="headerlink" title="Activation Functions"></a>Activation Functions</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9uofs.png"></p><p><img src="https://s3.ax1x.com/2020/11/13/D9uIYj.png"></p><h4 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h4><p>$$\sigma(x) = 1/(1+e^{-x})$$</p><ul><li>Squashes numbers to range [0,1]</li><li>Historically popular “firing rate” of a neuron</li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9uhTg.png"></p><p><strong>3 Problems</strong></p><ol><li>Saturated the neural may kill the gradient.</li></ol><p><img src="https://s3.ax1x.com/2020/11/13/D9u5kQ.png"></p><blockquote><p>x is a very negative and very positive val, its gradient will be killed to zero</p></blockquote><ol><li>Sigmoid outputs are not zero-centered</li></ol><p><img src="https://s3.ax1x.com/2020/11/13/D9u7pn.png"></p><blockquote><p>For the sign of x and gradient is always the same, it gonna behaves like is above pic.</p></blockquote><blockquote><p>thats why we need zero-mean data, to optimize the w just through the zig zag path.</p></blockquote><ol><li>exp() is a bit compute expensive</li></ol><hr><h4 id="Tanh"><a href="#Tanh" class="headerlink" title="Tanh"></a>Tanh</h4><ul><li>Squashes numbers to range [-1, 1]</li><li>zero centered (nice)</li><li>still kills gradients when saturated</li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9uHlq.png"></p><hr><h4 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h4><p>$$f(x) = max(0, x)$$</p><p><img src="https://s3.ax1x.com/2020/11/13/D9ub60.png"></p><ul><li>Does not saturate (in + region)</li><li>Very computationally efficient</li><li>Converges much faster than sigmoid/tanh in practice</li><li>Actually more biologically plausible than sigmoid</li></ul><p><strong>Problems</strong></p><ol><li>Not zero-centered output</li><li>An annoyance:</li><li>when x &lt;= 0 the gradient is slashed to zero (kill half the gradient)</li></ol><p><img src="https://s3.ax1x.com/2020/11/13/D9uX0U.png"></p><ul><li>Bad Init</li><li>Learning rate too high</li></ul><blockquote><p>people like to initialize ReLU neurons with slightly positive biases (eg 0.01), to increase the possibility that being activated.</p></blockquote><hr><h4 id="Leaky-ReLu"><a href="#Leaky-ReLu" class="headerlink" title="Leaky ReLu"></a>Leaky ReLu</h4><p>$$f(x) = max(0.01x,x)$$</p><p><img src="https://s3.ax1x.com/2020/11/13/D9uqXV.png"></p><ul><li>Does not saturated</li><li>Computationally efficient</li><li>Converges much faster …</li><li><strong>will not die</strong></li></ul><p>or <strong>Para Rectifier ReLu</strong></p><p>$$f(x) = max(\alpha{x},x)$$</p><hr><h4 id="Exponential-Linear-Units-ELU"><a href="#Exponential-Linear-Units-ELU" class="headerlink" title="Exponential Linear Units (ELU)"></a>Exponential Linear Units (ELU)</h4><p><img src="https://s3.ax1x.com/2020/11/13/D9uOmT.png"></p><ul><li>All benefits of ReLU</li><li>Closer to zero mean outputs</li><li>Negative saturation regime adds some robustness to noise</li></ul><p><em>While it requires exp()</em></p><hr><h4 id="Maxout-“Neuron”"><a href="#Maxout-“Neuron”" class="headerlink" title="Maxout “Neuron”"></a>Maxout “Neuron”</h4><p><img src="https://s3.ax1x.com/2020/11/13/D9uj7F.png"></p><hr><h4 id="In-practice"><a href="#In-practice" class="headerlink" title="In practice"></a>In practice</h4><ul><li>Use ReLU. (zbe careful with learning rates)</li><li>Try Leaky <em>ReLU / Maxout / ELU</em></li><li>Don’t use sigmoid</li></ul><hr><h3 id="Data-Preprocessing"><a href="#Data-Preprocessing" class="headerlink" title="Data Preprocessing"></a>Data Preprocessing</h3><h4 id="Step1-Preprocess-the-data"><a href="#Step1-Preprocess-the-data" class="headerlink" title="Step1: Preprocess the data"></a>Step1: Preprocess the data</h4><p><img src="https://s3.ax1x.com/2020/11/13/D9uxk4.png"></p><ul><li>In CV we usually don’t normalize the data.</li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9KSh9.png"></p><p>Practice above make the data zero-mean, but only the first layer, and that’s why we need the activation func tobe zero-mean.</p><hr><h3 id="Weight-Initialization"><a href="#Weight-Initialization" class="headerlink" title="Weight Initialization"></a>Weight Initialization</h3><h4 id="First-idea-Small-random-numbers"><a href="#First-idea-Small-random-numbers" class="headerlink" title="First idea: Small random numbers"></a>First idea: Small random numbers</h4><pre><code class="hljs python">W = <span class="hljs-number">0.01</span>* np.random.randn(D,H)</code></pre><blockquote><p>Works Okay for small, but have problems in big one.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9KC11.png"></p><h4 id="How-about-making-Weight-big"><a href="#How-about-making-Weight-big" class="headerlink" title="How about making Weight big?"></a>How about making Weight big?</h4><p><img src="https://s3.ax1x.com/2020/11/13/D9KP6x.png"></p><blockquote><p>it gonna saturated the regime to be either very possitive or very negative input of tanh, and comes out near zero gradients. The weight will not be updated.</p></blockquote><h4 id="Xavier-initialization"><a href="#Xavier-initialization" class="headerlink" title="Xavier initialization"></a>Xavier initialization</h4><p><em>Woo my initialzation? haha</em></p><p><img src="https://s3.ax1x.com/2020/11/13/D9KiX6.png"></p><blockquote><p>ensure we are at the active region of tanh</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9KA0O.png"></p><blockquote><p>Can be addressed by add an extra /2， to ensure the neural won’t die in ReLU</p></blockquote><hr><h3 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9KknK.png"></p><blockquote><p>To regulize the input tobe unit gaussian.</p></blockquote><p><em>I have no idea about it. What is unit gaussian?</em></p><p><img src="https://s3.ax1x.com/2020/11/13/D9KetH.png"></p><p><img src="https://s3.ax1x.com/2020/11/13/D9KE7D.png"></p><p><img src="https://s3.ax1x.com/2020/11/13/D9KZAe.png"></p><p><img src="https://s3.ax1x.com/2020/11/13/D9Kmhd.png"></p><hr><h3 id="Babysitting-the-Learning-Process"><a href="#Babysitting-the-Learning-Process" class="headerlink" title="Babysitting the Learning Process"></a>Babysitting the Learning Process</h3><ul><li><ol><li>Preprocess data</li></ol></li><li><ol start="2"><li>Choose the architecture:</li></ol></li><li><ol start="3"><li>Double check that the loss is reasonable</li></ol></li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9KK1I.png"></p><h4 id="The-Learning-Rate"><a href="#The-Learning-Rate" class="headerlink" title="The Learning Rate"></a>The Learning Rate</h4><ul><li>Very small learning rate 1e-6<blockquote><p>litter help</p></blockquote></li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9K3B8.png"></p><ul><li>Very great learning rate 1e6<blockquote><p>go extreme</p></blockquote></li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9KQjP.png"></p><ul><li>A Rough Range</li></ul><p>$$1\times{10}^{-3} \to 1\times{10}^{-5} $$</p><hr><h3 id="Hyperparameter-Optimization"><a href="#Hyperparameter-Optimization" class="headerlink" title="Hyperparameter Optimization"></a>Hyperparameter Optimization</h3><ul><li>Cross-validation strategy</li></ul><p><em>coarse -&gt; fine</em></p><ul><li>Random Sample</li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9Ku9A.png"></p><p><img src="https://s3.ax1x.com/2020/11/13/D9KMct.png"></p><p><img src="https://s3.ax1x.com/2020/11/13/D9K1nf.png"></p>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Convolutional_Neural_Networks 04</title>
    <link href="/CsBlog/2020/11/11/CS231n-04-Convolutional-Neural-Networks/"/>
    <url>/CsBlog/2020/11/11/CS231n-04-Convolutional-Neural-Networks/</url>
    
    <content type="html"><![CDATA[<h3 id="A-bit-of-CNN-History"><a href="#A-bit-of-CNN-History" class="headerlink" title="A bit of CNN History"></a>A bit of CNN History</h3><p><img src="https://s1.ax1x.com/2020/11/11/BOGJ5n.png"></p><p><img src="https://s1.ax1x.com/2020/11/11/BOGGUs.png"></p><h4 id="Fully-Connected-Layer"><a href="#Fully-Connected-Layer" class="headerlink" title="Fully Connected Layer"></a>Fully Connected Layer</h4><p><img src="https://s1.ax1x.com/2020/11/11/BOGlDg.png"></p><h4 id="Convolution-Layer"><a href="#Convolution-Layer" class="headerlink" title="Convolution Layer"></a>Convolution Layer</h4><p><img src="https://s1.ax1x.com/2020/11/11/BOG1bQ.png"></p><blockquote><p>We just let the 5x5x3 filter $w$ to take a dot product between itself and a small 5x5z3 chunck of the image</p></blockquote><p>$$W^Tx+b$$<br><strong>The $W$ and $x$ is streched into 1 dimention vec</strong></p><ul><li>Then the Outcome:</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOG8Ej.png"></p><blockquote><p>We can use different layers on the top of it and get more activation maps stack them together to get a new image, just as the following pic depicted.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/11/BOGtCq.png"></p><blockquote><p>Then we can recursively do that work, make the front layer’s output be the next layer’s input</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/11/BOGU2V.png"></p><p><strong>The Layers may look like..</strong><br><em>Simple -&gt; Complex</em></p><p><img src="https://s1.ax1x.com/2020/11/11/BOGN80.png"></p><p><img src="https://s1.ax1x.com/2020/11/11/BOGrVJ.png"></p><ul><li>The Convolution of two signals:</li></ul><p>$$f[x,y]*g[x,y] = \sum\limits_{n_1 = -\infin}^{\infin}\sum\limits_{n_2 = -\infin}^{\infin}f[n_1,n_2]·g[x-n_1,y-n_2]$$</p><ul><li>A little bit preview</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOG0rF.png"></p><hr><ul><li>Convolution Box</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOGwKU.png"></p><blockquote><p>We can tell that the activation maps are becomming smaller after the filter, so we commonly use zero pad to deal with it.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/11/BOGBb4.png"></p><p><img src="https://s1.ax1x.com/2020/11/11/BOGsa9.png"></p><blockquote><p>The Matrix shrinks from 32 —&gt; 28 -&gt; 24 (lose info)</p></blockquote><hr><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ol><li>Accepts a volume of size $W_1 * H_1 * D_1$</li><li>Four Hyperparas<ul><li>Number of filters $K$</li><li>spatial extent $F$</li><li>stride $S$</li><li>zero padding amount $P$</li></ul></li><li>Produces a volume of size $W_2 * H_2 * D_2$<ul><li>$W_2 = (W_1 - F + 2P)/S + 1$</li><li>$H_2 = (H_1 - F + 2P)/S + 1$</li><li>$D_2 = K$ <em>Depth keeps the same</em></li></ul></li></ol><h4 id="Common-Settings"><a href="#Common-Settings" class="headerlink" title="Common Settings"></a>Common Settings</h4><p>K = (powers of 2)</p><ul><li>F = 3, S = 1, P =1</li><li>F = 5, S = 1, P =2</li><li>F = 1, S = 1, P = 0 </li></ul><hr><h3 id="Conv-details"><a href="#Conv-details" class="headerlink" title="Conv details"></a>Conv details</h3><ul><li>One by One CONV</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOGy5R.png"></p><ul><li>EXAMPLE: CONV in pyTorch</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOGRxK.png"></p><ul><li>The Brain/Neuron View of CONV</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOG226.png"></p><ul><li>Pooling layer</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOGg8x.png"></p><blockquote><p>Just spacially down sample the image to make it smaller.<br>Common Practice is Max Pooling</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/11/BOGcP1.png"></p><blockquote><p>We may can just use stride to replace pooling?</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Introduction to Convolutional neural network 03</title>
    <link href="/CsBlog/2020/11/10/CS231n-03-Introduction-to-Convolutional-neural-network/"/>
    <url>/CsBlog/2020/11/10/CS231n-03-Introduction-to-Convolutional-neural-network/</url>
    
    <content type="html"><![CDATA[<h3 id="Computational-graphs"><a href="#Computational-graphs" class="headerlink" title="Computational graphs"></a>Computational graphs</h3><p><img src="https://s1.ax1x.com/2020/11/10/BbDAaD.png"></p><h3 id="BackPropagation-A-method-to-compute-the-gradients-of-abitrarily-complex-function"><a href="#BackPropagation-A-method-to-compute-the-gradients-of-abitrarily-complex-function" class="headerlink" title="BackPropagation - A method to compute the gradients of abitrarily complex function"></a>BackPropagation - A method to compute the gradients of abitrarily complex function</h3><ul><li>A recursive application of Chain rule</li></ul><p><img src="https://s1.ax1x.com/2020/11/10/BbDCKx.png"></p><blockquote><p>We get the gradient backprop from the front and comupte with the local gradient to prop to the back.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/10/BbDPr6.png"></p><blockquote><p>In some cases, some part of the graph can be represented by some func that we already know to simplify the computations. (trade off the math)</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/10/BbDiqK.png"></p><ul><li>Patterns in backward flow</li></ul><ol><li><strong>add gate:</strong> gradient distributor (local = 1)</li><li><strong>max gate:</strong> gradient distributor (local = 1 &amp; 0)</li><li><strong>mul gate:</strong> gradient switcher (local = y &amp; x )</li></ol><p><em>Gradients add at branches n-&gt;1</em></p><ul><li>Then We Got the gradients in the form of Jacobian Matrix</li></ul><p><img src="https://s1.ax1x.com/2020/11/10/BbDkVO.png"></p><p><img src="https://s1.ax1x.com/2020/11/10/BbDZPH.png"></p><p><em>This place include some linear algebra</em></p><h3 id="Modularized-implementation-Forward-Backward-API"><a href="#Modularized-implementation-Forward-Backward-API" class="headerlink" title="Modularized implementation: Forward / Backward API"></a>Modularized implementation: Forward / Backward API</h3><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComputationalGraph</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">inputs</span>):</span>        <span class="hljs-comment"># 1. pass inputs to input gates</span>        <span class="hljs-comment"># 2. forward the computational graph</span>        <span class="hljs-keyword">for</span> gate <span class="hljs-keyword">in</span> self.graph.nodes_topologically_sorted():            gate.forward()        <span class="hljs-keyword">return</span> loss    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backward</span>():</span>        <span class="hljs-keyword">for</span> gate <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(self.graph.nodes_topologically_sorted())            gate.backward() <span class="hljs-comment"># compute the gradients</span>        <span class="hljs-keyword">return</span> inputs_gradients</code></pre><h4 id="EXAMPLE-MulGate"><a href="#EXAMPLE-MulGate" class="headerlink" title="EXAMPLE: MulGate"></a>EXAMPLE: MulGate</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiplyGate</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">x, y</span>):</span>        z = x*y        self.x = x        self.y = y    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backward</span>(<span class="hljs-params">dz</span>):</span>        dx = self.y * z        dy = self.x * z        <span class="hljs-keyword">return</span> [dx, dy]</code></pre><blockquote><p>This practice is common.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/10/BbDeGd.png"></p><h3 id="Summary-so-Far"><a href="#Summary-so-Far" class="headerlink" title="Summary so Far"></a>Summary so Far</h3><p><img src="https://s1.ax1x.com/2020/11/10/BbDmRA.png"></p><h3 id="Neural-networks"><a href="#Neural-networks" class="headerlink" title="Neural networks"></a>Neural networks</h3><p>(Before) Linear score function: $f = Wx$<br>(Now) 2-layers Neural Network $f = W_2max(0, W_1x)$<br>….or more layers</p><p><img src="https://s1.ax1x.com/2020/11/10/BbDEIe.png"></p><blockquote><p>The h is the scores W1 output, and we put one more linear layer W2 on the top of it to weighting the scores given by h </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Loss Functions and Optimization 02</title>
    <link href="/CsBlog/2020/11/08/CS231n_02_Loss-Functions-and-Optimization/"/>
    <url>/CsBlog/2020/11/08/CS231n_02_Loss-Functions-and-Optimization/</url>
    
    <content type="html"><![CDATA[<h3 id="Preview-the-Goal-in-this-lecture"><a href="#Preview-the-Goal-in-this-lecture" class="headerlink" title="Preview the Goal in this lecture"></a>Preview the Goal in this lecture</h3><ol><li>Define a loss function</li><li>Come up with a way of finding the paras that minimize the (1)<br>(optimization)</li></ol><p><strong>The Remain Problem from last lecture</strong></p><ul><li>How to choose the W para ? </li></ul><p><img src="https://s1.ax1x.com/2020/11/08/BTZxgK.png"></p><h3 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h3><blockquote><p>A loss function tells how good our current classifier is.</p></blockquote><p>$${(x_i,y_i)}_{i=1}^N$$</p><p>The $X_i$ is image and the $y_i$ is label (int)</p><p>The Total loss is defined as the func follows.</p><p>$$L = \frac{1}{N}\sum\limits_iL_i(f(x_i,W),y_i)$$<br><em>Which is the sum of every single test’s loss</em></p><hr><h4 id="Muticlass-SVM-loss"><a href="#Muticlass-SVM-loss" class="headerlink" title="Muticlass SVM loss"></a><strong>Muticlass SVM loss</strong></h4><p>Given an example $(x_i,y_i)$ where $x_i$ is the image and where $y_i$ is the (int) label, using the shorthand for the score vec $s = f(x_i,W)$</p><p>The SVM loss has the form:</p><p><img src="https://s1.ax1x.com/2020/11/08/BTZ7B4.png"></p><blockquote><p>if the incorrect score is smaller than the right score (x margin), we set the loss to 0.<br>in this case the safe margin is set to one<br><strong>Margin choice depends on our need</strong></p></blockquote><ul><li>Then we loop the class</li></ul><p><img src="https://s1.ax1x.com/2020/11/08/BTZqE9.png"></p><p><img src="https://s1.ax1x.com/2020/11/08/BTZLNR.png"></p><ul><li>What if we use</li></ul><p>$$L = \frac{1}{N}\sum\limits_iL_i(f(x_i,W),y_i)^2$$</p><blockquote><p>This is not a linear function and totally different, it’s may be useful sometimes depends on the way you care about the errors.</p></blockquote><h4 id="Example-Code"><a href="#Example-Code" class="headerlink" title="Example Code"></a>Example Code</h4><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">L_i_vectorized</span>(<span class="hljs-params">x, y, W</span>):</span>    scores = W.dot(x)    margins = np.maximun(<span class="hljs-number">0</span>, scores - scores[y] + margin)    margins[y] = <span class="hljs-number">0</span>    loss_i = np.<span class="hljs-built_in">sum</span>(margins)    <span class="hljs-keyword">return</span> loss_i    <span class="hljs-comment"># pretty easy</span></code></pre><p><img src="https://s1.ax1x.com/2020/11/08/BTZO41.png"></p><blockquote><p>It just change the gap bettween scores</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTZzjO.png"></p><p><img src="https://s1.ax1x.com/2020/11/08/BTe9De.png"></p><blockquote><p>often use L2 regularization just Euclid norm.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTepuD.png"></p><blockquote><p>In this case the L1 and L2 reg is equal, but we can tell that L1 prefers the $w_1$ for it contains more zero, while the L2 prefers the $w_2$ for the weight is evenly spreaded through the test case.</p></blockquote><blockquote><p>The Multiclass SVM loss just care about the gap bettween the right labels and the wrongs.</p></blockquote><h4 id="Softmax-Classifier"><a href="#Softmax-Classifier" class="headerlink" title="Softmax Classifier"></a><strong>Softmax Classifier</strong></h4><p><img src="https://s1.ax1x.com/2020/11/08/BTeiEd.png"></p><blockquote><p>We just want to make the true probability closer to 1 (closer the better, eq is the best), so the loss func can be chosed by using the -log on the $P$.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTeCHH.png"></p><blockquote><p>If we want to get the zero loss, the score may goes to inf! But Computer don’t like that.</p></blockquote><ul><li>Debugging Way<br>outcomes might be $logC$</li></ul><hr><p><img src="https://s1.ax1x.com/2020/11/08/BTek4I.png"></p><p><img src="https://s1.ax1x.com/2020/11/08/BTeECt.png"></p><hr><h3 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h3><h4 id="Random-Search-The-Naive-but-Simplest-way"><a href="#Random-Search-The-Naive-but-Simplest-way" class="headerlink" title="Random Search - The Naive but Simplest way"></a>Random Search - The Naive but Simplest way</h4><blockquote><p>Really Slow !!!</p></blockquote><h4 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h4><blockquote><p>We just get the Gradient of W and go down to the bottom (maybe local best?)</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTeFUA.png"></p><p><strong>Code</strong></p><pre><code class="hljs python"><span class="hljs-comment"># Vanilla Gradient Descent</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    weight_grad = evaluate_gradient(loss_fun, data, weights)    weights += -step_size * weight_grad</code></pre><p><strong>Step size is called elearning rate which is important</strong></p><p><img src="https://s1.ax1x.com/2020/11/08/BTeV8P.png"></p><blockquote><p>Since the N might be super large, we sample some sets called minibatch and use it to estimate the true gradient.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTeZgf.png"></p><hr><p><img src="https://s1.ax1x.com/2020/11/08/BTenKS.png"></p><p><img src="https://s1.ax1x.com/2020/11/08/BTeuDg.png"></p><p><strong>Color Feature</strong><br><img src="https://s1.ax1x.com/2020/11/08/BTeQEj.png"></p><p><strong>Gradient</strong> <em>Extract the edge info</em><br><img src="https://s1.ax1x.com/2020/11/08/BTelUs.png"></p><p><strong>NLP?</strong><br><img src="https://s1.ax1x.com/2020/11/08/BTeG80.png"></p><blockquote><p>clustering different image patches from images</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTe15n.png"></p><ul><li>Differences</li></ul><ol><li>Extract the Feature at first and feed into the linear classificator</li><li>Convolutional Neutral Network would learn the feature automatically during the training process.</li></ol>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Image Classification 01</title>
    <link href="/CsBlog/2020/11/07/CS231n_01_Image_Classification/"/>
    <url>/CsBlog/2020/11/07/CS231n_01_Image_Classification/</url>
    
    <content type="html"><![CDATA[<p><strong>Preface:</strong> This is the note of Stanford course CS231n, paving the way for my lab research.</p><h1 id="Image-Classification"><a href="#Image-Classification" class="headerlink" title="Image Classification"></a>Image Classification</h1><p><em>A core task in Computer Vision</em></p><hr><h3 id="Computer’-Work"><a href="#Computer’-Work" class="headerlink" title="Computer’ Work"></a>Computer’ Work</h3><p>Input an image, and assign one of the label amoung the given labels.</p><ul><li><strong>The Problem:</strong> </li></ul><ol><li>Semantic Gap</li><li>Viewpoint variation</li><li>illumination </li><li>Deformation</li><li>Occlusion</li><li>Intraclass variation</li></ol><hr><h3 id="An-image-classifier"><a href="#An-image-classifier" class="headerlink" title="An image classifier"></a>An image classifier</h3><blockquote><p>Coding might be difficult </p></blockquote><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classify_image</span>(<span class="hljs-params">image</span>):</span>    <span class="hljs-comment"># Do Some Magic</span>    <span class="hljs-keyword">return</span> class_label</code></pre><ul><li>Attmpts</li></ul><p><img src="https://s1.ax1x.com/2020/11/07/BIMSmD.png"></p><hr><h3 id="Data-Driven-Approach"><a href="#Data-Driven-Approach" class="headerlink" title="Data-Driven Approach"></a>Data-Driven Approach</h3><ol><li>Collect a dataset of images and labels</li><li>Use Machine Learning to train a classifier</li><li>Evaluate the classifier on new images</li></ol><ul><li>First classifier: Nearest Neighbor</li></ul><p><em>Just Memorize all data and labels</em></p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span>(<span class="hljs-params">images, labels</span>):</span>    <span class="hljs-comment"># Machine Learning!</span>    <span class="hljs-keyword">return</span> model</code></pre><p><em>Predict the label of the most similar training image</em></p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span>(<span class="hljs-params">model, test_images</span>):</span>    <span class="hljs-comment"># Use model to predict labels</span>    <span class="hljs-keyword">return</span> test_labels</code></pre><p><strong>Example Dataset:</strong> CIFAR10</p><p><img src="https://s1.ax1x.com/2020/11/07/BIM9TH.png"></p><blockquote><p><strong>Issues:</strong> Although pics may seem visually similar, but still give lots of errors.</p></blockquote><hr><ul><li>Compare func used in it<h3 id="K-nearest-Neighbors-Method"><a href="#K-nearest-Neighbors-Method" class="headerlink" title="K nearest Neighbors Method"></a><strong>K nearest Neighbors Method</strong></h3></li></ul><p><strong>L1 distance:</strong> $d_1(I_1,I_2) = \sum\limits_{p} \mid I_1^p - I_2^p \mid$</p><p><img src="https://s1.ax1x.com/2020/11/07/BIKXSx.png"></p><p><em>Minimize the sum given the most similar pics</em></p><h4 id="BackWards"><a href="#BackWards" class="headerlink" title="BackWards"></a><strong>BackWards</strong></h4><p><img src="https://s1.ax1x.com/2020/11/07/BIKjl6.png"></p><h4 id="What-it-looks-like"><a href="#What-it-looks-like" class="headerlink" title="What it looks like"></a><strong>What it looks like</strong></h4><p><img src="https://s1.ax1x.com/2020/11/07/BIMp0e.png"></p><p><strong>Issues</strong></p><ol><li>Isolated Yellow Point</li><li>Noisy of one single point (green into blue)</li></ol><p><strong>Use K Nearest Neighbors to Optimize it</strong><br><img src="https://s1.ax1x.com/2020/11/07/BIMitA.png"></p><hr><p><em>A Better Cmp Func</em><br><strong>L2(Euclidean) distance:</strong> $d_1(I_1,I_2) = \sqrt{\sum\limits_{p}{(I_1^p - I_2^p)}^2}$</p><p><img src="https://s1.ax1x.com/2020/11/07/BIMFfI.png"></p><blockquote><p>The L1 Distance depends on the coordinate system, whenever there is a rotate, it would change the L1 Distance, while that won’t happen in the L2 Distance case (simply because it’s a circle)</p></blockquote><hr><h4 id="Hyperparameters"><a href="#Hyperparameters" class="headerlink" title="Hyperparameters"></a><strong>Hyperparameters</strong></h4><ul><li>What’s the best value of <strong>k</strong></li><li>What’s the best <strong>distance</strong> to use? (L1,L2 or anything else)</li></ul><p><em>These things are preset rather than learn automatically from learning process</em></p><p>This is <strong>Very problem-dependent</strong>, just try!, but How?</p><p><img src="https://s1.ax1x.com/2020/11/07/BIME1P.png"></p><p><strong>Training &amp; Validation process should not mixed with the test data</strong></p><ul><li>Cross Validation</li></ul><p><img src="https://s1.ax1x.com/2020/11/07/BIMApt.png"></p><ul><li>Validation process</li></ul><p><img src="https://s1.ax1x.com/2020/11/07/BIMV6f.png"></p><blockquote><p>using the validation data to choose the best hyperparameters.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/07/BIMu7Q.png"></p><blockquote><p>Cause we sum the offset, though the differences bettween pics and pics are various, they still got the same L2 distance, which is not so good.</p></blockquote><hr><h3 id="Linear-Classification"><a href="#Linear-Classification" class="headerlink" title="Linear Classification"></a><strong>Linear Classification</strong></h3><ul><li><strong>Parametric Model</strong><br><img src="https://s1.ax1x.com/2020/11/07/BIMZX8.png"></li></ul><p>$$f(x,W) = Wx + b$$</p><blockquote><p>We need f(x,W) to be 10x1 and the x is actually 3072x1, so the W we input may be 10x3072, sometimes we add a bias to balance.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/07/BIMn0g.png"></p><p><img src="https://s1.ax1x.com/2020/11/07/BIMMkj.png"></p><blockquote><p>It use a single line to separate the object based on its RGB info</p></blockquote><p>But how can we tell the quality of W ?<br>(View the next lecture)</p><ul><li><strong>Problems</strong><br><img src="https://s1.ax1x.com/2020/11/07/BIMQts.png"></li></ul><blockquote><p>Since it’s linear the Problems is obivious.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS-Lab2 二进制炸弹</title>
    <link href="/CsBlog/2020/11/06/ICS_Lab2/"/>
    <url>/CsBlog/2020/11/06/ICS_Lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="ICS-Lab2-Bomb"><a href="#ICS-Lab2-Bomb" class="headerlink" title="ICS-Lab2-Bomb"></a>ICS-Lab2-Bomb</h1><blockquote><p>这个是CS:APP的第二个lab，主要着重于汇编代码的阅读</p></blockquote><hr><h2 id="完成截图"><a href="#完成截图" class="headerlink" title="完成截图"></a>完成截图</h2><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_244e1f55d2823d58f65eabab9478d7ce.png"></p><hr><h2 id="Phase-1-入门"><a href="#Phase-1-入门" class="headerlink" title="Phase 1 - 入门"></a>Phase 1 - 入门</h2><h3 id="一、分析"><a href="#一、分析" class="headerlink" title="一、分析"></a>一、分析</h3><blockquote><p>练手入门题，用esi寄存器储存答案地址 (一个立即数)</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">402400</span>,%esi</code></pre><blockquote><p>之后调用了一个 string_not_equal 函数比较输入和答案是否一致，一致就通过了。</p></blockquote><pre><code class="hljs angelscript">callq  <span class="hljs-number">401338</span> &lt;<span class="hljs-built_in">string</span>s_not_equal&gt;</code></pre><h3 id="二、gdb调试"><a href="#二、gdb调试" class="headerlink" title="二、gdb调试"></a>二、gdb调试</h3><blockquote><p>看一下内存地址里面存了什么，获得flag</p></blockquote><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_4801c7e177c56f6e7299c273d0120988.png"></p><ul><li><strong>答案</strong>: Border relations with Canada have never been better.</li></ul><hr><h2 id="Phase-2-循环"><a href="#Phase-2-循环" class="headerlink" title="Phase 2 - 循环"></a>Phase 2 - 循环</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>本题是一个do while Loop, 难度不大, 耐心读就行了</p></blockquote><p><strong>关键位置</strong></p><ul><li>信息1 ： 看到 read_six_number 知道输入6个数，再往下看</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">cmpl</span>   $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,(%rsp) # 比较栈顶地址所存变量大小是否为<span class="hljs-number">1</span><span class="hljs-attribute">je</span>     <span class="hljs-number">400</span>f<span class="hljs-number">30</span> &lt;phase_<span class="hljs-number">2</span>+<span class="hljs-number">0</span>x<span class="hljs-number">34</span>&gt; # 如果为<span class="hljs-number">1</span> 跳转至地址 <span class="hljs-number">400</span>f<span class="hljs-number">30</span><span class="hljs-attribute">callq</span>  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt; # 如果不为<span class="hljs-number">1</span>，直接炸了<span class="hljs-attribute">jmp</span>    <span class="hljs-number">400</span>f<span class="hljs-number">30</span> &lt;phase_<span class="hljs-number">2</span>+<span class="hljs-number">0</span>x<span class="hljs-number">34</span>&gt; # 跳转至地址 <span class="hljs-number">400</span>f<span class="hljs-number">30</span></code></pre><ul><li>信息2 : 第一个数为1</li></ul><p>下面进入Loop Body</p><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_27148224f8cf2be48266eaa52f50b2f8.png"></p><ul><li>信息3 :<br>可以看到这个循环把前一个数乘了2，跟后一个数比较, 如果相等就能够继续，不然就炸了。</li></ul><blockquote><p>综上也就是说这是一个首项为1，公比为2的等比数列，共6项。</p></blockquote><p>所以答案就是 1 2 4 8 16 32</p><hr><h2 id="Phase-3-分支"><a href="#Phase-3-分支" class="headerlink" title="Phase 3 - 分支"></a>Phase 3 - 分支</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><blockquote><p>第三题关键点在于用gdb查看一下jumptable</p></blockquote><p> 我们先看一下输入，在输入了两个变量后，esi里放了内存中的一个可疑的东西，我们用gdb看一眼。</p><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">4025</span>cf,%esi</code></pre><pre><code class="hljs shell">(gdb) p(char *) 0x4025cf&quot;%d %d&quot;</code></pre><p> 发现原来是输入两个整型，再往下看</p><pre><code class="hljs apache"><span class="hljs-attribute">cmpl</span>   $<span class="hljs-number">0</span>x<span class="hljs-number">7</span>,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp) # 将 M(rsp + <span class="hljs-number">8</span>) 看作<span class="hljs-number">32</span>位无符号数跟<span class="hljs-number">7</span>比较<span class="hljs-attribute">ja</span>     <span class="hljs-number">400</span>fad &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">6</span>a&gt; # 如果大于就跳转至 <span class="hljs-number">0</span>x<span class="hljs-number">400</span>fad (炸弹炸了)</code></pre><p> 发现如果输入的第一个数大于7就爆炸了，看来switch最多只有7个case</p><pre><code class="hljs angelscript">jmpq   *<span class="hljs-number">0x402470</span>(,%rax,<span class="hljs-number">8</span>) # 跳转至 (eax * <span class="hljs-number">8</span> + <span class="hljs-number">0x402470</span>)处所存的地址 （jumptable）</code></pre><blockquote><p>最关键的是这一句，构造了一个 switch 的 jumptable，我们知道地址是 0x402470，按照 case * 8 + 0x402470 跳转到该地址里面的地址，所以我们用gdb看一下。</p></blockquote><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_ae5e359c30ff5ccb9292a7472c39eb19.png"></p><ul><li><p>我通关选了case 1（它比较特殊，处理它其他内存地址跳转都是按case从小到大顺序的，只有case 1 在最后一个，当然其他也都能过。）</p></li><li><p>case 1 跳转到了 0x400fb9 地址</p></li></ul><pre><code class="hljs angelscript">mov    $<span class="hljs-number">0x137</span>,%eax # eax = <span class="hljs-number">0x137</span> (<span class="hljs-number">311</span>) (不用跳转了，下面就是 <span class="hljs-number">0x400fbe</span>)</code></pre><p>其将eax置为了0x137，要小心是16进制，所以对应十进制311</p><pre><code class="hljs apache"><span class="hljs-attribute">cmp</span>    <span class="hljs-number">0</span>xc(%rsp),%eax # 比较 M(rsp + <span class="hljs-number">12</span>) 和 eax<span class="hljs-attribute">je</span>     <span class="hljs-number">400</span>fc<span class="hljs-number">9</span> &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">86</span>&gt; # 如果相等就跳转至 <span class="hljs-number">0</span>x<span class="hljs-number">400</span>fc<span class="hljs-number">9</span> (过关了！)</code></pre><p>最后是一个比较，如果eax和第二个输入值相同就过了。</p><ul><li>本题答案（不唯一)</li></ul><table><thead><tr><th align="center">case</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th></tr></thead><tbody><tr><td align="center">ans</td><td align="center">207</td><td align="center">311</td><td align="center">707</td><td align="center">256</td><td align="center">389</td><td align="center">206</td><td align="center">682</td><td align="center">327</td></tr></tbody></table><hr><h2 id="Phase-4-递归"><a href="#Phase-4-递归" class="headerlink" title="Phase 4 - 递归"></a>Phase 4 - 递归</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ul><li>这题是个递归，不过不用很深，很快就能看出答案。</li></ul><p>先正常读两个数，放在rdx，rcx中，检查输入。</p><pre><code class="hljs angelscript">cmpl   $<span class="hljs-number">0xe</span>,<span class="hljs-number">0x8</span>(%rsp) # 比较 M(rsp + <span class="hljs-number">8</span>) (既 rdx) 与 <span class="hljs-number">0xe</span>jbe    <span class="hljs-number">40103</span>a &lt;phase_4+<span class="hljs-number">0x2e</span>&gt; # 如果 rdx &lt;= <span class="hljs-number">0xe</span> (<span class="hljs-number">14</span>) 跳转至 <span class="hljs-number">0x40103a</span>, 不然就炸了 (作为无符号数)</code></pre><blockquote><p>这两行汇编告诉我们，rdx一定要小于 0xe (14) 且大于等于0, 不然炸了, 大幅度缩小了范围。</p></blockquote><blockquote><p>接下来就进入了函数递归调用，先做点预处理，把edx里面存一个立即数14，然后edi为第一个输入值，esi = 0 进入fun4</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>xe,%edx # edx = <span class="hljs-number">0</span>xe (<span class="hljs-number">14</span>)<span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%esi # esi = <span class="hljs-number">0</span><span class="hljs-attribute">mov</span>    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp),%edi # edi = (第一个输入值)<span class="hljs-attribute">callq</span>  <span class="hljs-number">400</span>fce &lt;func<span class="hljs-number">4</span>&gt; # 调用func<span class="hljs-number">4</span></code></pre><blockquote><p>先不着急看fun4，先看看最后要怎么过关</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">test</span>   %eax,%eax # eax &amp; eax<span class="hljs-attribute">jne</span>    <span class="hljs-number">401058</span> &lt;phase_<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">4</span>c&gt; <span class="hljs-comment"># 如果ZF == 0 就跳转（既eax != 0)，跳转至 0x401058 炸了</span><span class="hljs-attribute">cmpl</span>   $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,<span class="hljs-number">0</span>xc(%rsp) # 比较 M(rsp + <span class="hljs-number">12</span>) 和 <span class="hljs-number">0</span><span class="hljs-attribute">je</span>     <span class="hljs-number">40105</span>d &lt;phase_<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">51</span>&gt; # 如果相等就跳转到 <span class="hljs-number">0</span>x<span class="hljs-number">40105</span>d, 不然就炸了</code></pre><ul><li>test 实际上就是一个与操作，所以我们知道需要 eax == 0 且 M(rsp + 12) == 0，到这我们发现，第二个条件只要我们一开始输入的第二个参数为0，就能够保证，那么下面我们就要看进入fun4之后如何让返回值 eax == 0</li></ul><blockquote><p>再回来看fun4，其分为两部分，一个是递归的主体，一个是判断是否继续递归。一开始先对eax 和 ecx 进行一些操作。</p></blockquote><ul><li>我们发现 eax 和 ecx 的值在第一层递归都被置为14，(esi 为 0)按其操作得到 eax 除2, ecx 逻辑右移 31 位为0, 接着其实就是比较 edi 和 rax, <strong>相当于就是比较第一个参数和常数 7</strong></li></ul><pre><code class="hljs apache"><span class="hljs-attribute">jle</span>    <span class="hljs-number">400</span>ff<span class="hljs-number">2</span> &lt;func<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">24</span>&gt; # 若ecx &lt;= 就跳转至 <span class="hljs-number">0</span>x<span class="hljs-number">400</span>ff<span class="hljs-number">2</span></code></pre><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax # eax = <span class="hljs-number">0</span>;<span class="hljs-attribute">cmp</span>    %edi,%ecx # 比较 ecx 和 edi <span class="hljs-attribute">jge</span>    <span class="hljs-number">401007</span> &lt;func<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">39</span>&gt; <span class="hljs-comment"># 若 edi &gt;= ecx 跳转至 0x401007 返回</span></code></pre><ul><li>接着是一个跳转, 如果满足我们就跳转至 0x400ff2, 我们发现这里已经满足了我们需要的 eax == 0，而想要结束就得使 edi &gt;= ecx (7), 所以我们发现，对于上下两个跳转条件，只要 edi == ecx == 7 就能一直成立，从而直接达成条件，不用进入递归。</li></ul><p>进而我们得到了本题答案：7 0</p><hr><h2 id="Phase-5-指针"><a href="#Phase-5-指针" class="headerlink" title="Phase 5 - 指针"></a>Phase 5 - 指针</h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><ul><li>这题我觉得是最好玩的一题，先直接分析如何通关。</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">40245</span>e,%esi # esi = <span class="hljs-number">0</span>x<span class="hljs-number">40245</span>e <span class="hljs-comment"># 待比较的 string (flyers) 从 0x40245e 移动至 esi</span></code></pre><ul><li>我们在接近返回时看到了一个非常可疑的内存地址，直接给它打出来。</li></ul><pre><code class="hljs lsl">(gdb) p(char*) <span class="hljs-number">0x40245e</span>$<span class="hljs-number">4</span> = <span class="hljs-number">0x40245e</span> <span class="hljs-string">&quot;flyers&quot;</span></code></pre><blockquote><p>发现是一个可疑字符串 flyers，阅读上下文汇编代码可知，最后是比较字符串是否和指定字符串 “flyers” 一致。</p></blockquote><ul><li>我们再往上看看要怎么输入</li></ul><pre><code class="hljs angelscript">callq  <span class="hljs-number">40131</span>b &lt;<span class="hljs-built_in">string</span>_length&gt; # 比较字符长度是否为<span class="hljs-number">6</span>cmp    $<span class="hljs-number">0x6</span>,%eax # 比较 eax 和 <span class="hljs-number">6</span></code></pre><p>发现输入一定要是六个字符 <em>(于是试了试 flyers 果然不对)</em></p><ul><li>往下看，发现了一个 Loop 循环了6次</li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_016df1440f7044a54fb4ced529595b58.png"></p><blockquote><p>经过仔细阅读后，发现这个居然是遍历六个输入字符，将其 ascii 码低4位取出来作为偏移量 (offset),在一个基地址 （0x4024b0）后面取字符出来组成 flyers.</p></blockquote><ul><li>立刻开启 gdb 查看基地址附近的内存</li></ul><p><strong>发现分别对应的偏移量是 9, 15, 14, 5, 6, 7</strong></p><blockquote><p>直接查 ascii 码，发现对应 ionefg 、IONEFG 或者有一些不是字母的字符也行，只要低四位是正确的就可以。 </p></blockquote><p><strong>本题答案:</strong>  ionefg (答案不唯一)</p><hr><h2 id="Phase-6-Node结构体"><a href="#Phase-6-Node结构体" class="headerlink" title="Phase 6 - Node结构体"></a>Phase 6 - Node结构体</h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>这题还是比较麻烦的，代码比较长也比较复杂，要耐心读。</p><ul><li>这题的代码可以大致分为输入检测与处理和一个对结构体的顺序检测.<blockquote><p>最开始上来先输入六个数之后有个双循环，外部保证输入的六个数要大于等于1，且小于等于6，内部保证互异。所以总体看来就是输入的六个数就是123456, 现在问题是输入的顺序。</p></blockquote></li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_7194e52688ff3d696a3b889e2b17d63f.png"></p><p>这段代码遍历了所有输入并用7减去了输入的每个数，所以最后做出答案要记得反一下。</p><ul><li>接下来代码比较复杂，外面大循环循环了六次，内部有两个平行的小循环。作用是构造结构体，并在栈帧中将其存放位置按照输入的数的大小计算得出</li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_9ea5cd30293a18357af1da93c35e0f59.png"></p><blockquote><p>分析代码，我们先发现一种特殊情况就是当前计算的数为1时（输入为6）edx直接就是给定的地址 0x6032d0, 其余的都按照其大小，在第一个小循环中循环相应次数，给 rdx 在原地址上相应偏移16位。</p></blockquote><blockquote><p>接着下来将其存入栈帧中 rsp + 32 到 rsp + 80 的位置</p></blockquote><ul><li>使用 gdb 查看 node</li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_f2ecdd05728cbefbba59b068a29fdfdc.png"></p><p>最后我们看如何通关</p><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_a18a67d1b4dbfa16a7fd8800e3ee304b.png"></p><blockquote><p>发现通关条件是要求定序，前面node大于后面的节点，根据gdb node节点的值和要求我们得到了 3 4 5 6 1 2 的结果，最后不要忘记这是被7减过之后的结果，原来的输入要还原。所以答案就是 4 3 2 1 6 5</p></blockquote><p><strong>本题答案:</strong> 4 3 2 1 6 5</p><hr><h2 id="Secret-Phase-递归"><a href="#Secret-Phase-递归" class="headerlink" title="Secret Phase- 递归"></a>Secret Phase- 递归</h2><h3 id="一、进入方法"><a href="#一、进入方法" class="headerlink" title="一、进入方法"></a>一、进入方法</h3><ul><li>输入上面六种答案之后，发现 secret phase 并没有出现，于是开始着手寻找入口。</li></ul><blockquote><p>根据最后结果出现的字符顺藤摸瓜找到了 phase_defuse 函数，一看发现其中有一个可疑的 <string_not_equal> 函数以及几个可疑的内存地址,统统用 gdb 打印。</string_not_equal></p></blockquote><pre><code class="hljs perl">(gdb) p(char*) <span class="hljs-number">0x402619</span>$2 = <span class="hljs-number">0x402619</span> <span class="hljs-string">&quot;%d %d %s&quot;</span></code></pre><pre><code class="hljs lsl">(gdb) p(char*) <span class="hljs-number">0x402622</span>$<span class="hljs-number">3</span> = <span class="hljs-number">0x402622</span> <span class="hljs-string">&quot;DrEvil&quot;</span></code></pre><blockquote><p>发现之前调用过的__isoc99_sscanf@plt 还有隐藏用法，在输入两个数后再输入一个字符串 “DrEvil” 就能成功开启secret phase.</p></blockquote><ul><li>所以我们在最后一次调用__isoc99_sscanf@plt的 phase 4 输入 7 0 DrEvil, 果然在 phase 6 之后进入了 secret phase。</li></ul><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><ul><li>虽然说是隐藏关，但是复杂度和难度比 phase 6 低了不少，和 phase 4 一样是一个递归，但不同的是这次真的需要递归几次，但也不深。只要确定好路线还是比较容易的。</li></ul><pre><code class="hljs angelscript">callq  <span class="hljs-number">40149</span>e &lt;read_line&gt; # 读一行...callq  <span class="hljs-number">400</span>bd0 &lt;<span class="hljs-symbol">strtol@</span>plt&gt; # 调用 <span class="hljs-symbol">strtol@</span>plt</code></pre><blockquote><p>secret phase上来读了一整行然后调用了一个 strtol，经过阅读strtol的源码，发现它是以10为base将字符串转为一个整型，实际上就是剔除了最后答案中除了数字以外的字符。(所以写上答案数字然后乱输字母也能过 bushi)</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">lea</span>    -<span class="hljs-number">0</span>x<span class="hljs-number">1</span>(%rax),%eax <span class="hljs-comment"># eax = (rax) - 1</span><span class="hljs-attribute">cmp</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">3</span>e<span class="hljs-number">8</span>,%eax <span class="hljs-comment"># eax == 0x3e8 ? (即判断返回值与0x3e9)</span></code></pre><ul><li>这段代码告诉我们输入的数要小于 1000</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">6030</span>f<span class="hljs-number">0</span>,%edi # edi = <span class="hljs-number">0</span>x<span class="hljs-number">6030</span>f<span class="hljs-number">0</span> (<span class="hljs-number">36</span>)<span class="hljs-attribute">callq</span>  <span class="hljs-number">401204</span> &lt;fun<span class="hljs-number">7</span>&gt; # 调用fun<span class="hljs-number">7</span></code></pre><ul><li>将edi置为 0x6030f0 (里面存的是36) 接着开始调用fun7</li></ul><blockquote><p>我们先不着急看fun7, 老样子先看过关要求。</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">cmp</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">2</span>,%eax # 比较一下 eax 返回是否为<span class="hljs-number">2</span></code></pre><p>发现非常简单，只要eax返回值为2就行</p><ul><li>再来看fun7</li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_64ed470376ec6b72dc43690bf9b4ea0e.png"></p><blockquote><p>一看这个递归是逃不过了，但我们要让eax == 2, 路线其实非常明确，第一次先走 way3 将 eax 弄成1，再走 way1 让eax*2， 最后一层我们让eax == 0 最后返回我们得到的 eax 就等于2<br><em>（eax = 0 -&gt; 1 -&gt; 2）</em></p></blockquote><blockquote><p>关键是一个 edx 和 esi 的比较，edx == rdi, 然后每次改变rdi使其中储存地址中所储存的变量逐步接近 esi 完成递归操作。</p></blockquote><p>根据所存地址(注意/d打出的是10进制)，可以很容易找出递归路径</p><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_dfddd1801cd10c701dd2753164434977.png" style="width:65%"></p><ul><li>输入22可以正好满足需求<blockquote><p><strong>22 &lt;= 36 因而 rdi = (rdi + 8) (存8)，22 &gt; 8 因而 rdi = = (rdi + 16) (存22), 22==22 所以 eax 返回 0 ，返回 1， 返回2，最终过关</strong></p></blockquote></li></ul><p><strong>本题答案:</strong> 22 (可以带非数字字符)</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Assembly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS-Lab1 位运算</title>
    <link href="/CsBlog/2020/11/05/ICS_Lab1/"/>
    <url>/CsBlog/2020/11/05/ICS_Lab1/</url>
    
    <content type="html"><![CDATA[<h1 id="ICS-Lab1-位运算"><a href="#ICS-Lab1-位运算" class="headerlink" title="ICS_Lab1-位运算"></a>ICS_Lab1-位运算</h1><blockquote><p>这个是CS:APP的第一个lab，也是我ICS课上的第一个lab，主要注重于使用受限制的位运算来完成操作</p></blockquote><hr><h2 id="Bits-c"><a href="#Bits-c" class="headerlink" title="Bits.c"></a><strong>Bits.c</strong></h2><h3 id="1-bitAnd–与"><a href="#1-bitAnd–与" class="headerlink" title="1. bitAnd–与"></a><strong>1. bitAnd–与</strong></h3><p><strong>题目：</strong></p><pre><code>只用~和|实现&amp;</code></pre><p><strong>样例：</strong></p><pre><code>bitAnd(6, 5) = 4</code></pre><p><strong>可使用操作：</strong> ~ |</p><p><strong>最大操作数限制：</strong> 8</p><p><strong>使用操作数：</strong> 4</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitAnd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;  <span class="hljs-keyword">return</span> ~(~x | ~y); <span class="hljs-comment">//De Morgan&#x27;s laws</span>&#125;</code></pre><blockquote><p>应用摩根律 <del>(x | y) = ~x &amp; ~y, 可得 x &amp; y = ~(</del>x | ~y)</p></blockquote><hr><h3 id="2-getByte–获取字节"><a href="#2-getByte–获取字节" class="headerlink" title="2. getByte–获取字节"></a><strong>2. getByte–获取字节</strong></h3><p><strong>题目：</strong></p><pre><code>从x中提取字节n, n编号从0至3</code></pre><p><strong>样例：</strong></p><pre><code>getByte(0x12345678,1) = 0x56</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 6</p><p><strong>使用操作数：</strong> 3</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getByte</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">return</span> (x &gt;&gt; (n &lt;&lt; <span class="hljs-number">3</span>)) &amp; <span class="hljs-number">0xff</span>;&#125;</code></pre><p><strong>分析：</strong></p><p>*由于 1Byte = 8bits = 2^3bits， 所以 n Bytes = 2^3 * n bits*</p><blockquote><p>因而将n左移3位，即 n * 2^3, 再将x右移 n * 2^3 即可将所求字节放在低8位，将其与上0xff，即可取出字节。</p></blockquote><hr><h3 id="3-logicalShift–逻辑右移"><a href="#3-logicalShift–逻辑右移" class="headerlink" title="3. logicalShift–逻辑右移"></a><strong>3. logicalShift–逻辑右移</strong></h3><p><strong>题目：</strong></p><pre><code>将x逻辑右移n位</code></pre><p><strong>样例：</strong></p><pre><code>logicalShift(0x87654321,4) = 0x08765432</code></pre><p><strong>可使用操作：</strong>  ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 20</p><p><strong>使用操作数：</strong> 10</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">logicalShift</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-comment">//flag equals to: if n == 0 return 0; else return 1;</span>  <span class="hljs-keyword">int</span> flag = !!n;  <span class="hljs-keyword">int</span> mask = ~(flag &lt;&lt; (<span class="hljs-number">32</span> + (~n + <span class="hljs-number">1</span>)));  <span class="hljs-keyword">return</span> (x &gt;&gt; n) &amp; mask;&#125;</code></pre><p><strong>分析：</strong></p><ul><li><p>算数右移</p><blockquote><p>算数右移即在右移后用原符号位数将高位补齐，保持右移后二进制数的符号保持不变。</p></blockquote></li><li><p>逻辑右移</p><blockquote><p>逻辑右移即在右移后用 0 将高位补齐，是“逻辑上”的右移。</p></blockquote></li></ul><blockquote><p>在正常右移运算中使用的是算数右移，因而要解决的问题即对于负数如何将最高位补上0，而非符号位1。<br>我采取掩码的方式，先将x正常右移n位与上其高位的掩码，使其右移产生的高位变为0</p></blockquote><ul><li>掩码构造<blockquote><p>掩码不能草率的构造为 ~(-1 &lt;&lt; (32 - n)), 这种构造方式当n为0时会因-1被左移32位而导致异常，构造出来的mask仍为0</p></blockquote></li></ul><blockquote><p>由于不能使用if，为判断n是否为0，我才用了一个flag = !n + ~0, 其有很好的性质。当n为0时，flag也为0，而当n不为零时，flag统一为-1，这样使用flag代替原先的-1, 从而避免上述情况。</p></blockquote><blockquote><p>这样我们可以使用 mask = <del>(flag &lt;&lt; (32 + (</del>n + 1)))，来构造掩码，当n为0时，flag为0，从而mask = -1，避免上述错误。</p></blockquote><hr><h3 id="4-bitCount–比特计数"><a href="#4-bitCount–比特计数" class="headerlink" title="4. bitCount–比特计数"></a><strong>4. bitCount–比特计数</strong></h3><p><strong>题目：</strong></p><pre><code>返回二进制数中1的个数</code></pre><p><strong>样例：</strong></p><pre><code>bitCount(5) = 2, bitCount(7) = 3</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 40</p><p><strong>使用操作数：</strong> 36</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">int</span> tmp, l1, l2, l4, l8, l16; <span class="hljs-comment">//tmp is used to save ops</span>  tmp = (<span class="hljs-number">0x55</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x55</span>;  l1 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp; <span class="hljs-comment">//0x55555555</span>  tmp = (<span class="hljs-number">0x33</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x33</span>;  l2 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp; <span class="hljs-comment">//0x33333333</span>  tmp = (<span class="hljs-number">0x0f</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x0f</span>;  l4 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp; <span class="hljs-comment">//0x0f0f0f0f</span>  l8 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">16</span>) + <span class="hljs-number">0xff</span>; <span class="hljs-comment">//0x00ff00ff</span>  l16 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xff</span>; <span class="hljs-comment">//0x0000ffff</span>  x = (x &amp; l1) + ((x &gt;&gt; <span class="hljs-number">1</span>) &amp; l1);  x = (x &amp; l2) + ((x &gt;&gt; <span class="hljs-number">2</span>) &amp; l2);  x = (x &amp; l4) + ((x &gt;&gt; <span class="hljs-number">4</span>) &amp; l4);  x = (x &amp; l8) + ((x &gt;&gt; <span class="hljs-number">8</span>) &amp; l8);  x = (x &amp; l16) + ((x &gt;&gt; <span class="hljs-number">16</span>) &amp; l16);  <span class="hljs-keyword">return</span> x;&#125;</code></pre><p><strong>分析：</strong></p><ul><li>分治思想<blockquote><p>本题使用了一个简单的分治思想，对于一个二进制数，要对其中为1的位做计数， 对于1位二进制数来说，1的个数无非就是其本身所表示的1或0。利用这个特性，我们可以先将一个二进制数每一位独立分开为相间隔的两部分, 其每位表示的就是自身的二进制个数，再将两串二进制数对其相加，所得到的每两位分隔的二进制数就是表达这个位置的位为1的个数。</p></blockquote></li></ul><blockquote><p>进一步相加为4位，8位其所代表的含义不变，最后合并至32位二进制数，其所表示的就是原二进制数中所含1的个数。</p></blockquote><pre><code class="hljs cpp"><span class="hljs-comment">//以八位二进制数 10101110 为例//</span>按 <span class="hljs-number">1</span>|<span class="hljs-number">0</span>|<span class="hljs-number">1</span>|<span class="hljs-number">0</span>|<span class="hljs-number">1</span>|<span class="hljs-number">1</span>|<span class="hljs-number">1</span>|<span class="hljs-number">0</span> 分割， 为两串<span class="hljs-number">1</span>|<span class="hljs-number">1</span>|<span class="hljs-number">1</span>|<span class="hljs-number">1</span>和<span class="hljs-number">0</span>|<span class="hljs-number">0</span>|<span class="hljs-number">1</span>|<span class="hljs-number">0</span>，再将其合并，成为 <span class="hljs-number">01</span> | <span class="hljs-number">01</span> | <span class="hljs-number">10</span> | <span class="hljs-number">01</span>, 再将两串 <span class="hljs-number">01</span> | <span class="hljs-number">10</span> 和<span class="hljs-number">01</span> | <span class="hljs-number">01</span>合并得 <span class="hljs-number">0010</span> | <span class="hljs-number">0011</span>（这个很容易看出表示左四位有<span class="hljs-number">2</span>个<span class="hljs-number">1</span>，右四位有<span class="hljs-number">3</span>个<span class="hljs-number">1</span>），再次合并得 <span class="hljs-number">00000101</span>, 得到总共有<span class="hljs-number">5</span>个<span class="hljs-number">1</span>。<span class="hljs-comment">//对于32位二进制数亦按此继续操作即可//</span></code></pre><blockquote><p>于是为完成分割取位的操作，我们需要采用掩码</p></blockquote><ul><li>0x55555555 \ 0x33333333 \ 0x0f0f0f0f \ 0x0000ffff</li></ul><blockquote><p>利用位运算分别构造，使用tmp可以节约ops, 之后按照分治思想进行操作即可。</p></blockquote><hr><h3 id="5-bang–逻辑非"><a href="#5-bang–逻辑非" class="headerlink" title="5. bang–逻辑非"></a><strong>5. bang–逻辑非</strong></h3><p><strong>题目：</strong></p><pre><code>计算 !x 而不使用逻辑非!</code></pre><p><strong>样例：</strong></p><pre><code>bang(3) = 0, bang(0) = 1</code></pre><p><strong>可使用操作：</strong> ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 12</p><p><strong>使用操作数：</strong> 6</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bang</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">return</span> ((x &gt;&gt; <span class="hljs-number">31</span>) | ((~x + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">31</span>)) + <span class="hljs-number">1</span>;&#125;</code></pre><p><strong>分析：</strong></p><ul><li>逻辑非<blockquote><p>对于逻辑非运算，应该都很熟悉，!x 当且仅当x为0时其为1，其余时候都为0，可以用来区分零和非零数。</p></blockquote></li></ul><blockquote><p>该问题的关键就是在于如何区分零和非零数，我们知道零的二补码仍然是零，而对于其余非零数，其符号位会有相应改变，利用这一性质，我们可以对零和非零数做出区分。</p></blockquote><blockquote><p>使用 <code>((x &gt;&gt; 31) | ((~x + 1) &gt;&gt; 31))</code>，将二进制数x的符号位与其补码左移31位相与，如若是非零数，其中符号位至少有一个为1，所以经过31位的算数右移后，其中一项必为-1，一项为0，相与之后得到-1,。而对于0来说，结果始终为0。</p></blockquote><blockquote><p>最后只要将结果+1，就能得到逻辑非的效果。</p></blockquote><hr><h3 id="6-tmin–最小数"><a href="#6-tmin–最小数" class="headerlink" title="6. tmin–最小数"></a><strong>6. tmin–最小数</strong></h3><p><strong>题目：</strong></p><pre><code>返回二补码中最小的数</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 4</p><p><strong>使用操作数：</strong> 1</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tmin</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>此题非常简单，我们知道计算机中负数是用其补码表示的，int所能表示的最小数为0x80000000(-2^31), 即符号位为1，其余皆为0，所以只要将1左移31位即可。</p></blockquote><hr><h3 id="7-fitsBits–填充比特"><a href="#7-fitsBits–填充比特" class="headerlink" title="7. fitsBits–填充比特"></a><strong>7. fitsBits–填充比特</strong></h3><p><strong>题目：</strong></p><pre><code>返回1如果x可以表示为n位二补码，反之返回0 (1 &lt;= n &lt;= 32)</code></pre><p><strong>样例：</strong></p><pre><code>fitsBits(5,3) = 0, fitsBits(-4,3) = 1</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 15</p><p><strong>使用操作数：</strong> 7</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fitsBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">int</span> k = x &gt;&gt; (n + ~<span class="hljs-number">0</span>); <span class="hljs-comment">// if can k = 0 or -1</span>  <span class="hljs-keyword">return</span> !k | !(k + <span class="hljs-number">1</span>);&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>我们知道如若一个数能够被n位二进制数表示，则其第n位即最高位是符号位，那么将其右移n-1位后，根据算术右移，其得到的结果不是0，就是1。否则表示，其还有高于n位的位数， 即不能用n位表示。</p></blockquote><blockquote><p>所以用 k = x &gt;&gt; (n + ~0) 表示将其右移n-1位，再用 !k | !(k + 1) 判断k是否为0或-1</p></blockquote><hr><h3 id="8-divpwr2–除以2的n次方"><a href="#8-divpwr2–除以2的n次方" class="headerlink" title="8. divpwr2–除以2的n次方"></a><strong>8. divpwr2–除以2的n次方</strong></h3><p><strong>题目：</strong></p><pre><code>计算 x/(2^n), (0 &lt;= n &lt;= 30)</code></pre><p><strong>样例：</strong></p><pre><code>divpwr2(15,1) = 7, divpwr2(-33,4) = -2</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 15</p><p><strong>使用操作数：</strong> 7</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divpwr2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> sign = x &gt;&gt; <span class="hljs-number">31</span>;    <span class="hljs-keyword">int</span> bias = (<span class="hljs-number">1</span> &lt;&lt; n) + ~<span class="hljs-number">0</span>;    x = x + (bias &amp; sign);    <span class="hljs-keyword">return</span> x &gt;&gt; n;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>本题的难点在于Round toward zero, 我们知道除以2的n次方即为将x右移n位。对于正数，尾数截断，因而自然向0舍入。而对于负数则不是如此，经试验在gcc上对于负数，其是向偶数舍入的，因而我们要对负数进行操作。</p></blockquote><blockquote><p>同时由于其向偶数舍入，我们不能简单地对负数进行+1操作，例如原本正确的 -7/4 = -1.25 = -1，但是经过+1操作后变为-6/4 = -1.5 Round toward even则变为了2。所以我们不应简单加一，而是加一个偏差值，其为2^n - 1，对于-7/4来说，就是3，加上bias之后得到(-7 + 3)/4即为-1。</p></blockquote><blockquote><p>所以我们构造bias = (1 &lt;&lt; n) + <del>0 (由于不能用减号，-1用+</del>0表示)，然后我们要记得将sign取出，在x进行加操作时先检查一下x是否是负数，再进行操作。最后只要方向的将x右移n位即可。</p></blockquote><hr><h3 id="9-negate–取负"><a href="#9-negate–取负" class="headerlink" title="9. negate–取负"></a><strong>9. negate–取负</strong></h3><p><strong>题目：</strong></p><pre><code>返回-x</code></pre><p><strong>样例：</strong></p><pre><code>negate(1) = -1.</code></pre><p><strong>可使用操作：</strong>  ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 5</p><p><strong>使用操作数：</strong> 2</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">negate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">return</span> ~x + <span class="hljs-number">1</span>;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>很简单，对于有符号二进制数取负就是取其补码，而补码等于其取反加一，返回取反加一即可。</p></blockquote><hr><h3 id="10-isPositive–是正数"><a href="#10-isPositive–是正数" class="headerlink" title="10. isPositive–是正数"></a><strong>10. isPositive–是正数</strong></h3><p><strong>题目：</strong></p><pre><code>返回1如果x大于0，反之返回0</code></pre><p><strong>样例：</strong></p><pre><code>isPositive(-1) = 0.</code></pre><p><strong>可使用操作：</strong>  ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 8</p><p><strong>使用操作数：</strong> 5</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">return</span> !(x &gt;&gt; <span class="hljs-number">31</span>) &amp; !!x;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>这题关键在于把0剔除了，区分正负数就是区分其符号位，将x右移31位，负数得-1，正数为0，用一个逻辑非使正数为1，负数为0，然后再和!!x与一下就能剔除0</p></blockquote><ul><li>!!x 当 x == 0 时返回 0，不为 0 时返回 1</li></ul><hr><h3 id="11-isLessOrEqual–小于等于"><a href="#11-isLessOrEqual–小于等于" class="headerlink" title="11. isLessOrEqual–小于等于"></a><strong>11. isLessOrEqual–小于等于</strong></h3><p><strong>题目：</strong></p><pre><code>如果x小于等于y返回1，反之返回0</code></pre><p><strong>样例：</strong></p><pre><code>isLessOrEqual(4,5) = 1.</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 24</p><p><strong>使用操作数：</strong> 14</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;  <span class="hljs-keyword">int</span> res = y + (~x + <span class="hljs-number">1</span>); <span class="hljs-comment">// y - x</span>  <span class="hljs-keyword">int</span> xSign = x &gt;&gt; <span class="hljs-number">31</span>;  <span class="hljs-keyword">int</span> ySign = y &gt;&gt; <span class="hljs-number">31</span>;  <span class="hljs-keyword">int</span> dif = ~xSign + ySign;  <span class="hljs-keyword">return</span> (~(dif + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">31</span>) &amp; !(res &gt;&gt; <span class="hljs-number">31</span>)) | !dif;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>我在这里采取了作差的方法 res = y + (~x + 1)，即计算一下y-x，判断其是否非负，同时也要考虑溢出问题，即 x 为负数，y为正数，y-x后溢出为负。</p></blockquote><blockquote><p>我将x,y右移31位代表其符号，若负则为-1，若正为0。我同时构造了一个 dif 以表示x,y符号之间的关系。</p></blockquote><blockquote><p><strong>dif = ~xSign + ySign</strong></p></blockquote><ol><li> 当 x &lt; 0 &amp;&amp; y &lt; 0 时，dif = -1 </li><li> 当 x &lt; 0 &amp;&amp; y &gt; 0 时，dif = 0 </li><li> 当 x &gt; 0 &amp;&amp; y &lt; 0 时，dif = -2 </li><li> 当 x &gt; 0 &amp;&amp; y &lt; 0 时，dif = -1</li></ol><blockquote><p>将 x,y 符号之间的关系表达出来，把 dif 加一我们可以观察到当 x,y 同号时，dif为0，所以将其取反和 !(res &gt;&gt; 31) 相与，就可以表示同号不溢出的情况，而当 x &lt; 0, y &gt; 0 的情况发生时，我们注意到 dif 就是 0 ，所以我们直接或上 !dif 即可表达这种情况。</p></blockquote><hr><h3 id="12-ilog2–以2为底的对数"><a href="#12-ilog2–以2为底的对数" class="headerlink" title="12. ilog2–以2为底的对数"></a><strong>12. ilog2–以2为底的对数</strong></h3><p><strong>题目：</strong></p><pre><code>返回x取以2为底的对数并向下取整，输入的 x &gt; 0</code></pre><p><strong>样例：</strong></p><pre><code>ilog2(16) = 4</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 90</p><p><strong>使用操作数：</strong> 48</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ilog2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">int</span> tmp, l1, l2, l4, l8, l16;  x |= x &gt;&gt; <span class="hljs-number">1</span>;  x |= x &gt;&gt; <span class="hljs-number">2</span>;  x |= x &gt;&gt; <span class="hljs-number">4</span>;  x |= x &gt;&gt; <span class="hljs-number">8</span>;  x |= x &gt;&gt; <span class="hljs-number">16</span>;    tmp = (<span class="hljs-number">0x55</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x55</span>;  l1 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;  tmp = (<span class="hljs-number">0x33</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x33</span>;  l2 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;  tmp = (<span class="hljs-number">0x0f</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x0f</span>;  l4 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;  l8 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">16</span>) + <span class="hljs-number">0xff</span>;  l16 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xff</span>;  x = (x &amp; l1) + ((x &gt;&gt; <span class="hljs-number">1</span>) &amp; l1);  x = (x &amp; l2) + ((x &gt;&gt; <span class="hljs-number">2</span>) &amp; l2);  x = (x &amp; l4) + ((x &gt;&gt; <span class="hljs-number">4</span>) &amp; l4);  x = (x &amp; l8) + ((x &gt;&gt; <span class="hljs-number">8</span>) &amp; l8);  x = (x &amp; l16) + ((x &gt;&gt; <span class="hljs-number">16</span>) &amp; l16);  <span class="hljs-keyword">return</span> x + ~<span class="hljs-number">0</span>;</code></pre><p><strong>分析：</strong></p><blockquote><p>我们知道二进制数每位有其位权，所以对 x 取以2为底的对数就是指其为1的最高位的位权。为了获得最高位的位置，其实我们可以将其最高位往下全部变为1，再类似bitsCount数其中1的个数就行了。</p></blockquote><blockquote><p>我把 x 移位相与，保证最高位往下所有数字为1，再使用bitsCount就得到答案。</p></blockquote><blockquote><p>最后不要忘记减一</p></blockquote><hr><h3 id="13-float-neg–浮点数的负数"><a href="#13-float-neg–浮点数的负数" class="headerlink" title="13. float_neg–浮点数的负数"></a><strong>13. float_neg–浮点数的负数</strong></h3><p><strong>题目：</strong></p><pre><code>返回-f，当NaN时，返回参数f</code></pre><p><strong>可使用操作：</strong> 所有的整型操作，包括 ||, &amp;&amp;. 以及 if, while</p><p><strong>最大操作数限制：</strong> 10</p><p><strong>使用操作数：</strong> 5</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_neg</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;  <span class="hljs-keyword">unsigned</span> <span class="hljs-built_in">exp</span> = uf &amp; <span class="hljs-number">0x7f800000</span>;  <span class="hljs-keyword">unsigned</span> frac = uf &amp; <span class="hljs-number">0x007fffff</span>;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> == <span class="hljs-number">0x7f800000</span> &amp;&amp; frac)    <span class="hljs-keyword">return</span> uf;  <span class="hljs-keyword">return</span> uf ^= <span class="hljs-number">0x80000000</span>;&#125;</code></pre><p><strong>分析：</strong></p><ul><li>IEEE-float<blockquote><p>我们知道IEEE单精度浮点数，最高位为符号位，其后8位为阶码exp，后23位为尾数frac。其牺牲了精度来扩大了表达范围。</p></blockquote></li></ul><blockquote><p>而当 exp 全 1 时，如若frac非全零，则表示NaN。若全零，则表示无穷大/小。</p></blockquote><blockquote><p>这里我们只要将原数和符号位0x80000000异或一下，即可取负。不要忘记排除NaN的情况。</p></blockquote><hr><h3 id="14-float-i2f–int转float"><a href="#14-float-i2f–int转float" class="headerlink" title="14. float_i2f–int转float"></a><strong>14. float_i2f–int转float</strong></h3><p><strong>题目：</strong></p><pre><code>把int类型的数转换为float表示(比特形式)</code></pre><p><strong>可使用操作：</strong> 所有的整型操作，包括 ||, &amp;&amp;. 以及 if, while</p><p><strong>最大操作数限制：</strong> 30</p><p><strong>使用操作数：</strong> 30</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_i2f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">unsigned</span> frac, mask1, mask2, mask3, mask4, d;  <span class="hljs-keyword">int</span> high = <span class="hljs-number">0x80000000</span>;  <span class="hljs-keyword">unsigned</span> sign = x &amp; <span class="hljs-number">0x80000000</span>;  <span class="hljs-keyword">unsigned</span> <span class="hljs-built_in">exp</span> = <span class="hljs-number">127</span>;  <span class="hljs-keyword">int</span> count = <span class="hljs-number">32</span>, i;  <span class="hljs-keyword">if</span>(sign)    x = ~x + <span class="hljs-number">1</span>;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!x)    <span class="hljs-keyword">return</span> x;    frac = x;  <span class="hljs-keyword">for</span>(;high; high &gt;&gt;= <span class="hljs-number">1</span>)  &#123;    --count;    <span class="hljs-keyword">if</span>(high &amp; x)      <span class="hljs-keyword">break</span>;  &#125;  i = count - <span class="hljs-number">23</span>;  mask1 = ~(<span class="hljs-number">1</span> &lt;&lt; count); <span class="hljs-comment">// the highest 1</span>  mask2 = <span class="hljs-number">1</span> &lt;&lt; i; <span class="hljs-comment">//the lowest of remain frac;</span>  mask3 = mask2 &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// the highest of deserted bits </span>  mask4 = mask2 - <span class="hljs-number">1</span>; <span class="hljs-comment">// the deserted bits</span>  <span class="hljs-built_in">exp</span> += count;  frac &amp;= mask1;    <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)  &#123;    d = frac &amp; mask4; <span class="hljs-comment">// deserted bits</span>    <span class="hljs-keyword">if</span>(d &gt; mask3 | (d == mask3 &amp;&amp; frac &amp; mask2))    &#123;      frac += mask2;      <span class="hljs-keyword">if</span>(frac &gt; <span class="hljs-number">0x3fffffff</span>)      &#123;        frac = <span class="hljs-number">0</span>;        <span class="hljs-built_in">exp</span>++;      &#125;    &#125;    frac &gt;&gt;= i;  &#125;  <span class="hljs-keyword">else</span>    frac &lt;&lt;= -i;  <span class="hljs-keyword">return</span> sign | <span class="hljs-built_in">exp</span> &lt;&lt; <span class="hljs-number">23</span> | frac;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>我认为这题比较难，我做了很久很久….它难在浮点数向偶数舍入以及其操作数的限制。</p></blockquote><blockquote><p>我们知道由于浮点数表示范围比整型大，我们可以将整型转换为浮点数，但是相应的会有一些精度的丢失，因为尾数frac只有23位，而int有31位可用。</p></blockquote><blockquote><p>所以其关键在于int的位数，一开始先把该取出来的都用掩码取出来，把负数和零处理一下。之后我利用了一个循环先找出int的最高位在哪，利用count计数。</p></blockquote><blockquote><p>后面我采取了四个掩码，分别代表最高位的1，留下的尾数中的最低位，要舍去的位数的最高位，以及舍弃的位数的掩码。利用这四个掩码我们可以达到存frac时，将其向<strong>偶数舍入</strong>。</p></blockquote><blockquote><p>具体操作是，先取出丢弃的尾数，将其存放在d中，看其有没有超过0.5 (即 d 是否大于 mask3) 如果大于，直接frac++就行。而如果等于的话，还要看frac是否是奇数 (即frac &amp; mask2是否为1) 如果是，则要向偶数舍入,frac++。</p></blockquote><blockquote><p>加完frac之后还要注意<strong>溢出问题</strong>，如果溢出了，要将frac置0，然后把阶码 exp++，再按照之前输出来的尾数移动，将尾数对齐即可 （位数最高默认为1不存，因而把最高位隐去）。</p></blockquote><blockquote><p>最后把符号位，阶码位和尾数位拼接，得到最后的结果。</p></blockquote><hr><h3 id="15-float-twice–float-2"><a href="#15-float-twice–float-2" class="headerlink" title="15. float_twice–float * 2"></a>15. float_twice–float * 2</h3><p><strong>题目：</strong></p><pre><code>返回float * 2, 当参数是NaN时，返回参数</code></pre><p><strong>可使用操作：</strong> 所有的整型操作，包括 ||, &amp;&amp;. 以及 if, while</p><p><strong>最大操作数限制：</strong> 30</p><p><strong>使用操作数：</strong> 20</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_twice</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;  <span class="hljs-keyword">unsigned</span> sign = uf &amp; <span class="hljs-number">0x80000000</span>;  <span class="hljs-keyword">unsigned</span> <span class="hljs-built_in">exp</span> = uf &amp; <span class="hljs-number">0x7f800000</span>;  <span class="hljs-keyword">unsigned</span> frac = uf &amp; <span class="hljs-number">0x007fffff</span>;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> == <span class="hljs-number">0x7f800000</span>) <span class="hljs-comment">//NaN &amp; inf</span>    <span class="hljs-keyword">return</span> uf;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">exp</span> &amp;&amp; !frac) <span class="hljs-comment">// 0</span>    <span class="hljs-keyword">return</span> uf;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">exp</span> &amp;&amp; frac &lt;= <span class="hljs-number">0x3fffff</span>)  <span class="hljs-comment">// low</span>    frac *= <span class="hljs-number">2</span>;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">exp</span> &amp;&amp; frac &gt; <span class="hljs-number">0x3fffff</span>) <span class="hljs-comment">// high</span>  &#123;    <span class="hljs-built_in">exp</span> += <span class="hljs-number">0x00800000</span>;    frac = (frac * <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x7fffff</span>;  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-comment">// normal</span>    <span class="hljs-built_in">exp</span> += <span class="hljs-number">0x00800000</span>;  <span class="hljs-keyword">return</span> sign + <span class="hljs-built_in">exp</span> + frac;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>主要要分析的地方，在于当阶码exp为0时，是否在乘2之后进位。所以要考虑尾数是否大于0x3fffff，如果小于等于之，则直接尾数乘2就行，不会溢出，否则则exp要进位，同时尾数乘2之后要与上0x7fffff保证不溢出。</p></blockquote><blockquote><p>其他正常情况直接exp++就行，注意一下特殊情况;</p></blockquote><p><em>本题中测试集中有一个inf，也要直接返回参数uf</em></p><hr><h2 id="Bits-honor-c"><a href="#Bits-honor-c" class="headerlink" title="Bits_honor.c"></a><strong>Bits_honor.c</strong></h2><h3 id="1-bitReverse–比特翻转"><a href="#1-bitReverse–比特翻转" class="headerlink" title="1. bitReverse–比特翻转"></a><strong>1. bitReverse–比特翻转</strong></h3><p><strong>题目：</strong></p><pre><code>把32比特int的比特位翻转</code></pre><p><strong>样例：</strong></p><pre><code>bitReverse(0x80000004) = 0x20000001bitReverse(0x7FFFFFFF) = 0xFFFFFFFE</code></pre><p><strong>最大操作数限制：</strong> 40</p><p><strong>使用操作数：</strong> 40</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitReverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> tmp,l1, l2, l4, l8, l16;   tmp = (<span class="hljs-number">0x55</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x55</span>;   l1 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;   tmp = (<span class="hljs-number">0x33</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x33</span>;   l2 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;   tmp = (<span class="hljs-number">0x0f</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x0f</span>;   l4 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;   l8 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">16</span>) + <span class="hljs-number">0xff</span>;   l16 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xff</span>;   x = ((x &gt;&gt; <span class="hljs-number">16</span>) &amp; l16) | (x &lt;&lt; <span class="hljs-number">16</span>);   x = ((x &gt;&gt; <span class="hljs-number">8</span>) &amp; l8) | ((x &amp; l8) &lt;&lt; <span class="hljs-number">8</span>);   x = ((x &gt;&gt; <span class="hljs-number">4</span>) &amp; l4) | ((x &amp; l4) &lt;&lt; <span class="hljs-number">4</span>);   x = ((x &gt;&gt; <span class="hljs-number">2</span>) &amp; l2) | ((x &amp; l2) &lt;&lt; <span class="hljs-number">2</span>);   x = ((x &gt;&gt; <span class="hljs-number">1</span>) &amp; l1) | ((x &amp; l1) &lt;&lt; <span class="hljs-number">1</span>);   <span class="hljs-keyword">return</span> x;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>这题和 bitsCount 有异曲同工之妙，也是一个分治法，将32位二进制数一分为二，交换，再将内部各自再一分为二，交换，直至最底层2位二进制数互换位置，最后完成了将所有位数翻转的工作。</p></blockquote><blockquote><p>但值得注意的是，给出的是有符号的int，所以在右移交换位置时，会发生因为负数算术右移导致高位全是1的情况，致使在与的过程中高位全部变为1。这边只要将其移动后在和掩码相与就能解决这一问题。而对于低位，先与掩码相与再移动，可以省去取反得到高位掩码的操作数。再用tmp省一下操作数。</p></blockquote><blockquote><p>最后操作数正好卡在40</p></blockquote><hr><h3 id="2-mod3–取模3"><a href="#2-mod3–取模3" class="headerlink" title="2. mod3–取模3"></a><strong>2. mod3–取模3</strong></h3><p><strong>题目：</strong></p><pre><code>计算 x 取模 3，而不用%</code></pre><p><strong>样例：</strong></p><pre><code>mod3(100) = 1mod3(-100) = -1</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 90</p><p><strong>使用操作数：</strong> 24</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mod3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> mask = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xff</span>;   x = (x &gt;&gt; <span class="hljs-number">16</span>) + (x &amp; mask); <span class="hljs-comment">// sum base 4^8 digits (a &lt;= 0x1FFFE)</span>   x = (x &gt;&gt; <span class="hljs-number">8</span>) + (x &amp; <span class="hljs-number">0xff</span>); <span class="hljs-comment">// sum base 4^4 digits (a &lt;= 0x2FD)</span>   x = (x &gt;&gt; <span class="hljs-number">4</span>) + (x &amp; <span class="hljs-number">0xf</span>); <span class="hljs-comment">// sum base 4^2 digits (a &lt;= 0x3C)</span>   x = (x &gt;&gt; <span class="hljs-number">2</span>) + (x &amp; <span class="hljs-number">0x3</span>); <span class="hljs-comment">// sum base 4^1 digits (a &lt;= 0x1D)</span>   x = (x &gt;&gt; <span class="hljs-number">2</span>) + (x &amp; <span class="hljs-number">0x3</span>); <span class="hljs-comment">// sum base 4^1 digits (a &lt;= 0x9)</span>   x = (x &gt;&gt; <span class="hljs-number">2</span>) + (x &amp; <span class="hljs-number">0x3</span>); <span class="hljs-comment">// sum base 4^1 digits (a &lt;= 0x4)</span>   x = (((x + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">2</span>) + x) &amp; <span class="hljs-number">0x3</span>;   <span class="hljs-keyword">return</span> x;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>这题难度算是比较大的，我参考了一些资料最后才写出这个代码。其实这题也与bitsCount有着一定的联系。</p></blockquote><blockquote><p>对于解这题有一个根本的公式即 </p></blockquote><pre><code>a % m = ((b % m)(a/b) + (a % b)) % m其中b是进制数</code></pre><blockquote><p>我们知道，如果想要知道一个十进制的数能否被三整除，只要看它所有数位之和是否能被三整除就行了。其实这就是上述公式的特殊情况，由于10 mod 3 == 1 所以其就退化为</p></blockquote><pre><code>a mod m = (a/b + a % b) % m递归下来就是所有数位之和</code></pre><blockquote><p>而对于二进制的情况，我们可以将进制位b选为4，这样正好是两位二进制数，同时4 % 3 == 1，这样一来，对于二进制数中我们只需要统计所有两两数位(四进制)的和能否被三整除就行了。</p></blockquote><blockquote><p>而考虑到我们每做一次 a/b + a % b 统计数位和都减小了数的规模，这样只要做有限次就能够将数控制在&lt;=3的范围内。</p></blockquote><blockquote><p>对于a % 4，这是一个经典的trivial情况，我们只需要做 a &amp; 3，就能够轻松得到a % 4的值。而对于a/4，只需要做a &gt;&gt; 2即可。</p></blockquote><blockquote><p>对于二进制数我们不仅可以按两位两位的四进制数位和来数，也可以直接数其倍数(4^i)，从最大4^8开始统计，一步步减小x的值，最后将x做到&lt;= 3的范围</p></blockquote><blockquote><p>最后要判断x是否为3，如果为3的话则要置为0，我利用3数位全为1的特点，将其+1进位后，右移2位。如果为3，则得到的是1。将其再加上x，如若x是1或2，则还是不变，但如果是3，它又会进位到4，那么我们只要再与上0x3，则会得到0，即为想要的结果。</p></blockquote><hr><h3 id="3-float-f2i–float转int"><a href="#3-float-f2i–float转int" class="headerlink" title="3. float_f2i–float转int"></a><strong>3. float_f2i–float转int</strong></h3><p><strong>题目：</strong></p><pre><code>输入一个按二进制位储存的float（以unsigned表示），将其转为int输出。(NaN,inf，溢出直接返回参数)</code></pre><p><strong>可使用操作：</strong> 所有的整型操作，包括 ||, &amp;&amp;. 以及 if, while</p><p><strong>最大操作数限制：</strong> 30</p><p><strong>使用操作数：</strong> 17</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">float_f2i</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> sign, <span class="hljs-built_in">exp</span>, frac, res;   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> tmp;   <span class="hljs-keyword">if</span>(!uf)      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   sign = uf &amp; <span class="hljs-number">0x80000000</span>;   <span class="hljs-built_in">exp</span> = uf &amp; <span class="hljs-number">0x7f800000</span>;   frac = (uf &amp; <span class="hljs-number">0x007fffff</span>) | <span class="hljs-number">0x00800000</span>;   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> == <span class="hljs-number">0x7f800000</span>) <span class="hljs-comment">//NaN and inf</span>      <span class="hljs-keyword">return</span> <span class="hljs-number">0x80000000</span>u;   <span class="hljs-built_in">exp</span> &gt;&gt;= <span class="hljs-number">23</span>;   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> &lt; <span class="hljs-number">127</span>)      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">158</span>)      <span class="hljs-keyword">return</span> <span class="hljs-number">0x80000000</span>u;   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">150</span>)      tmp = frac &lt;&lt; (<span class="hljs-built_in">exp</span> - <span class="hljs-number">150</span>);   <span class="hljs-keyword">else</span>      tmp = frac &gt;&gt; (<span class="hljs-number">150</span> - <span class="hljs-built_in">exp</span>);         <span class="hljs-keyword">if</span>(sign)      res = ~tmp + <span class="hljs-number">1</span>;   <span class="hljs-keyword">else</span>      res = tmp;      <span class="hljs-keyword">return</span> res | sign;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>这题特殊情况比较多，把NaN和inf处理一下，然后注意一下溢出情况，即取出来的exp - bias &gt; 31，肯定超过2^31整型储存的最大值，直接返回0x80000000u，然后对于exp小于127的，其指数是负数，直接返回int值为0。对于在exp - bias 在 0 到 31 之间的，由于frac只有23位，所以要将注意一下讨论23的情况。</p></blockquote><blockquote><p>最后把取出来的符号位对一下，如果负数取反加一，正数直接等，最后再或上符号位，返回答案。</p></blockquote><hr><h2 id="结果截图"><a href="#结果截图" class="headerlink" title="结果截图"></a><strong>结果截图</strong></h2><h3 id="bits-c"><a href="#bits-c" class="headerlink" title="bits.c"></a><strong>bits.c</strong></h3><p><img src="/CsBlog/CsBlog/2020/11/05/ICS_Lab1/ICS_Lab1/bits_btest.JPG" alt="bits_btest"></p><p><img src="/CsBlog/CsBlog/2020/11/05/ICS_Lab1/ICS_Lab1/bits_dlc.png" alt="bits_dlc"></p><h3 id="bits-honor-c"><a href="#bits-honor-c" class="headerlink" title="bits_honor.c"></a><strong>bits_honor.c</strong></h3><p><img src="/CsBlog/CsBlog/2020/11/05/ICS_Lab1/ICS_Lab1/bits_honor_btest.JPG" alt="bits_honor_btest"></p><p><img src="/CsBlog/CsBlog/2020/11/05/ICS_Lab1/ICS_Lab1/bits_honor_dlc.png" alt="bits_honor_dlc"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><p><a href="https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E5%8F%B3%E7%A7%BB/3711081?fr=aladdin">https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E5%8F%B3%E7%A7%BB/3711081?fr=aladdin</a><br><a href="https://blog.csdn.net/jiahonghao2002/article/details/108223366">https://blog.csdn.net/jiahonghao2002/article/details/108223366</a><br><a href="https://leetcode-cn.com/problems/reverse-bits/solution/dian-dao-er-jin-zhi-wei-by-leetcode/">https://leetcode-cn.com/problems/reverse-bits/solution/dian-dao-er-jin-zhi-wei-by-leetcode/</a><br><a href="http://homepage.cs.uiowa.edu/~jones/bcd/mod.shtml#exmod3">http://homepage.cs.uiowa.edu/~jones/bcd/mod.shtml#exmod3</a><br><a href="https://www.zhihu.com/question/38206659/answer/763034261">https://www.zhihu.com/question/38206659/answer/763034261</a><br><a href="https://blog.csdn.net/xindaxinda123/article/details/95617758">https://blog.csdn.net/xindaxinda123/article/details/95617758</a><br><a href="https://www.runoob.com/w3cnote/32-float-storage.html">https://www.runoob.com/w3cnote/32-float-storage.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bits</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/CsBlog/2020/11/05/hello-world/"/>
    <url>/CsBlog/2020/11/05/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="第一篇博客用以测试"><a href="#第一篇博客用以测试" class="headerlink" title="第一篇博客用以测试"></a>第一篇博客用以测试</h2><h3 id="一、-下面是一段C-代码"><a href="#一、-下面是一段C-代码" class="headerlink" title="一、 下面是一段C++代码"></a>一、 下面是一段C++代码</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Hello World!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre><h3 id="二、-下面是一段表格"><a href="#二、-下面是一段表格" class="headerlink" title="二、 下面是一段表格"></a>二、 下面是一段表格</h3><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">x</td></tr></tbody></table><h3 id="三、-下面是一段-Latex"><a href="#三、-下面是一段-Latex" class="headerlink" title="三、 下面是一段 Latex"></a>三、 下面是一段 Latex</h3><p>$$E= mc^2$$</p><h3 id="四、下面是一张图片"><a href="#四、下面是一张图片" class="headerlink" title="四、下面是一张图片"></a>四、下面是一张图片</h3><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRP-ciAYVH8UlH3ZaZC3NkN3ow9CrG36O5crg&usqp=CAU"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
