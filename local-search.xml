<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算理论基础笔记</title>
    <link href="/2021/07/05/Computation_Theory/note/"/>
    <url>/2021/07/05/Computation_Theory/note/</url>
    
    <content type="html"><![CDATA[<h1 id="计算理论基础"><a href="#计算理论基础" class="headerlink" title="计算理论基础"></a>计算理论基础</h1><h2 id="第一章-预备知识"><a href="#第一章-预备知识" class="headerlink" title="第一章 预备知识"></a>第一章 预备知识</h2><p>重点：</p><ul><li>符号表示，可能在问答题里面出现</li></ul><h3 id="1-1-定理及其证明方法"><a href="#1-1-定理及其证明方法" class="headerlink" title="1.1 定理及其证明方法"></a>1.1 定理及其证明方法</h3><ul><li>形式系统</li></ul><ol><li><strong>基本符号</strong> <em>（常量符号、变量符号、运算符等抽象字符）</em></li><li><strong>形成规则</strong> <em>(构造各种语言的方法规则)</em></li><li><strong>公理</strong> <em>（无需经过证明，正确性得到公认的语句）</em></li><li><strong>推理规则</strong> <em>（用于得到新的合法语句）</em></li></ol><ul><li><em>如何证明一个语句为真</em></li></ul><ol><li>每个语句或者是公理，或者由前面的语句自然导出</li><li>最后一个语句就是所要证明的语句</li></ol><ul><li><strong>定理证明方法</strong></li></ul><ol><li>演绎法</li><li>反证法/归谬法</li><li>归纳法、第二归纳法</li></ol><h3 id="1-2-集合及其基本运算"><a href="#1-2-集合及其基本运算" class="headerlink" title="1.2 集合及其基本运算"></a>1.2 集合及其基本运算</h3><ol><li>集合描述方法</li></ol><ul><li>列举法 $A={a,b,c,d}$</li><li>模式表示法 ${x|P(x)}$</li></ul><ol><li>集合运算及定理</li></ol><ul><li>定理1.9 德摩根定理</li></ul><p>$\quad \quad \bar{A \cap B} = \bar A \cup \bar B$<br>$\quad \quad \bar{A \cup B} = \bar A \cap \bar B$</p><h3 id="1-3-图和树简介"><a href="#1-3-图和树简介" class="headerlink" title="1.3 图和树简介"></a>1.3 图和树简介</h3><ul><li><strong>图</strong> ：顶点集合以及边集合</li><li>有向图、无向图</li><li>通路、回路</li><li><p>邻接矩阵</p></li><li><p><strong>树</strong> </p></li><li>树中每一个顶点到另一个顶点均有一条通路，称该顶点为树的根</li><li>树中一定没有回路</li><li>仅一个顶点(根节点)没有前导顶点</li><li>一定存在没有后继的顶点</li></ul><h3 id="1-4-字母表、字符串和语言"><a href="#1-4-字母表、字符串和语言" class="headerlink" title="1.4 字母表、字符串和语言"></a>1.4 字母表、字符串和语言</h3><ul><li>自然语言<br>— 人类彼此相互交流的工具，由基本符号构成，如日语俄语等</li><li><strong>形式语言</strong><br>— 用于需要严格描述的领域，构成基础为“符号”</li></ul><ul><li><strong>字符表</strong>是符号的集合，记为 $\Sigma$</li><li>$\Sigma$上的符号串<br>— $\Sigma$ 上的符号以任意顺序拼接起来构成<br>— 任何符号可以重复出现</li><li><strong>定义1.23</strong><br>— 对于任何给定的字符表$\Sigma$，$\Sigma$上的字符串集合称作$\Sigma$上的语言</li><li><strong>定义1.24</strong><br>— 设$L$是某个字母表上的一个语言，若 $L$ 中任何字符串都不是另一个字符串的真前缀，则$L$ 具有<strong>前缀性质</strong></li><li><strong>定义1.25</strong><br>— 设 $L<em>{1}$ 为 $\Sigma</em>{1}$ 的语言, $L<em>{2}$ 为 $\Sigma</em>{2}$ 的语言，则  $L<em>{1}$ 和 $L</em>{2}$ 的连接 $L<em>{1}L</em>{2} = {xy | x \in L<em>{1} and \ y \in L</em>{2}}$</li><li><strong>定义1.26</strong><br>— <strong>语言 $L$的闭包 $L^{*}$</strong><br>— 以任意次序连接L中任意多个字符串所组成的集合<br>— 只要 $L$ 中包含至少一个元素, $L^{*}$就为无穷集</li></ul><hr><h2 id="第二章-文法理论"><a href="#第二章-文法理论" class="headerlink" title="第二章 文法理论"></a>第二章 文法理论</h2><p>重点：</p><ul><li>⽂法分类（给定⼀个语⾔集合，判定是0123型⽂法，熟悉每个⽂法的判定⽅法）（最重要） </li><li>上下⽂有关⽂法上下⽂信息的获得,1’型⽂法如何转化为1型⽂法</li></ul><h3 id="2-1-文法定义"><a href="#2-1-文法定义" class="headerlink" title="2.1 文法定义"></a>2.1 文法定义</h3><ul><li>四元组 $G=(V,T,P,S)$</li></ul><ol><li>V是变元符有限集 Variables</li><li>T是终结符有限集 Termination</li><li>P是生成式有限集 (Production?)</li><li>S∈V，为文法G的开始符 Start</li></ol><h3 id="2-2-派生"><a href="#2-2-派生" class="headerlink" title="2.2 派生"></a>2.2 派生</h3><p><strong>直接派生</strong><br>若$\alpha = \alpha<em>{1} A \alpha</em>{2}, \ \gamma=\alpha<em>{1}\beta\alpha</em>{2}$，且$A\to\beta$为P中一个生成式，则 $\alpha \mathop{\Rightarrow}\limits_{G}^{}\gamma$<br>，称由$\alpha$直接派生出$\gamma$</p><p><strong>派生</strong><br>将 $\mathop{\Rightarrow}\limits<em>{G}^{}$ 扩充为 $\hat{\mathop{\Rightarrow}\limits</em>{G}^{}}$，则为派生</p><p>$\quad (\hat{\mathop{\Rightarrow}\limits_{}} 表示多步直接派生)$</p><h3 id="2-3-文法分类"><a href="#2-3-文法分类" class="headerlink" title="2.3 文法分类"></a>2.3 文法分类</h3><p><strong>1. 短语结构文法 PSG (0型文法)</strong></p><ul><li><strong>特点：</strong> 不加限制</li><li><strong>对应语言：</strong> 短语结构语言 PSL</li><li><strong>对应自动机：</strong> 图灵机 TM</li><li><strong>形式：</strong>$\alpha\to\beta,\ \alpha,\beta\in(V \cup T)^{*}$ 且 $\alpha\ne\epsilon$</li></ul><p><strong>2. 上下文有关文法 CSG (1型文法)</strong></p><ul><li><strong>特点：</strong> 每个终结符$\to$终结符，满足前者偏序后者 ($\leq$)</li><li><strong>对应语言：</strong> 上下文有关语言 CSL</li><li><strong>对应自动机:</strong> 线性有界自动机 LBA</li><li><strong>形式：</strong> $\forall \alpha\to\beta\in P$, 满足 $|\alpha|\leq |\beta|$ 并且 $\alpha,\beta\in(V \cup T)^{*}$ 且 $\alpha\ne\epsilon$</li></ul><p><strong>3. 上下文无关文法 CFG (2型文法)</strong></p><ul><li><strong>特点：</strong> 都有变元推出变元或终结符或者变元与终结符的连接</li><li><strong>对应语言：</strong> 上下文无关语言 CFL</li><li><strong>对应自动机：</strong> 下推自动机 PDA</li><li><strong>形式：</strong> 对所有P中生成式都有，$A\to\beta \quad \beta\in(V \cup T)^{*},\ A \in V$</li></ul><p><strong>4. 正规文法 RG (3型文法)</strong></p><ul><li><strong>特点 ：</strong> 变元推出终结符或推出终结符+变元</li><li><strong>对应语言：</strong> 正规语言 RL</li><li><strong>对应自动机：</strong> 有穷自动机 DFA</li><li><strong>形式：</strong> 对所有P中生成式都有，$A\to a\ 或\ A\to aB \quad a\in T \cup {\epsilon},\ A,B \in V$</li></ul><h3 id="2-4-文法等价"><a href="#2-4-文法等价" class="headerlink" title="2.4 文法等价"></a>2.4 文法等价</h3><p>对于两个文法 $G<em>{1}=(V</em>{1},\ T<em>1,\ P_1,\ S_1)$ 与 $G</em>{2}=(V_{2},\ T_2,\ P_2,\ S_2)$，若$L(G_1)=L(G_2)$，则文法等价</p><h3 id="2-5-1°型文法"><a href="#2-5-1°型文法" class="headerlink" title="2.5 1°型文法"></a>2.5 1°型文法</h3><ul><li><strong>特点：</strong> 看形式</li><li><strong>形式：</strong> 对文法 $G=(V,\ T,\ P,\ S)$，若P中每个生成式都有 $\alpha_1 A \alpha_2 \to \alpha_1 \beta \alpha_2$形式，$A \in V, \ \alpha_1,\alpha_2\in(V \cup T)^{*}$, $\beta \in {(V \cup T)}^{+}$ </li></ul><h4 id="1、-1型文法和1°型文法转换"><a href="#1、-1型文法和1°型文法转换" class="headerlink" title="1、 1型文法和1°型文法转换"></a>1、 1型文法和1°型文法转换</h4><ul><li><p>定理：对于任何1型文法G，一定存在一个$1^{°}$型文法G’,使得L(G)=L(G’) 反之亦然。</p></li><li><p>$\Rightarrow$<br>对于任何生成式 $\alpha_1 A \alpha_2 \to \alpha_1 \beta \alpha_2$,恒有 $|\alpha_1 A \alpha_2| \leq |\alpha_1 \beta \alpha_2|$<br>即$1^{°}$型文法一定是1型文法</p></li><li><p>$\Leftarrow$ </p></li><li><p>第一步：将G变为G’’</p><ul><li>这一步构造出生成式只有两种形式的G’’</li><li>其中$V^{‘’}=V \cup M, M={[a] | a\in T}$</li><li>$P^{‘’}=\overline{P} \cup { [a] \to a | a \in T }$</li></ul></li><li><p>第二步：G’’ 中生成式形式分类讨论</p><ul><li>（1） $A\to\beta$ (A∈V，或为新引入变元[a])，其已经是1°文法</li><li>（2）$A_1A_2…A_n\to B_1B_2…B_n,\quad (n\ge 2,\ m\ge n)$<ul><li>解决方法：引入一组新变元用于过渡</li><li><ol><li>$A_1A_2…A_n \to C_1A_2…A_n$ </li></ol></li><li><ol><li>$C_1A_2…A_n \to C_1C_2…A_n$ </li></ol></li><li><ol><li>$C<em>1C_2…C</em>{n-1}A_n \to C_1C_2…C_n$ </li></ol></li><li><ol><li>$C_1C_2…C_n \to B_1C_2…C_n$ </li></ol></li><li><ol><li>$B_1C_2…C_n \to B_1B_2…C_n$ </li></ol></li><li><ol><li>$B<em>1B_2…B</em>{n-1}C_n \to B_1B_2…B_n$</li></ol></li><li>完成 $A_1A_2…A_n\to B_1B_2…B_n$</li></ul></li></ul></li></ul><h3 id="2-6-上下文在文法中的体现"><a href="#2-6-上下文在文法中的体现" class="headerlink" title="2.6 上下文在文法中的体现"></a>2.6 上下文在文法中的体现</h3><h4 id="上下文有关文法（1型文法）的上下文"><a href="#上下文有关文法（1型文法）的上下文" class="headerlink" title="上下文有关文法（1型文法）的上下文"></a>上下文有关文法（1型文法）的上下文</h4><ul><li>可用1°型文法解释，$\alpha_1 A \alpha_2 \to \alpha_1 \beta \alpha_2$，其中$\alpha_1\ 和\ \alpha_2$ 是A的上下文，在该上下文语境中A可替换为β</li><li>在另外上下文语境中可替换为别的字符串，例如另有生成式 $\alpha<em>{1’} A \alpha</em>{2’} \to \alpha<em>{1’} \gamma \alpha</em>{2’}$</li></ul><h4 id="上下文无关文法（2型文法）的上下文"><a href="#上下文无关文法（2型文法）的上下文" class="headerlink" title="上下文无关文法（2型文法）的上下文"></a>上下文无关文法（2型文法）的上下文</h4><ul><li>$A\to \beta$ 变元A不管出现在任何地方都可替换为β，与上下文无关</li></ul><h3 id="2-7-语法分析树"><a href="#2-7-语法分析树" class="headerlink" title="2.7 语法分析树"></a>2.7 语法分析树</h3><ul><li>定义：//TODO</li></ul><h4 id="边缘"><a href="#边缘" class="headerlink" title="边缘"></a>边缘</h4><ul><li><p>对于派生树，其叶节点标记从左到右收集起来的字符串，称为该派生树的边缘</p></li><li><p><strong>相关定理：</strong> G为上下文无关文法，那么S可以派生出α当且仅当在G中存在一颗边缘为α的派生树<br>证明: //TODO</p></li></ul><h4 id="多义和固有多义"><a href="#多义和固有多义" class="headerlink" title="多义和固有多义"></a>多义和固有多义</h4><p>不重要 TODO</p><hr><h2 id="第三章-有穷自动机和正规表达式"><a href="#第三章-有穷自动机和正规表达式" class="headerlink" title="第三章 有穷自动机和正规表达式"></a>第三章 有穷自动机和正规表达式</h2><p>重点</p><ul><li>掌握⼏类⾃动机的特点（FM, NFM, 有空动作的FM），⼏种FM之间如何进⾏变换（等价性），例：如何进⾏ 空动作的消除（空闭包的转换） </li><li>掌握正则表达式和正规集，正规集和有穷⾃动机的关系（实际上在第四章） </li><li>了解摩尔机和米里机的定义和功能（⾮重点）</li></ul><h3 id="3-1-确定有穷自动机-DFA"><a href="#3-1-确定有穷自动机-DFA" class="headerlink" title="3.1 确定有穷自动机 DFA"></a>3.1 确定有穷自动机 DFA</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><ul><li>有穷自动机（FA or DFA）是一个五元组 $M=(Q,\ \Sigma, \delta,\ q_0, F)$<ul><li><ol><li>Q是有穷状态集</li></ol></li><li><ol><li>$\Sigma$是有穷的输入字符表</li></ol></li><li><ol><li>$\delta$是转移函数，将$Q\times \Sigma$映射到Q</li></ol></li><li><ol><li>$q_0\in Q$ 是初始状态</li></ol></li><li><ol><li>$F\subset Q 是终结状态$</li></ol></li></ul></li></ul><h4 id="2-扩充转移函数"><a href="#2-扩充转移函数" class="headerlink" title="2.扩充转移函数"></a>2.扩充转移函数</h4><p>对于 FA $M=(Q,\ \Sigma, \delta,\ q_0, F)$ 其扩充转移函数是 $\hat\delta$ 是$Q\times\Sigma^*$ 到 Q 的映射</p><ul><li><ol><li>$\hat{\delta}(q,\epsilon) = q$</li></ol></li><li><ol><li>$\hat\delta(q,wa)=\delta(\hat\delta(q,w),a)$</li></ol></li><li><p>递归定义<br>接受一个输入，然后进行状态转移，再接受下一个。输入一个串得到最后状态。</p></li></ul><h4 id="3-有穷自动机接受语言"><a href="#3-有穷自动机接受语言" class="headerlink" title="3.有穷自动机接受语言"></a>3.有穷自动机接受语言</h4><p>$L(M)={x| \delta(q_0,x)\in F}$<br>若 $\delta(q_0,x)=p\in F$，则称字符串x，被M接受，意义上来理解，就是输入x，M从q0转移到终结状态F</p><h3 id="3-2-非确定有穷自动机-NFA"><a href="#3-2-非确定有穷自动机-NFA" class="headerlink" title="3.2 非确定有穷自动机 NFA"></a>3.2 非确定有穷自动机 NFA</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h4><ul><li>非确定的有穷自动机（NFA）五元组 $G=(Q,\Sigma,\delta,q_0,F)$<ul><li><ol><li>Q是有穷状态集</li></ol></li><li><ol><li>$\Sigma$是有穷输入字符表</li></ol></li><li><ol><li>$\delta$是非确定的状态转移函数，$Q\times \Sigma$到$2^Q$上的映射</li></ol></li><li><ol><li>$q_0\in Q$ 是初始状态</li></ol></li><li><ol><li>$F \subset Q$是终结状态集</li></ol></li></ul></li></ul><h4 id="2-转移函数一般形式："><a href="#2-转移函数一般形式：" class="headerlink" title="2. 转移函数一般形式："></a>2. 转移函数一般形式：</h4><p>$\delta(q,a)={p_1,…..,p_k} \quad p_i\in Q$ 或者 $\delta(q,a)=\emptyset$</p><h4 id="3-扩充转移函数"><a href="#3-扩充转移函数" class="headerlink" title="3. 扩充转移函数"></a>3. 扩充转移函数</h4><p>类似有穷自动机定义，输入一个串，对每个字符进行状态转移，最后得出的最终状态<strong>集合</strong></p><h4 id="4-接受条件"><a href="#4-接受条件" class="headerlink" title="4. 接受条件"></a>4. 接受条件</h4><p>如果$\delta(q_0,\ x)\cap F$非空，则称字符串 $x$ 被 $M$ 接受</p><h3 id="3-3-NFA与DFA的等价性"><a href="#3-3-NFA与DFA的等价性" class="headerlink" title="3.3 NFA与DFA的等价性"></a>3.3 NFA与DFA的等价性</h3><ul><li>当给定某类中的一个有穷自动机，一定存在另一类中的一个有穷自动机，两者接受同样集合，则称二者等价。</li></ul><h4 id="1-NFA与DFA等价"><a href="#1-NFA与DFA等价" class="headerlink" title="1. NFA与DFA等价"></a>1. NFA与DFA等价</h4><ul><li>证明： 构造法 构造 DFA，其定义为<ul><li>对于Q’,其将NFA中Q的每一个子集作为Q’中的一个状态，若子集为${q_1,q_2,..,q_n}$，则Q’中状态记为$[q_1,q_2,..,q_n]$</li><li>对于$\delta^{‘}$，定义为<script type="math/tex">\delta^{'}([q_1,q_2,..,q_n],a) = p_1,p_2,..,p_n \\ iff \\ \delta(\{q_1,q_2,..,q_n\},a) = p_1,p_2,..,p_n</script></li></ul></li></ul><p>进一步证明 TODO</p><h4 id="2-NFA至DFA的转换"><a href="#2-NFA至DFA的转换" class="headerlink" title="2. NFA至DFA的转换"></a>2. NFA至DFA的转换</h4><p>构造方法，从NFA出发，并不需要直接一步写出Q的幂集，而是看NFA中存在哪些状态。<br>例题3.4</p><h4 id="3-具有-epsilon-动作的有穷自动机"><a href="#3-具有-epsilon-动作的有穷自动机" class="headerlink" title="3. 具有$\epsilon$动作的有穷自动机"></a>3. 具有$\epsilon$动作的有穷自动机</h4><p>在不接受输入符号，输入为$\epsilon$ 时能做转移动作<br>即转移函数$\delta$扩充至$Q\times (\Sigma \cup {\epsilon})$ 到 $2^Q$ 的映射</p><ul><li><p>$\epsilon -CLOSURE(q)$<br>直白的说，就是如果NFA只接受空动作能够到达的状态集合</p></li><li><p>定义</p><ul><li><ol><li>$q\in \epsilon -CLOSURE(q)$</li></ol></li><li><ol><li>递归，若$p\in \epsilon -CLOSURE(q)$，则$\delta(q, \epsilon)\in \epsilon -CLOSURE(q)$</li></ol></li><li>规定：$\epsilon -CLOSURE(P) = \mathop{\cup}\limits_{q\in P}\epsilon -CLOSURE(q)$</li></ul></li><li><p>扩充函数<br>非简单扩充，就是说 $\hat\delta(q,a) \neq \delta(q,a)$，因为空输入也可以转移状态，其他差不多</p></li><li><p>接受语言<br>$L(M)={w|\hat\delta(q_0,w) \cap F }$ 非空<br><em>增加空动作没有增加表达能力，即有空动作和没有空动作的NFA等价</em></p></li><li><p>空动作NFA与NFA等价<br>构造法，对具有空动作的NFA M构造 $M’=(Q’,\Sigma^{‘},\delta^{‘},q_0,F^{‘})$，</p></li></ul><p>$\hat \delta(q,a)$ 即 $\delta(\epsilon -CLOSURE(q), a)$</p><ul><li>$\delta^{‘}(q,a) = \hat\delta(q,a)$</li><li><script type="math/tex; mode=display">F^{'}=\left\{  \begin{array}{rcl}      F\cup \{q_0\} && {如果\epsilon-CLOSURE(q_0)\cap F非空}\\      F && {否则}  \end{array} \right.</script>证明对 |x| 进行归纳 TODO</li></ul><h3 id="3-4-正规表达式和正规集"><a href="#3-4-正规表达式和正规集" class="headerlink" title="3.4 正规表达式和正规集"></a>3.4 正规表达式和正规集</h3><ul><li>正规表达式递归定义<ul><li><ol><li>$\phi$是一个正规表达式，代表空集</li></ol></li><li><ol><li>$\epsilon$是一个正规表达式，代表集合${\epsilon}$</li></ol></li><li><ol><li>对于$\Sigma$中每个符号a，a是正规表达式，代表集合{a}</li></ol></li><li><ol><li>如果r和s是正规表达式，分别表示集合R和S，则(r+s),(rs)和(r<em>)是正规表达式，分别表示$R \cup S$、$RS$和$R^</em>$</li></ol></li></ul></li></ul><p>正规表达式代表的集合称为正规集</p><p><img src="/uploads/upload_e70fbfc8866d389b084873dd20ba2e72.png" style="height: 300px;"></p><ul><li><p>运算优先级<br>$* &gt; 连接 &gt; +$</p></li><li><p>对应自动机<br>有穷自动机 DFA<br>有穷自动机所能接受的集合类和正规表达式所能表示的集合类统称为正规集类</p></li><li><p>定理3.3 r为正规表达式，则有一个具有空动作的NFA接受L(r)<br>归纳法证明，归纳r的构造次数</p></li><li>基础：r构造次数为0，即r是$\epsilon$、$\phi$、$\Sigma$中某个元素a</li><li><p>归纳</p><ul><li>r = r1 + r2<br>归纳假设有 M1 接受 r1, M2 接受 r2<br>则构造一个M将两个M1,M2并起即可，形式说明TODO</li><li>r = r1r2<br>归纳假设有 M1 接受 r1, M2 接受 r2<br>则构造一个M先过M1再过M2即可，形式说明TODO</li><li>r = r1*<br>归纳假设有 M1 接受 r1,<br>则扩展一下M1，让其终结状态可以回到开始状态重复判断即可，形式说明TODO</li></ul></li><li><p>定理3.4 如果L被DFA接受，则L可用正规表达式表示<br>对各状态进行编号，记 $R<em>{ij}^k={x\mid \delta(q_i,x)=q_j，中间不经过编号大于k的状态 }$ ，有递推式 $R</em>{ij}^k=R<em>{ik}^{k-1}(R</em>{kk}^{k-1})^*R<em>{kj}^{k-1}\cup R</em>{ij}^{k-1}$  ，然后归纳证明 $R_{ij}^k$ 可用正规表达式表示</p></li></ul><h3 id="3-5-具有输出的有穷自动机"><a href="#3-5-具有输出的有穷自动机" class="headerlink" title="3.5 具有输出的有穷自动机"></a>3.5 具有输出的有穷自动机</h3><ol><li>摩尔机</li><li>米里机</li></ol><p>非重点</p><hr><h2 id="第四章-正规文法与正规集的性质-重要"><a href="#第四章-正规文法与正规集的性质-重要" class="headerlink" title="第四章 正规文法与正规集的性质(重要)"></a>第四章 正规文法与正规集的性质(重要)</h2><ul><li>缩胀定理（重点），反证法证明 </li><li>极⼩化的处理，掌握极⼩化的算法（过程）（明示了快背），如何优化有穷⾃动机 </li><li>⻨⻄尔-尼诺德定理，需要掌握 </li></ul><h3 id="4-1-正规文法与有穷自动机的关系"><a href="#4-1-正规文法与有穷自动机的关系" class="headerlink" title="4.1 正规文法与有穷自动机的关系"></a>4.1 正规文法与有穷自动机的关系</h3><ul><li><strong>Th4.1</strong><br>— 设 $L$ 被某个正规文法 $G$ 产生，则 $L$ 可被某个有穷自动机接受</li></ul><ul><li><strong>Th4.2</strong><br>— 设 $L$ 被某个DFA $M$ 接受， 则 $L$ 可被某个正规文法产生</li></ul><p>构造方法：</p><ul><li>$A\to aB$ 对应 $\delta(A,a)=B$</li><li>$A\to a$ 对应 $\delta(A,a)=f\in F$</li></ul><h3 id="4-2-正规集的缩胀定理"><a href="#4-2-正规集的缩胀定理" class="headerlink" title="4.2 正规集的缩胀定理"></a>4.2 正规集的缩胀定理</h3><ol><li><p><strong>有穷自动机表达能力有限</strong></p></li><li><p><strong>Th4.3 正规集的缩胀定理(pumping Lemma)：存在整数 $k \geq 0$ ，对于任意串 $x, y, z$ 这里 $xyz \in A$， 只要$|y| \ge k$ ，就可以将 $y$ 写成 $y=uvw, \quad v \ne \sigma$ ，并且对于任何 $i \ge 0$，都有 $xuv^{i}wz \in A$</strong></p></li></ol><ul><li><p>证明：定理的直观含义为：如果 $A$ 是正规集，那么当它的元素含有<strong>足够长</strong>的子串 $y$ 时（x与y的长短不重要）， $y$ 就一定包含一个非空的子串 $v$ （$u, w$ 的长短不重要），这个子串 $v$ 可以“膨胀”任意多次 （$i &gt; 0$），或者被“删除” （$i = 0$），而 $xuv^{i}wz$ 仍然属于 $A$</p></li><li><p>设 $k$ 是接受正规集 $A$ 的 $DFA$ 状态数，因为 $y$ 的长度大于或等于k， 则 $DFA$ 在扫视 $y$ 的过程中，必然出现重复的状态，串 $v$ 就是该状态相邻的两次出现过程中扫视过的子串。</p></li></ul><script type="math/tex; mode=display">\sigma(q_{1}, u)=p, \sigma(p, v)=p, \sigma(p, w)=q_2</script><p>其余的推理过程与例2.10的分析相同</p><ul><li><em>正规集的缩胀定理经常用来指明某些集合不是正规集，通常就是反证法，大家都懂的。</em></li></ul><h3 id="4-3-正规集的封闭性质与判定算法"><a href="#4-3-正规集的封闭性质与判定算法" class="headerlink" title="4.3 正规集的封闭性质与判定算法"></a>4.3 正规集的封闭性质与判定算法</h3><ul><li>在并、连接和闭包运算下是封闭的</li><li>在补运算下封闭，即若 $L$ 是正规集，且 $L\subseteq\Sigma^{<em>}$， 则 $\Sigma^{</em>}-L$ 也是正规的</li><li>在交运算下封闭</li><li>在商运算下封闭（暂且理解：两个正规集做商运算，其结果必然是正规集）</li></ul><ul><li><em>Th4.9</em><br>具有n个状态的有穷自动机具有如下性质：<ul><li>1)它接受的集合非空，当且仅当它接受一个长度小于n的字符串 </li><li>2）它接受的集合是无穷的，当且仅当它接受一个长度为1的字符串，这里 $n \leq l &lt; 2n$</li></ul></li><li><em>两个有穷自动机是否等价是可判定的</em></li></ul><h3 id="4-4-有穷自动机的最小化"><a href="#4-4-有穷自动机的最小化" class="headerlink" title="4.4 有穷自动机的最小化"></a>4.4 有穷自动机的最小化</h3><p><strong>一个减少状态数的思路：给定 $DFA \ =(Q, \Sigma, \delta, q_{0}, F)$，根据等价关系构造出一个 $DFA M/ \equiv$，该 $DFA$称为 $M$的商自动机</strong></p><ul><li><strong>判断两个状态等价：</strong> 对于 $p, q \in Q$， 若对于每个 $x \in \Sigma^{*}, \quad \delta(p, x) \in F$当且仅当 $\delta(q,x) \in F$， 就称 $p, q$ 等价，记作 $p \equiv q$</li></ul><p><strong>极小化算法过程：</strong><br>— <em>在 $DFA$ 的状态集上确定所有的状态对是否等价</em></p><ol><li>对所有状态对 ${p, q}  (p, q \in Q)$画一张表，开始时中每个格子均为空白（未做标记）</li><li>对一切 $p \in F, q \notin F$ 的 ${p, q}$，在相应格子上做标记（例如画一个X）</li><li>重复下述步骤，直到表中内容不再改变为止：如果对于某个 $a \in \Sigma$， 存在一个未被标记的状态对 ${p, q}$，使得 ${\delta(p,a),\delta(q,a)}$已做标记，则将 ${p, q}$ 做标记</li><li>完成1，2，3之后，所有未被标记的状态对都是等价的，即 $p \equiv q$</li></ol><h3 id="Myhill-Nerode-关系"><a href="#Myhill-Nerode-关系" class="headerlink" title="Myhill-Nerode 关系"></a>Myhill-Nerode 关系</h3><p><strong>判定方式</strong></p><ul><li><p>对某个集合$A \subset \Sigma^<em>,\quad$ R为$\Sigma^</em>$上的等价关系。若R满足</p><ul><li><ol><li>是右不变的</li></ol></li><li><ol><li>细分A</li></ol></li><li><ol><li>具有有穷指数</li></ol></li></ul></li><li><p>则称R为A的 Myhill-Nerode 关系</p></li></ul><h3 id="Myhill-Nerode-定理"><a href="#Myhill-Nerode-定理" class="headerlink" title="Myhill-Nerode 定理"></a>Myhill-Nerode 定理</h3><ul><li>A是一个正规集</li><li>$\Sigma^*上存在关于A的MN关系$</li><li>$R_A$具有有穷指数</li></ul><hr><h2 id="第五章-上下文无关文法与下推自动机"><a href="#第五章-上下文无关文法与下推自动机" class="headerlink" title="第五章 上下文无关文法与下推自动机"></a>第五章 上下文无关文法与下推自动机</h2><p>重点:</p><ul><li>了解化简（作业题） </li><li>⼀定要会两种范式（乔姆斯基范式&amp;葛雷巴赫范式） </li><li>构造下推⾃动机（作业题）</li></ul><h3 id="5-1-上下文无关文法的化简"><a href="#5-1-上下文无关文法的化简" class="headerlink" title="5.1 上下文无关文法的化简"></a>5.1 上下文无关文法的化简</h3><p>检验文法$G=(V, T, P, S)$中是否有无用符号 （变元或终结符），若有，则将其消除。</p><h4 id="无用符号"><a href="#无用符号" class="headerlink" title="无用符号"></a>无用符号</h4><ul><li>$X \in V \cup T$ 但X不出现在任何由S派生出的字符串中。</li><li><p>$X \in V$ 但X不能派生出任何终结符号串</p></li><li><p>Th5.1 不带无用符号的CFG可生成所有非空CFL</p><p>  化简思路</p><ul><li><ol><li>找到无用符号（一类二类）</li></ol></li><li><ol><li>删除无用符号</li></ol></li><li><ol><li>返回1继续检查，直到不产生无用符号为止</li></ol><p>PPT思路</p></li><li><ol><li>首先删除二类无用符号 </li></ol></li><li><ol><li>接着删除一类无用符号</li></ol></li><li><ol><li>返回1检查，直到不产生无用符号</li></ol></li></ul></li></ul><h4 id="epsilon-生成式"><a href="#epsilon-生成式" class="headerlink" title="$\epsilon$ -生成式"></a>$\epsilon$ -生成式</h4><p>形如 $A \to \epsilon$ 的生成式，如果 $\epsilon \in L(G)$ 那么不能删，其余都可以删除。</p><ul><li><p>可为零<br>如果在CFG中，A属于变元集合，如果有A派生出$\epsilon$则称A为可为零的。</p></li><li><p>Th5.3 可为零的可判定性<br>对于CFG中任意变元是否可为零是可判定的<br>判定思路：</p></li><li><ol><li>对$A \to \epsilon$ 即trivial的本来就可为零的，将A加入Z</li></ol></li><li><ol><li>对于一切生成式 B，有$B \to \alpha$ 如果 $\alpha \in V^+$在中所有变元均在Z中，将B加入Z</li></ol></li><li><ol><li>重复1，直至没有元素加入Z为止</li></ol></li></ul><p>Z 中元素均为可为零的元素</p><ul><li>Th5.2 不带无用符号且没有$\epsilon$-生成式的CFG可以生成所有不包含空串的CFL<br><strong>不会证 ；）</strong></li></ul><h4 id="单一生成式"><a href="#单一生成式" class="headerlink" title="单一生成式"></a>单一生成式</h4><p>形如 $A \to B$ （A、B皆为变元）的生成式</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>上面说的三个都可以消掉</p><h3 id="5-2-上下文无关文法的范式"><a href="#5-2-上下文无关文法的范式" class="headerlink" title="5.2 上下文无关文法的范式"></a>5.2 上下文无关文法的范式</h3><h4 id="乔姆斯基范式-Chomsky-（CNF定理）"><a href="#乔姆斯基范式-Chomsky-（CNF定理）" class="headerlink" title="乔姆斯基范式 Chomsky （CNF定理）"></a>乔姆斯基范式 Chomsky （CNF定理）</h4><p>任何不包含$\epsilon$的CFL，都可由生成式仅为 $A \to BC$ 或 $A \to a$ （A，B，C为变元，a为终结符）形式的文法产生<br>（化为乔姆斯基范式，例题5.3）<br>a</p><h4 id="格雷巴赫范式-Greibach-GNF定理"><a href="#格雷巴赫范式-Greibach-GNF定理" class="headerlink" title="格雷巴赫范式 Greibach (GNF定理)"></a>格雷巴赫范式 Greibach (GNF定理)</h4><p>任何不包含$\epsilon$的CFL，都可由生成式仅为$A \to a\alpha$ (a为终结符,$\alpha$ 为变元串，包含空串）形式的文法产生</p><p>//TODO</p><h3 id="5-3-下推自动机"><a href="#5-3-下推自动机" class="headerlink" title="5.3 下推自动机"></a>5.3 下推自动机</h3><p>下推自动机（简称PDA）是一个七元组 $M=(Q,\Sigma,\Gamma, \delta, q_0, Z_0, F)$</p><ul><li>Q是有穷状态集</li><li>$\Sigma$是有穷的输入字母表</li><li>$\Gamma$是有穷的栈符号表</li><li>$\delta$是转移函数，将$Q \times (\Sigma \cup {epsilon} \times \Gamma)$ 映射到$(Q\times \Gamma^*)$ 的有穷子集</li><li>$q_0 \in Q$ 是初始状态</li><li>$Z_0 \in \Gamma$ 是栈底符号</li><li>$F \subset Q$ 是终结状态集</li></ul><h4 id="转移函数"><a href="#转移函数" class="headerlink" title="转移函数"></a>转移函数</h4><p>三元组 $\delta(q,a,Z) = {(p_1,\gamma_1), (p_2, \gamma_2),…,(p_m, \gamma_m)}$ 其中 q, a 一个状态一个输入字符，Z为栈顶符号</p><p>状态由 $q \to p$，栈顶符号由 $Z \to \gamma$<br>转移动作不确定</p><ul><li>函数值有m种选择 （m可以为0）</li><li>读头不动也可以有函数值</li></ul><h4 id="瞬时描述"><a href="#瞬时描述" class="headerlink" title="瞬时描述"></a>瞬时描述</h4><p>$(q<em>0,w,Z_0) \mathop{\vdash}\limits</em>{M}^*\ (p, \epsilon, \gamma)$ 表示从状态 $(p, \gamma) \in \delta(q_o, w, Z_0)$，上一个字符为w，下一个字符为 $\epsilon$</p><p>即由一个瞬时描述 ID 转移到下一个 ID</p><h4 id="按终结方式接受"><a href="#按终结方式接受" class="headerlink" title="按终结方式接受"></a>按终结方式接受</h4><p>若M是一个PDA，集合$L(M)={w|(q<em>0,w,Z_0) \mathop{\vdash}\limits</em>{M}^*\ (p, \epsilon, \gamma)}$<br>则称M按终结状态方式接受的语言</p><ul><li>接受状态<br>还是由初始状态到接受状态，和栈中符号没什么关系，栈符号只影响状态转移<br><em>不过如果输入串未读完栈就变空，无法进行状态转移，则w不可能被接受。</em></li></ul><h4 id="按栈空方式接受"><a href="#按栈空方式接受" class="headerlink" title="按栈空方式接受"></a>按栈空方式接受</h4><ul><li>接受状态<br>顾名思义，读完之后栈空了就接受了，终结状态则不影响是否接受。</li></ul><p>构造PDA接受$0^n1^n$，例题5.5</p><ul><li>例题 5.6、5.7</li></ul><h3 id="5-4-下推自动机与上下文无关文法的关系"><a href="#5-4-下推自动机与上下文无关文法的关系" class="headerlink" title="5.4 下推自动机与上下文无关文法的关系"></a>5.4 下推自动机与上下文无关文法的关系</h3><ul><li>下推自动机接受的语言类是上下文无关文法 CFL (2型文法)</li></ul><hr><h2 id="第六章-上下文无关语言的性质"><a href="#第六章-上下文无关语言的性质" class="headerlink" title="第六章 上下文无关语言的性质"></a>第六章 上下文无关语言的性质</h2><p>重点</p><ul><li>缩胀定理/ogden定理（尤其考察后者）</li><li>考察给⼀个语⾔判断是否是上下⽂⽆关语⾔ 封闭属性 </li><li>成员资格判定问题（PPT）,CYK算法</li></ul><h3 id="6-1-CFL缩胀定理"><a href="#6-1-CFL缩胀定理" class="headerlink" title="6.1 CFL缩胀定理"></a>6.1 CFL缩胀定理</h3><p>回忆一下正规集缩胀定理<br>正规集中每个足够长的字符串，都包含一个短子串可扩张任意多次，所得字符串仍然属于该正规集</p><ul><li>CFL 缩胀定理<br>在CFL中，每个足够长的字符串，都包含两个相距不远的短子串，两个子串可以扩充任意多次，所得子串仍然属于CFL</li></ul><p><strong>形式描述：</strong><br>对于每个CFL，都存在正整数 $k \ge 0$ 使得对每个$z \in L$ 只要 $|z| \ge k$ 就可将z划分为5个子串，<br>满足以下三个条件</p><ol><li>对任何的$i \ge 0$ 都有$uv^iwx^iy \in L$</li><li>$|vx| \ge 1$</li><li>$|vwx| \le k$</li></ol><p>（其中 k = $b^{|V| + 1}$，其中b是生成式右侧符号数的最大值）<br>看计算理论导引P77，写的很清楚</p><h3 id="6-2-Ogden定理"><a href="#6-2-Ogden定理" class="headerlink" title="6.2 Ogden定理"></a>6.2 Ogden定理</h3><p><strong>形式描述：</strong><br>L为CFL，存在整数$k \ge 0$，使得对每个$z \in L$，并且在z中标出k个或多于k个特别符号，将z写成z=uvwxy，且满足</p><ol><li>v和x一起至少包含一个特别符号</li><li>vwx之多包含k个特别符号<br>则对任何$i \ge 0,\ uv^iwx^iy \in L$</li></ol><p>例题6.4 </p><h3 id="6-3-CFL封闭性质"><a href="#6-3-CFL封闭性质" class="headerlink" title="6.3 CFL封闭性质"></a>6.3 CFL封闭性质</h3><p>回忆一下RL的封闭性质，RL在以下运算下封闭</p><ul><li>交并补</li><li>连接</li><li>闭包</li><li>商</li></ul><p><strong>CFL在以下运算下封闭</strong></p><ul><li><p>并<br>对G1,G2，生成式的开始元S1，S2<br>构造 G3 $S \to S1 | S2$</p></li><li><p>连接<br>对G1,G2，生成式的开始元S1，S2<br>构造 G3 $S \to S1S2$</p></li><li><p>闭包<br>对G1,G2，生成式的开始元S1<br>构造 G3 $S \to S1S|\epsilon$</p></li></ul><p><strong>注意 CFL 在 <em>交</em> $\cap$ 和 <em>补</em> $\hat{ }$ 运算下不封闭</strong></p><ul><li><p>交<br>$L1= {a^ib^ic^j|i \ge 1, j \ge 1}$, $L2= {a^ib^jc^j|i \ge 1, j \ge 1}$<br>两者是CFL<br>但其交集$L1 \cap L2= {a^ib^ic^i|i \ge 1}$ 不是CFL，可由Pumping LEmma 证得</p></li><li><p>补运算<br>交运算，可化为补+并的形式，若补运算封闭，则由于并运算封闭，可证得交运算封闭，推出矛盾。</p></li></ul><h4 id="CFL和正规集的交是CFL"><a href="#CFL和正规集的交是CFL" class="headerlink" title="CFL和正规集的交是CFL"></a>CFL和正规集的交是CFL</h4><ul><li>定理6.6 若L是CFL，R是正规集，则$L\cap R$是CFL</li></ul><h3 id="6-4-CFL判定算法"><a href="#6-4-CFL判定算法" class="headerlink" title="6.4 CFL判定算法"></a>6.4 CFL判定算法</h3><h4 id="给出CFG-G-V-T-P-S-L-G-是否为空和是否有穷问题是可判定的"><a href="#给出CFG-G-V-T-P-S-L-G-是否为空和是否有穷问题是可判定的" class="headerlink" title="给出CFG G=(V, T, P, S), L(G)是否为空和是否有穷问题是可判定的"></a>给出CFG G=(V, T, P, S), L(G)是否为空和是否有穷问题是可判定的</h4><ul><li>L(G) 是否为空<ul><li>检验S是否能派生出终结符号串</li><li>若能，则L(G)非空；不能则为空</li></ul></li><li>L(G)是否有穷<ul><li>对G的Chomsky范式，以变元为顶点画出有向图</li><li>原问题 $\Leftrightarrow$ 该有向图是否有回路</li><li>即X的最长路径长度为l，则从X派生出的终结符号串长度不超过$2^l$ (归纳假设)</li></ul></li></ul><p>图论算法判定一个有向图是否有回路，所以L(G’)是否有穷，是可判定的</p><h3 id="6-5-成员资格问题"><a href="#6-5-成员资格问题" class="headerlink" title="6.5 成员资格问题"></a>6.5 成员资格问题</h3><p><strong>给定一个CFG G和一个终结符串x，问x是否属于L(G)</strong><br>暴力算法思想，对于G的Greibach范式文法，从S生成式推出右侧的第一个终结变元和x串的第一个符号比较，如果对应就把右侧第二个变元的推出式拿出重复上述操作，直到接受或拒绝为止，时间复杂度$O(m^n)$</p><h4 id="CYK算法"><a href="#CYK算法" class="headerlink" title="CYK算法"></a>CYK算法</h4><p>时间复杂度 $O({|x|}^3)$<br>倒着的树，看Vij表，懂的都懂<br>（区间DP）<br><img src="/uploads/upload_e2b3e93174f7cd571038ce381a21f95c.png" alt></p><hr><h2 id="第七章-图灵机"><a href="#第七章-图灵机" class="headerlink" title="第七章 图灵机"></a>第七章 图灵机</h2><p>重点</p><ul><li>构造语⾔的图灵机（会考的稍微复杂）</li><li>图灵机构造技术 其他类型的图灵机（多带的、⾮确定、双栈机） </li><li>枚举器，正则次序，对偶产生器</li></ul><h3 id="7-1-图灵机基本模型"><a href="#7-1-图灵机基本模型" class="headerlink" title="7.1 图灵机基本模型"></a>7.1 图灵机基本模型</h3><p>确定单带图灵机是一个9元组 $M=(Q,\Sigma,\Gamma,\vdash, \diamond,\delta,s,t,r)$</p><ul><li><ol><li>Q有穷状态集</li></ol></li><li><ol><li>$\Sigma$有穷输入字母表</li></ol></li><li><ol><li>$\Gamma$有穷的带字母表</li></ol></li><li><ol><li>$\vdash$ 左端标记</li></ol></li><li><ol><li>$\diamond$ 空白符号</li></ol></li><li><ol><li>$\delta$ 转移函数</li></ol></li><li><ol><li>$s \in Q$ 开始状态</li></ol></li><li><ol><li>$t \in Q$ 接受状态</li></ol></li><li><ol><li>$r \in Q$ 拒绝状态</li></ol></li></ul><p>L 表示读写头左移，R表示右移，对于左端标记，永远有$\delta(p,\vdash)=(q,\vdash,R)$</p><ul><li><p>递归可枚举集<br>TM M接受的语言，称为递归可枚举集</p></li><li><p>递归集<br>被完全 TM M 接受的语言，称为递归集</p></li><li><p>完全TM<br>对一切输入均能停机（达到接受或拒绝状态）</p></li></ul><p>例题做做做</p><h3 id="7-2-图灵机构造技术"><a href="#7-2-图灵机构造技术" class="headerlink" title="7.2 图灵机构造技术"></a>7.2 图灵机构造技术</h3><h4 id="有限控制器中的存储"><a href="#有限控制器中的存储" class="headerlink" title="有限控制器中的存储"></a>有限控制器中的存储</h4><ul><li>元组表示状态，将带上符号吸收到状态中</li></ul><h4 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h4><ul><li>将带上符号不断吸收到状态中，不断写下，达到整体移动的目的</li></ul><h4 id="多道技术"><a href="#多道技术" class="headerlink" title="多道技术"></a>多道技术</h4><ul><li>保存处理更复杂的数据，例如计算$n^2$</li></ul><h4 id="查讫符号"><a href="#查讫符号" class="headerlink" title="查讫符号"></a>查讫符号</h4><ul><li>即给带上符号打标记，利用到多道技术</li><li>常用于区分某个符号是否查过</li><li>例7.7 构造一个识别 $l={wcw|w \in {a,b}^+}$的 $TM$</li></ul><h4 id="子程序技术"><a href="#子程序技术" class="headerlink" title="子程序技术"></a>子程序技术</h4><ul><li>懂的都懂，大概不考<br>构造TM M实现乘法运算</li></ul><h3 id="7-3-图灵机的变型"><a href="#7-3-图灵机的变型" class="headerlink" title="7.3 图灵机的变型"></a>7.3 图灵机的变型</h3><h4 id="双向无限带"><a href="#双向无限带" class="headerlink" title="双向无限带"></a>双向无限带</h4><ul><li>将图灵机的单向无限延伸扩大到双向无限延伸<ul><li>无左端标记$\vdash$</li><li>其余符号和功能均与单向无限带TM相同</li></ul></li></ul><p>并没增加其表达能力，和单带相同</p><ul><li>可以构造一个双带单向无限图灵机，识别能力与双向无限图灵机相同（定理7.1）</li></ul><h4 id="多带"><a href="#多带" class="headerlink" title="多带"></a>多带</h4><ul><li>用一个控制器控制k条带，在每条带上有独立的读写头<br><strong>和多道技术的区别</strong><br>多道技术是一个控制器多个带，这个是多个控制器多个带。</li><li>给一些证明带来许多方便</li><li>并没增加其表达能力，和单带相同</li></ul><h4 id="非确定图灵机"><a href="#非确定图灵机" class="headerlink" title="非确定图灵机"></a>非确定图灵机</h4><p><strong>确定的图灵机 $\delta$ 是单值函数，非确定性图灵机增加非确定性动作，并未改变其识别能力</strong></p><ul><li>可以证明确定型图灵机与非确定型图灵机的等价性<br>定理7.3 若L被一个非确定的TM $M_1$ 接受，则L也被某个确定的TM $M_2$ 接受。</li></ul><h4 id="双栈机"><a href="#双栈机" class="headerlink" title="双栈机"></a>双栈机</h4><p>其是特殊的三带图灵机<br>一个带用于输入，只读不写<br>另外两个用来模拟栈</p><ul><li>读头右移，可写任意符号 （进栈）</li><li><p>读头左移，只能写空白符 （退栈）<br>读头指向为栈顶，左端标记右边那个为栈底</p></li><li><p>任意的单带图灵机能被双栈机给模拟<br>右移时，右栈弹栈，左栈压栈。反之类似</p></li></ul><p><strong>下推自动机是单栈机，所以其能力比图灵机小， 即$PDA &lt; TM$</strong><br><strong>图灵机是下推自动机的扩充，能接受其不能接受的语言</strong></p><h4 id="带字母最少的图灵机"><a href="#带字母最少的图灵机" class="headerlink" title="带字母最少的图灵机"></a>带字母最少的图灵机</h4><ul><li>限制带字母表上只有 $0,\ 1,\ \diamond$ 三个符号</li><li>和任何TM等价</li></ul><h4 id="作为枚举器的图灵机"><a href="#作为枚举器的图灵机" class="headerlink" title="作为枚举器的图灵机"></a>作为枚举器的图灵机</h4><ul><li>用一条带专门作为输出带，带上符号一旦写上就不改动，带头一直往右，永不回头。</li></ul><h4 id="枚举器和TM的等价"><a href="#枚举器和TM的等价" class="headerlink" title="枚举器和TM的等价"></a>枚举器和TM的等价</h4><ul><li>设对某个枚举器 $M_1,\ L=G(M_1)$, 则存在TM $M_2$ 使得 $L(M_2) = L$<ul><li>构造M2，M2比M1多一条输入带，比较M2的输入和M1产生的串，如果相等则接受，不相等则与M1产生的下一个串继续比较，这样进行。</li><li>因为M1产生的串都是M2能接受的，M1不能产生的串都是M2不能接受的（不停机）所以 L(M2)=G(M1)=L</li></ul></li></ul><h4 id="对偶产生器"><a href="#对偶产生器" class="headerlink" title="对偶产生器"></a>对偶产生器</h4><ul><li>一个过程，以i+j不减的顺序列出正整数对(i,j)</li></ul><h4 id="字母表-Sigma-上串的正则次序"><a href="#字母表-Sigma-上串的正则次序" class="headerlink" title="字母表 $\Sigma$ 上串的正则次序"></a>字母表 $\Sigma$ 上串的正则次序</h4><ul><li>先按长度排序</li><li>再按字典序</li></ul><h3 id="7-4-图灵机与0型文法的关系"><a href="#7-4-图灵机与0型文法的关系" class="headerlink" title="7.4 图灵机与0型文法的关系"></a>7.4 图灵机与0型文法的关系</h3><p>图灵机对应0型文法</p><hr><h2 id="第八章-不可判定性"><a href="#第八章-不可判定性" class="headerlink" title="第八章 不可判定性"></a>第八章 不可判定性</h2><p>重点</p><ul><li>递归集和递归可枚举集的属性 </li><li>两个不可判定问题（停机问题+成员资格问题） </li><li>通⽤图灵机的概念，图灵机的⼆进制编码 </li><li>Rice定理</li></ul><h3 id="8-1-递归集和递归可枚举集性质"><a href="#8-1-递归集和递归可枚举集性质" class="headerlink" title="8.1 递归集和递归可枚举集性质"></a>8.1 递归集和递归可枚举集性质</h3><h4 id="补集"><a href="#补集" class="headerlink" title="补集"></a><strong>补集</strong></h4><ul><li>一个递归集的补集仍然是递归集<br>因为完全TM<br>调换接受拒绝状态</li></ul><h4 id="并集"><a href="#并集" class="headerlink" title="并集"></a><strong>并集</strong></h4><ul><li>递归集的并是递归的，递归可枚举集的并是递归可枚举的<ul><li>对于递归集，其是由完全TM生成的语言集合那么对于输入串，可先经M1进行验证，若接受则接受，若不接受则进第二个M2，重复上述过程。 （这里的保证是因为他们是完全TM，可以停机）</li><li>对于递归可枚举集，构造非确定M3’,对输入分别在M1，和M2上验证，如果有一个接受则接受，可见M3‘的停机问题也是不可判定的，为一般TM。</li></ul></li></ul><h4 id="交集"><a href="#交集" class="headerlink" title="交集"></a><strong>交集</strong></h4><ul><li>递归集的交是递归的，递归可枚举集的交是递归可枚举的</li></ul><p>看ppt的图，应该很清楚</p><ul><li>若语言 L 和 L补 都是递归可枚举的，则L（和L补）是递归的</li></ul><h3 id="8-2-通用图灵机和两个不可判定问题"><a href="#8-2-通用图灵机和两个不可判定问题" class="headerlink" title="8.2 通用图灵机和两个不可判定问题"></a>8.2 通用图灵机和两个不可判定问题</h3><h4 id="通用图灵机"><a href="#通用图灵机" class="headerlink" title="通用图灵机"></a>通用图灵机</h4><p>模拟任何图灵机的图灵机，将某个TM作为通用图灵机的输入来看待</p><ul><li>需要对TM有统一的、合理的编码</li><li>在给定输入串上，模拟TM的动作</li><li>给定TM接受，则该TM接受这个TM和这个输入的二元组</li></ul><h4 id="图灵机编码"><a href="#图灵机编码" class="headerlink" title="图灵机编码"></a>图灵机编码</h4><p>M#w</p><h4 id="关于停机问题的不可判定性"><a href="#关于停机问题的不可判定性" class="headerlink" title="关于停机问题的不可判定性"></a>关于停机问题的不可判定性</h4><ul><li><p>没有一个算法在有限步之内能够判断一个TM M在给定的输入串x上是否能停机。</p><ul><li><ol><li>接受状态</li></ol></li><li><ol><li>拒绝状态</li></ol></li><li><ol><li>无限循环</li></ol></li></ul></li><li><p><strong>任意给定TM M对任意给定输入串x是否停机的问题是不可判定的</strong><br>自指悖论（类似<strong>罗素悖论</strong>的方法）</p></li></ul><p><strong>证明</strong></p><ul><li><strong>Step 1 TM编码</strong><ul><li>由于可对TM进行编码，所以任何TM可以表示为01串</li><li>而我们可以把任何零一串看作一个TM</li><li>在上述规定下，可按正则次序列出所有TM<br>$M<em>{\epsilon},\ M_0,\ M_1\ ,M</em>{00},\ M_{01}…$<br>显然真正的TM一定出现在此序列中至少一次</li></ul></li></ul><ul><li><p><strong>Step 2 二维表标记</strong></p><ul><li>考虑无穷维的二维表，其顶端遍历 ${0, 1}^*$ 的正则序列，左端遍历 TM，用H (Halt) 表示停机，用L (Loop) 表示不停机，在对应位置做上标记</li></ul></li><li><p><strong>Step 3 开始证明</strong></p><ul><li>假设存在完全TM K，以Mx#y为输入，能够判断Mx在y上是否能够停机。如果停机，则 K 接受 Mx#y；否则，拒绝</li><li>构造另一个TM N，其输入为 $x \in {0, 1}^*$ 其完成以下任务<ul><li>从x找到Mx，将Mx#x写到其带上</li><li>在 Mx#x 上模拟K的动作，如果K接受，则其就进入循环（不停机），如果K拒绝，他就接受。</li></ul></li><li>那么根据N的定义，如果N在x上停机，则代表K拒绝，则代表Mx在y上不停机。</li></ul></li><li><p><strong>Step 4 推出矛盾</strong></p><ul><li>因为N也是图灵机，假设其编码为y，在正则序列中出现为My，如果N在y上停机，则代表My在y上不停机，而My就是N，导致矛盾。矛盾起因是K的存在性<br>所以不存在这样的TM能够判断M在任何输入下是否停机，即停机问题是不可判定的</li></ul></li></ul><h4 id="成员资格问题的不可判定性"><a href="#成员资格问题的不可判定性" class="headerlink" title="成员资格问题的不可判定性"></a>成员资格问题的不可判定性</h4><ul><li><p><strong>对于任意给定 TM M 和输入串x，M是否接受x的问题是不可判定的</strong></p><ul><li><ol><li>存在完全的 TM K，它能对任意的M和x，判断x是否属于L(M)。若$x \in L(M)$，则K接受$M#x$；否则拒绝</li></ol></li><li><ol><li>构造N，使得如果x在M上达到接受或拒绝的停机状态，则N接受。可以看出N是判断M在x上是否停机的TM。</li></ol></li><li><ol><li>现在对M输入N#x，则N是否接受x等价于x在M上是否停机，而停机问题是不可判定的，所以成员资格问题也不可判定。</li></ol></li></ul></li></ul><h3 id="8-3-归约方法和Rice定理"><a href="#8-3-归约方法和Rice定理" class="headerlink" title="8.3 归约方法和Rice定理"></a>8.3 归约方法和Rice定理</h3><ul><li><strong>给定TM M其是否接受空串的问题是不可判定的</strong></li></ul><p>将HP的不可判定性导出问题B的不可判定性</p><ul><li>HP Halt Problem 停机问题</li><li>B 其他问题</li></ul><h4 id="Rice定理"><a href="#Rice定理" class="headerlink" title="Rice定理"></a>Rice定理</h4><ul><li><p>r.e.集合类的任何一个非平凡性质都是不可判定的</p></li><li><p><strong>Step 1 准备</strong> </p><ul><li>设 P 是 r.e. 集合类上的一个非平凡性质，不失一般性，假设空集不具有性质P，则因为P的非平凡性，必定存在一个集合A满足P，即P(A) = T设K是接受A的TM</li></ul></li><li><p><strong>Step 2 归约HP到集合 ${M|P(L(M)) = T}$</strong><br>  给定M#x, 构造TM M’，其按以下步骤进行</p><ul><li>对于TM的输入y，将其放在一个道上</li><li>将x写在另一个道上</li><li>在M上模拟x的动作</li><li>如果M在x上停机，则在K上模拟y的动作</li><li>如果K接受y，则M’接受y</li></ul></li><li><p><strong>Step 3 推出矛盾</strong></p><ul><li>显然，M和M’的停机问题相关联，如果停机有 M’ 和 K 接受一样的集合。</li><li>所以有 M 在 x 上停机，可推出，L(M’) = A，可推出 P(L(M’)) = T</li><li>反之则不停机，P(L(M’)) = F</li><li>这就得出了停机问题到该问题的归约，但停机问题不可判定，所以其非平凡性质也不可判定。</li></ul></li></ul><h3 id="8-4-关于CFL的不可判定问题"><a href="#8-4-关于CFL的不可判定问题" class="headerlink" title="8.4 关于CFL的不可判定问题"></a>8.4 关于CFL的不可判定问题</h3><h3 id="8-5-Post对应问题的不可判定性及其应用"><a href="#8-5-Post对应问题的不可判定性及其应用" class="headerlink" title="8.5 Post对应问题的不可判定性及其应用"></a>8.5 Post对应问题的不可判定性及其应用</h3><hr><h2 id="第九章-线性有界自动机和上下文有关语言"><a href="#第九章-线性有界自动机和上下文有关语言" class="headerlink" title="第九章 线性有界自动机和上下文有关语言"></a>第九章 线性有界自动机和上下文有关语言</h2><p>重点</p><ul><li>给定语⾔，构造LBA </li><li>LBA对停机问题的判定问题</li></ul><p>各种机器对应的不同⽂法，⽐如FA对应CFG，图灵机对应0型，PDA对应CFL</p><h3 id="9-1-线性有界自动机-LBA"><a href="#9-1-线性有界自动机-LBA" class="headerlink" title="9.1 线性有界自动机 LBA"></a>9.1 线性有界自动机 LBA</h3><ul><li>对TM的读写头范围加以限制</li><li>左右端都有标记</li><li>接收机和小于TM接受的集合类</li></ul><p>线性有界自动机 LBA 是9元组 $M=(Q,\ \Sigma, \Gamma, \vdash,\ \dashv, \delta,\ s,\ t,\ r)$</p><ul><li><ol><li>Q 有穷状态集</li></ol></li><li><ol><li>$\Sigma$ 有穷输入字母表</li></ol></li><li><ol><li>$\Gamma$ 有穷带上字母表</li></ol></li><li><ol><li>$\vdash$ 左端符号</li></ol></li><li><ol><li>$\dashv$ 右端符号</li></ol></li><li><ol><li>$\delta$ 状态转移函数</li></ol></li><li><ol><li>s 开始状态</li></ol></li><li><ol><li>t 接受状态</li></ol></li><li><ol><li>r 拒绝状态</li></ol></li></ul><p><strong><em>例题9.1</em></strong><br>思路：</p><ul><li><ol><li>查讫符号打标记后找到中心</li></ol></li><li><ol><li>对消</li></ol></li></ul><h3 id="9-2-LBA-和-CSL-的关系"><a href="#9-2-LBA-和-CSL-的关系" class="headerlink" title="9.2 LBA 和 CSL 的关系"></a>9.2 LBA 和 CSL 的关系</h3><ul><li>若L是CSL，则L可被某个LBA接受</li></ul><p>将S派生出来的各种字符串（在下道），与上道的w比较，若相等则接受</p><h3 id="9-3-CSL的性质及其和递归集的关系"><a href="#9-3-CSL的性质及其和递归集的关系" class="headerlink" title="9.3 CSL的性质及其和递归集的关系"></a>9.3 CSL的性质及其和递归集的关系</h3><h4 id="CSL封闭性"><a href="#CSL封闭性" class="headerlink" title="CSL封闭性"></a>CSL封闭性</h4><ul><li>并</li><li>连接</li><li>正闭包（因为CSL不包含 $\epsilon$，所以L1为CSL则其闭包 $L_1^*$ 不是CSL）</li><li>交运算</li></ul><h4 id="每个CSL都是递归的"><a href="#每个CSL都是递归的" class="headerlink" title="每个CSL都是递归的"></a>每个CSL都是递归的</h4><p>思路：<br>因为输入串长度有限，并且两端封闭，所以总的情况数是有限的为$k(n+2)l^n$ 种，那么用双带，一带正常执行，令一带计算执行步数，如果超出则说明进入循环，则拒绝。所以有CSL是递归的</p><h4 id="存在递归集，不是CSL"><a href="#存在递归集，不是CSL" class="headerlink" title="存在递归集，不是CSL"></a>存在递归集，不是CSL</h4><h3 id="9-4-语言类之间的关系"><a href="#9-4-语言类之间的关系" class="headerlink" title="9.4 语言类之间的关系"></a>9.4 语言类之间的关系</h3><ol><li>RL(3型文法RG)</li><li>DCFL</li><li>CFL(2型文法CFG)</li><li>CSL∪{ε}(1型文法CSG)</li><li>递归集</li><li>r.e.集（递归可枚举集）(0型文法PSG),如成员问题所对应的字符串</li><li>非r.e.集，如FIN</li></ol><hr><h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><p>重点</p><ul><li>给定语⾔：判断是P还是NP</li><li>P与NP的封闭性证明 常⻅的NPC问题的推导和证明(重点)<ul><li>证NP问题</li><li>证归约性 </li></ul></li><li>P NP NPC NPHARD的概念 </li><li>PSPACE==NPSPACE-NPSPACEhard </li><li>L-NL（构造：利⽤指针） </li><li>后⾯的层次定理&amp;布尔电路不考</li></ul><h3 id="层次概览"><a href="#层次概览" class="headerlink" title="层次概览"></a>层次概览</h3><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_81564f07be5cb20ec62f5761169626dc.png" alt></p><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_aeeccf9bef7be94af30f6875bdf5d5e1.png" alt></p><script type="math/tex; mode=display">L \subset NL = coNL \subset P \subset NP \subset PSPACE = NPSPACE \subset EXPTIME</script><h3 id="P类"><a href="#P类" class="headerlink" title="P类"></a>P类</h3><ul><li>定义： P是确定型单带图灵机在多项式时间内可判定的语言类</li></ul><script type="math/tex; mode=display">P = \mathop\cup\limits_{k} TIME(n^k)</script><h4 id="PATH-in-P"><a href="#PATH-in-P" class="headerlink" title="PATH $\in$ P"></a><strong>PATH $\in$ P</strong></h4><p>PATH 问题，即G（有向图）中两点判定是否存在有向路径<br>用BFS算法，O(m)<br>或者dijkstra算法</p><h4 id="RELPRIME-in-P"><a href="#RELPRIME-in-P" class="headerlink" title="RELPRIME $\in$ P"></a><strong>RELPRIME $\in$ P</strong></h4><p>RELPRIME 问题，即判定两数互素<br>辗转相除法（欧几里得算法）</p><h4 id="每个CFL都是P"><a href="#每个CFL都是P" class="headerlink" title="每个CFL都是P"></a><strong>每个CFL都是P</strong></h4><p>CYK 复杂度$O(n^3)$</p><h3 id="NP类"><a href="#NP类" class="headerlink" title="NP类"></a>NP类</h3><h4 id="引理：NP是具有多项式时间验证机的语言"><a href="#引理：NP是具有多项式时间验证机的语言" class="headerlink" title="引理：NP是具有多项式时间验证机的语言"></a><strong>引理：NP是具有多项式时间验证机的语言</strong></h4><ul><li>用于验证该问题的额外信息称为证书<ul><li>HAMPATH 中两点之间的哈密顿路径</li><li>COMPOSITES 中 x 一个不等于1的因子</li></ul></li></ul><h4 id="一个语言在NP中，当且仅当其能够被某个非确定型多项式时间图灵机判定"><a href="#一个语言在NP中，当且仅当其能够被某个非确定型多项式时间图灵机判定" class="headerlink" title="一个语言在NP中，当且仅当其能够被某个非确定型多项式时间图灵机判定"></a><strong>一个语言在NP中，当且仅当其能够被某个非确定型多项式时间图灵机判定</strong></h4><h4 id="NTIME-t-n-L-L-是一个被O-t-n-时间的非确定型图灵机判定的语言"><a href="#NTIME-t-n-L-L-是一个被O-t-n-时间的非确定型图灵机判定的语言" class="headerlink" title="NTIME(t(n)) = {L| L 是一个被O(t(n))时间的非确定型图灵机判定的语言}"></a><strong>NTIME(t(n)) = {L| L 是一个被O(t(n))时间的非确定型图灵机判定的语言}</strong></h4><script type="math/tex; mode=display">NP = \cup_k NTIME(n^k)</script><h4 id="CLIQUE-in-NP"><a href="#CLIQUE-in-NP" class="headerlink" title="CLIQUE $\in$ NP"></a><strong>CLIQUE $\in$ NP</strong></h4><p>CLIQUE = {(G,k)| G是包含k团的无向图}</p><ul><li><p>验证机角度</p><pre><code>  证书：团，记为c  V为CLIQUE的验证机  V = 对输入((G,k), c)  1. 检查c是否是G中k个点的集合  2. 检查G是否包含连接c中节点的所有边  3. 若均通过则接受，否则拒绝</code></pre></li><li><p>非确定型TM角度</p><pre><code>  N = 对于输入(G,k)  1. 非确定的选择G中k个节点的子集c  2. 检查G是否包含连接c中节点的所有边  3. 若是则接受，否则拒绝</code></pre></li></ul><h4 id="SUBSET-SUM-in-NP"><a href="#SUBSET-SUM-in-NP" class="headerlink" title="SUBSET-SUM $\in$ NP"></a><strong>SUBSET-SUM $\in$ NP</strong></h4><p>SUBSET-SUM，给定集合s和t，判定是否有s的子集y，使得子集y中元素之和等于t</p><ul><li><p>验证机角度</p><pre><code>  证书：子集  V = 对输入((s,t),c)  1. 验证c中元素之和是否等于t  2. 验证s是否包含c中所有元素  3. 若均通过则接受，否则拒绝</code></pre></li><li><p>非确定型TM角度</p><pre><code>  N = 对于输入(s,t)  1. 非确定的选择s中的子集c  2. 验证c的元素之和是否等于t  3. 若是则接受，否则拒绝</code></pre></li><li><p>co-NP</p></li></ul><h3 id="P与NP问题"><a href="#P与NP问题" class="headerlink" title="P与NP问题"></a>P与NP问题</h3><ul><li>P = NP ?<script type="math/tex; mode=display">NP \subset EXPTIME = \mathop\cup\limits_{k} TIME(2^{n^k})</script></li></ul><h3 id="NP完全性"><a href="#NP完全性" class="headerlink" title="NP完全性"></a>NP完全性</h3><ul><li>定义<ul><li><ol><li>B属于NP（多项式时间内被非确定图灵机判定）</li></ol></li><li><ol><li>NP中每一个A都可在多项式时间内归约到B（归约，重要步骤）</li></ol></li><li>则称B为NP完全问题</li></ul></li></ul><ul><li>证明P=NP的一类思路<ul><li>证明某个NPC $\in$ P</li></ul></li></ul><h4 id="库克-列文定理"><a href="#库克-列文定理" class="headerlink" title="库克-列文定理"></a><strong>库克-列文定理</strong></h4><p>SAT 问题，给定一个布尔公式$\phi$判断其是否可满足</p><script type="math/tex; mode=display">SAT \in P，当且仅当 P=NP</script><p>证明：</p><ul><li>第一步：非确定图灵机可以在多项式时间内猜测变量的赋值，然后判断其是否可满足，因此 $SAT \subset NP$</li><li>第二步：<ul><li>假设从$NP$取出任意语言$A$，非确定$TM N$在$n^k-3$判定</li><li>考虑$N$对应的$n^k\times n^k$画面$\omega$</li><li>设计一个$\phi$,使得变量的一个满足赋值确实对应$N$在$\omega$上的接受画面</li><li>//todo</li></ul></li></ul><h4 id="SAT-in-NPC"><a href="#SAT-in-NPC" class="headerlink" title="SAT $\in$ NPC"></a><strong>SAT $\in$ NPC</strong></h4><p>为NP中的每一个语言A，构造一个到SAT的多项式时间归约<br>书P170~173</p><h4 id="3SAT-in-NPC"><a href="#3SAT-in-NPC" class="headerlink" title="3SAT $\in$ NPC"></a><strong>3SAT $\in$ NPC</strong></h4><h4 id="CLIQUE-in-NPC"><a href="#CLIQUE-in-NPC" class="headerlink" title="CLIQUE $\in$ NPC"></a><strong>CLIQUE $\in$ NPC</strong></h4><ul><li><strong>证明NPC</strong><ul><li>先证明NP</li><li>再证明某个已知NPC问题可在多项式时间内归约到他</li></ul></li></ul><h4 id="顶点覆盖问题-VERTEX-COVER"><a href="#顶点覆盖问题-VERTEX-COVER" class="headerlink" title="顶点覆盖问题 VERTEX-COVER"></a>顶点覆盖问题 VERTEX-COVER</h4><p>VERTEX-COVER 判定G是具有k个顶点的顶点覆盖的无向图<br>NP完全<br>3SAT 到 VERTEX-COVER 的归约<br>书P174</p><ul><li>证明思路：将一个$3nf$公式$\phi$转化成一个图$G$和数值$k$，只要能找到覆盖，$\phi$就被相应地满足</li></ul><h4 id="哈密顿路径问题-HAMPATH"><a href="#哈密顿路径问题-HAMPATH" class="headerlink" title="哈密顿路径问题 HAMPATH"></a>哈密顿路径问题 HAMPATH</h4><p>HAMPATH $\in$ NPC<br>3SAT 到 HAMPATH 的归约</p><p>书p175~177</p><h4 id="子集和问题-SUBSET-SUM"><a href="#子集和问题-SUBSET-SUM" class="headerlink" title="子集和问题 SUBSET-SUM"></a>子集和问题 SUBSET-SUM</h4><p>SUBSET-SUM $\in$ NPC<br>3SAT 到 SUBSET-SUM 的归约</p><p>书p178~180</p><hr><h3 id="萨维奇定理"><a href="#萨维奇定理" class="headerlink" title="萨维奇定理"></a>萨维奇定理</h3><p>任何消耗$f(n)$空间的非确定型TM都可以转变为仅消耗$f^2(n)$空间的确定型TM</p><script type="math/tex; mode=display">NSPACE(f(n)) \subset SPACE(f^2(n))</script><p>方法：利用中间格局递归二分<br>CANYIELD = 对于输入 c1，c2，t</p><ol><li>t=1 直接检查是否有c1 = c2 或根据N规则，检查c1是否能够一步只能产生c2，其中之一成立则接受，否则拒绝</li><li>若 t &gt; 1，则对于N在w上消耗空间f(n)的每一个格局cm</li><li>运行CANYIELD(c1, cm, t/2)</li><li>运行CANYIELD(cm, c2, t/2)</li><li>两个都接受则接受，否则拒绝</li></ol><p>对输入 $c<em>{start}$，$c</em>{accept}$，$2^{df(n)}$</p><p>递归深度$O(log2^{df(n)})$，所以总消耗空间$O(f^2(n))$</p><h3 id="PSPACE类"><a href="#PSPACE类" class="headerlink" title="PSPACE类"></a>PSPACE类</h3><p>PSPACE是在确定型图灵机上，在多项式空间内可判定的语言类</p><script type="math/tex; mode=display">PSPACE = \mathop\cup\limits_{k}SPACE(n^k)</script><ul><li>SAT $\in$ SPACE(n)</li><li>$ALL<em>{NFA} \in coNSPACE(n) \Rightarrow ALL</em>{NFA} \in SPACE(n^2)$</li><li><p>其都在PSPACE中</p></li><li><p>$P \subset PSPACE$<br>因为运行n步的程序，最多消耗n的空间</p></li><li><p>$NP \subset NPSPACE$<br>同理</p></li></ul><p>由于 NPSPACE = PSPACE<br>所以有 $NP \subset PSPACE$</p><h3 id="PSPACE完全性"><a href="#PSPACE完全性" class="headerlink" title="PSPACE完全性"></a>PSPACE完全性</h3><p>定义 若B是PSPACE-C则其满足以下两个条件</p><ul><li><ol><li>$B \in PSPACE$</li></ol></li><li><ol><li>PSPACE中每个语言A可多项式时间内归约到B</li></ol></li><li>只满足2类似NP难称其为PSPACE难的</li></ul><h4 id="TQBF问题"><a href="#TQBF问题" class="headerlink" title="TQBF问题"></a>TQBF问题</h4><p>判定$\phi$是真的全量词化布尔公式<br>其是PSPACE完全的</p><ul><li>先给出一个线性空间的复杂度算法，证明其属于PSPACE</li><li>再给出归约方式，类似萨维奇定理证明方法<br>书 P192</li></ul><h4 id="博弈必胜"><a href="#博弈必胜" class="headerlink" title="博弈必胜"></a>博弈必胜</h4><p>$FORMULA_GAME = {&lt;\phi&gt; | 在与\phi相关联的公式博弈中选手E有必胜策略}$<br>其是PSPACE完全的<br><strong>因为其等价于TQBF</strong></p><h4 id="广义地理学"><a href="#广义地理学" class="headerlink" title="广义地理学"></a>广义地理学</h4><p>$GG = {<G,b> | 在图G上以结点b起始的广义地理学游戏中，选手I有必胜策略}$<br>其是PSPACE完全的<br>证明方法类似TQBF的递归算法</G,b></p><h3 id="L和NL类"><a href="#L和NL类" class="headerlink" title="L和NL类"></a>L和NL类</h3><p>亚线性空间界限，类似工作主存上是亚线性空间，其余放在外存（只读）。</p><h4 id="L类"><a href="#L类" class="headerlink" title="L类"></a>L类</h4><ul><li>L是确定型图灵机在对数空间内可判定的语言类<script type="math/tex; mode=display">L=SPACE(logn)</script></li></ul><h4 id="NL类"><a href="#NL类" class="headerlink" title="NL类"></a>NL类</h4><ul><li><p>NL是非确定性图灵机在对数空间内可判定的语言类集合</p><script type="math/tex; mode=display">NL=NSPACE(logn)</script></li><li><p>例题 8.13<br>$A = {0^k1^k| k \ge 0} \in L$<br>在工作带上用二进制数0、1的数目，两个计数器消耗对数级别空间，所以$A \in L$</p></li><li><p>$PATH \in NL$<br>非确定的猜测从s到t的每一步，工作带上只记录每一步当前节点的位置，非确定的选择下一个节点，反复执行，直到到达t接受。或执行m步后拒绝，m是节点数。由此得到了PATH的被非确定型图灵机在亚线性空间内接受。</p></li></ul><h3 id="NL完全性"><a href="#NL完全性" class="headerlink" title="NL完全性"></a>NL完全性</h3><p>定义 若语言B是NL完全的，则其满足</p><ul><li><ol><li>$B \in NL$ </li></ol></li><li><ol><li>NL中的每个A<strong>对数空间</strong>内可归约到B</li></ol></li></ul><h4 id="PATH是NL完全的"><a href="#PATH是NL完全的" class="headerlink" title="PATH是NL完全的"></a>PATH是NL完全的</h4><p>证明方法，把输入字符串w对应为图，图中节点对应NTM在输入w上的一个格局。一个结点能指向另一个结点的调节时，其对应的格局能在NTM的一步内产生第二个结点对应的格局，因此，NTM对输入w是否接受就对应着初始格局到接受格局的PATH<br>更详细的对数空间归约证明情况书 p199~200</p><h4 id="NL-subset-P"><a href="#NL-subset-P" class="headerlink" title="$NL \subset P$"></a>$NL \subset P$</h4><ul><li><ol><li>因为PATH是NL完全的，所以NL中任何语言可对数空间内归约到PATH</li></ol></li><li><ol><li>由此，NL中任何语言也可对数时间内归约到PATH</li></ol></li><li><ol><li>因为多项式时间内归约到P中语言的语言本身也属于P</li></ol></li><li><ol><li>所以 $NL \in P$</li></ol></li></ul><h3 id="NL-coNL"><a href="#NL-coNL" class="headerlink" title="NL = coNL"></a>NL = coNL</h3>]]></content>
    
    
    <categories>
      
      <category>Computation Theory</category>
      
    </categories>
    
    
    <tags>
      
      <tag>P=NP?</tag>
      
      <tag>Computation Complexity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Malloc Lab 动态内存分配器</title>
    <link href="/2021/05/22/ICS/MallocLab/"/>
    <url>/2021/05/22/ICS/MallocLab/</url>
    
    <content type="html"><![CDATA[<h1 id="Malloc-Lab"><a href="#Malloc-Lab" class="headerlink" title="Malloc Lab"></a>Malloc Lab</h1><p>​    个人的实验报告，放上来给大家参考。</p><p>​    Malloc lab 需要我们编写一个类似 libc malloc 的动态内存分配器，其主要考察动态内存分配器的原理设计以及堆内存的结构组织，同时需要比较强的 DEBUG 能力。最后在不使用BST以及其他全局数据结构的情况下我的方法达到了 97/100 的分数</p><p><a href="https://github.com/ZiYang-xie/Malloc_Lab">ZiYang-xie/Malloc_Lab: CMU Malloc Lab Repo (github.com)</a></p><h2 id="一、空闲块组织结构"><a href="#一、空闲块组织结构" class="headerlink" title="一、空闲块组织结构"></a>一、空闲块组织结构</h2><p>​    在结构设计上我采用了分离存储的显示链表形式来进行组织空闲块，在书上说明了分离存储的思想，但没有具体说明实现方法。在此我使用称为 <strong>Segregated Free List</strong> 的空闲块组织设计，即在堆的低地址分配数量等于 <code>SEG_LEN</code> 的指针，每个指针分别对应着一个大小类，指向正式堆块中的空闲块，相当于 <code>SEG_LEN</code> 个链表。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gquqskpijgj30ff07cdg2.jpg" alt="Segregated Free List"></p><p>​    在我的代码设计中，我以2的幂次分割大小类，由于空闲块最小块大小为16 bytes （包括头尾标记以及前后指针）因此其设计为 {2^4 ~ 2^5} \ {2^5 ~ 2^6} \ {2^6 ~ 2^7} …(类推)</p><p> 为了区分某一空闲块应该被放置在哪个类中，我们需要一个 <strong>get_index</strong> 函数，正常设计也十分简单，即通过一个循环右移，计算位数。在这里我参考了 <strong>Bit twiddling hacks</strong> 著名位运算<em>奇技淫巧</em> 网站，采用了一个位运算的 log2 方式，其可以在 O(1) 的复杂度计算出 log2(x)</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_index</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> v)</span> </span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 本质上是位运算的 log 2, O(1)复杂度</span>    <span class="hljs-comment">// 参考 &#x27;Bit twiddling hacks&#x27;</span>    <span class="hljs-comment">// Linking: https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogLookup</span>        <span class="hljs-keyword">size_t</span> r, shift;    r = (v &gt; <span class="hljs-number">0xFFFF</span>)   &lt;&lt; <span class="hljs-number">4</span>; v &gt;&gt;= r;    shift = (v &gt; <span class="hljs-number">0xFF</span>) &lt;&lt; <span class="hljs-number">3</span>; v &gt;&gt;= shift; r |= shift;    shift = (v &gt; <span class="hljs-number">0xF</span>)  &lt;&lt; <span class="hljs-number">2</span>; v &gt;&gt;= shift; r |= shift;    shift = (v &gt; <span class="hljs-number">0x3</span>)  &lt;&lt; <span class="hljs-number">1</span>; v &gt;&gt;= shift; r |= shift;                                          r |= (v &gt;&gt; <span class="hljs-number">1</span>);    <span class="hljs-comment">// 从 2^4 开始 (空闲块最小 16 bytes)</span>    <span class="hljs-keyword">int</span> x = (<span class="hljs-keyword">int</span>)r - <span class="hljs-number">4</span>;    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>)         x = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(x &gt;= SEG_LEN)         x = SEG_LEN - <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> x;&#125;</code></pre><h2 id="二、堆内存设计"><a href="#二、堆内存设计" class="headerlink" title="二、堆内存设计"></a>二、堆内存设计</h2><p>​    在空闲块指针之上，分配正常的堆块，正常的堆块由<strong>序言块</strong> （一个已分配大小为8的块），以及<strong>结尾块</strong>（一个已分配大小为0的块）前后包围，这样可以很方便的检验边界情况，当后继块大小为0，那么便可判断其达到了结尾。之后便记录下全局的开始地址 <code>global_list_start_ptr</code> 即可</p><pre><code class="hljs c"><span class="hljs-comment">/* 空闲块 */</span><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; SEG_LEN; ++i)  PUT(heap_listp + i*WSIZE, <span class="hljs-literal">NULL</span>);            <span class="hljs-comment">// 初始化空闲块大小类头指针</span><span class="hljs-comment">/* 分配块 */</span>PUT(heap_listp + (i+<span class="hljs-number">0</span>)*WSIZE, PACK(DSIZE, ALLOCATED));  <span class="hljs-comment">/* 序言块头部 */</span>PUT(heap_listp + (i+<span class="hljs-number">1</span>)*WSIZE, PACK(DSIZE, ALLOCATED));  <span class="hljs-comment">/* 序言块尾部 */</span>PUT(heap_listp + (i+<span class="hljs-number">2</span>)*WSIZE, PACK(<span class="hljs-number">0</span>, ALLOCATED));      <span class="hljs-comment">/* 结尾块头部 */</span>global_list_start_ptr = heap_listp;heap_listp += (i+<span class="hljs-number">1</span>)*WSIZE; <span class="hljs-comment">// 对齐到起始块有效载荷</span></code></pre><h2 id="三、具体设计"><a href="#三、具体设计" class="headerlink" title="三、具体设计"></a>三、具体设计</h2><p>​    接下来以函数为单位详细介绍实现过程</p><pre><code>### mm_init 初始化堆</code></pre><p>​    堆内存设计块节中以及包含大部分，mm_init 代码，在组织完堆初始化的指针之后就可以进行分配栈空间以一个初始化的空闲块，这涉及到了 extend_heap 函数</p><pre><code class="hljs c"><span class="hljs-comment">/* 扩展空栈至 CHUNKSIZE bytes */</span>    <span class="hljs-keyword">if</span>(extend_heap(CHUNKSIZE) == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre><h3 id="extend-heap-堆扩展"><a href="#extend-heap-堆扩展" class="headerlink" title="extend_heap 堆扩展"></a>extend_heap 堆扩展</h3><p>​    对于堆扩展，我们调用 mm_sbrk 函数将lab中设计好的抽象 program breaker 上移扩展堆大小，其返回空闲块的头指针，我们设置好它的头尾标记，并通过 coalesce 函数在进行前后空闲块合并之后插入到空闲块链表中。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">extend_heap</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> asize)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">char</span> *bp;    <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>)(bp = mem_sbrk(asize)) == <span class="hljs-number">-1</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-comment">/* 初始化空闲块的头尾和结尾块的头部 */</span>    PUT(HDRP(bp), PACK(asize, FREE));                <span class="hljs-comment">/* 空闲块头部 */</span>    PUT(FTRP(bp), PACK(asize, FREE));                <span class="hljs-comment">/* 空闲块尾部 */</span>    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="hljs-number">0</span>, ALLOCATED));    <span class="hljs-comment">/* 结尾块头部 */</span>    <span class="hljs-keyword">return</span> coalesce(bp);&#125;</code></pre><h3 id="coalesce-合并块"><a href="#coalesce-合并块" class="headerlink" title="coalesce 合并块"></a>coalesce 合并块</h3><p>​    合并块的模式包含四种情况，并且在我的设计模式中，在合并后将空闲块插入到空闲链表中去，形成一体化操作。</p><ul><li><strong>Case1: 前后均不空闲</strong></li></ul><pre><code class="hljs c"><span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; next_alloc)&#123;                   <span class="hljs-comment">/* 前后非空闲 */</span>  insert_free_block(bp);  <span class="hljs-keyword">return</span> bp;&#125;</code></pre><p>前后均不空闲的时候就直接插入当前空闲块，并返回bp</p><ul><li><strong>Case2: 后空闲</strong></li></ul><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)&#123;             <span class="hljs-comment">/* 后空闲 */</span>  size += NEXT_BLKSZ(bp);  delete_free_block(NEXT_BLKP(bp));  PUT(HDRP(bp), PACK(size, FREE));  PUT(FTRP(bp), PACK(size, FREE));  PUT(PRED(bp), <span class="hljs-literal">NULL</span>);  PUT(SUCC(bp), <span class="hljs-literal">NULL</span>);&#125;</code></pre><p>​    后空闲的时候就从空闲链表中删除后方空闲块，并把当前块的头部和后部块的尾部大小设计为扩展后大小 <em>( 由于 FTRP 中调用了 HDRP，所以先设计HDRP的size之后FTRP能够正确定位到尾部 )</em> 并且设置空闲块前驱后继指针为NULL做好清理。</p><ul><li><strong>Case3:</strong> 前空闲</li></ul><pre><code class="hljs c"><span class="hljs-keyword">if</span>(!prev_alloc &amp;&amp; next_alloc) &#123;            <span class="hljs-comment">/* 前空闲 */</span>  size += PREV_BLKSZ(bp);  delete_free_block(PREV_BLKP(bp));  PUT(FTRP(bp), PACK(size, FREE));  PUT(HDRP(PREV_BLKP(bp)), PACK(size, FREE));  bp = PREV_BLKP(bp);  PUT(PRED(bp), <span class="hljs-literal">NULL</span>);  PUT(SUCC(bp), <span class="hljs-literal">NULL</span>);&#125;</code></pre><p>​    前空闲就从空闲链表中删除前方空闲块，并且注意分配的头部标记是前一块的头部标记，其余逻辑和 Case2类似</p><ul><li><strong>Case4:</strong> 前后均非空闲</li></ul><pre><code class="hljs c"><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 前后均空闲 */</span>  size += NEXT_BLKSZ(bp) + PREV_BLKSZ(bp);  delete_free_block(PREV_BLKP(bp));  delete_free_block(NEXT_BLKP(bp));  PUT(HDRP(PREV_BLKP(bp)), PACK(size, FREE));  PUT(FTRP(NEXT_BLKP(bp)), PACK(size, FREE));  bp = PREV_BLKP(bp);  PUT(PRED(bp), <span class="hljs-literal">NULL</span>);  PUT(SUCC(bp), <span class="hljs-literal">NULL</span>);&#125;</code></pre><p>​    前两种的结合，不多赘述</p><h3 id="insert-free-block-插入空闲链表"><a href="#insert-free-block-插入空闲链表" class="headerlink" title="insert_free_block 插入空闲链表"></a>insert_free_block 插入空闲链表</h3><p>​    插入空闲链表算是一个比较重要的函数，其关乎着空闲块的组织结构，在这里我采用的是<strong>地址排序</strong>的策略。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert_free_block</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *fbp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 地址排序 - Address Order</span>    <span class="hljs-keyword">void</span> *succ = root;        <span class="hljs-keyword">while</span>(SUCC_BLKP(succ))&#123;        succ = (<span class="hljs-keyword">char</span> *)SUCC_BLKP(succ);        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)succ &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)fbp)&#123;            <span class="hljs-comment">// 安装地址顺序插入空闲块</span>            <span class="hljs-comment">// PRED_BLKP(succ) &lt;-&gt; fbp &lt;-&gt; succ</span>            <span class="hljs-keyword">char</span> *tmp = succ;            succ = (<span class="hljs-keyword">char</span> *)PRED_BLKP(succ);            PUT(SUCC(succ), fbp);            PUT(PRED(fbp), succ);            PUT(SUCC(fbp), tmp);            PUT(PRED(tmp), fbp);            <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> INDEBUG</span>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;succ(PRE): %p \t tmp(SUCC): %p \t&quot;</span>, succ, tmp);                print_free_list(<span class="hljs-string">&quot;Insert&quot;</span>);            <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>            <span class="hljs-keyword">return</span>;        &#125;    &#125;        <span class="hljs-comment">// Base Case &amp; Last Case </span>    <span class="hljs-comment">// 当前大小类无空闲块 或者 在地址分配时当前空闲块地址最大被分配在最后</span>    PUT(SUCC(succ), fbp);    PUT(PRED(fbp), succ);    PUT(SUCC(fbp), <span class="hljs-literal">NULL</span>);&#125;</code></pre><p>​    首先获得目标块的 index，即属于二的几次幂，之后通过 <code>global_list_start_ptr</code> 加上 index 偏移定位到其属于的大小类链表的 root 指针，如果root指针有指向就进行地址顺序的排序，如果找到后部块地址大于插入块，就把该插入块插到上述块的前部。</p><p>​    如果root没有指向，即当前该大小类中没有空闲块，或者按地址序，该块地址大小最大则进行直接的分配在succ之后。</p><h3 id="delete-free-block-删除空闲块"><a href="#delete-free-block-删除空闲块" class="headerlink" title="delete_free_block 删除空闲块"></a>delete_free_block 删除空闲块</h3><p>​    删除空闲块要注意，这里常见的bug是和 insert_free_block 一同出现的指针维护不良，导致删除不存在的块，或者访问 nullptr 的前后继以及指针越界问题。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete_free_block</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *fbp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// NORMAL: GOT A SUCCESSOR AND PREDECESSOR</span>    <span class="hljs-keyword">if</span>(SUCC_BLKP(fbp) &amp;&amp; PRED_BLKP(fbp))&#123;        PUT(SUCC(PRED_BLKP(fbp)), SUCC_BLKP(fbp));        PUT(PRED(SUCC_BLKP(fbp)), PRED_BLKP(fbp));    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(PRED_BLKP(fbp))&#123; <span class="hljs-comment">// LAST BLOCK</span>        PUT(SUCC(PRED_BLKP(fbp)), <span class="hljs-literal">NULL</span>);    &#125;    PUT(SUCC(fbp), <span class="hljs-literal">NULL</span>);    PUT(PRED(fbp), <span class="hljs-literal">NULL</span>);&#125;</code></pre><p>​    正常情况是当前块是链表中间节点，重新连接好前后，把其从链表上脱离即可。如果是最后一个节点，就直接把前继节点的后继指针置为空。最后做好当前删除块的清理工作，把其前后继指针置为NULL</p><h3 id="mm-malloc-分配空闲块"><a href="#mm-malloc-分配空闲块" class="headerlink" title="mm_malloc 分配空闲块"></a>mm_malloc 分配空闲块</h3><p>​    mm_malloc 是该lab中的主要函数，用于控制分配内存块的工作。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mm_malloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">size_t</span> asize = align_size(size);    <span class="hljs-comment">/* 调整后的块大小 */</span>    <span class="hljs-keyword">size_t</span> extendsize;                  <span class="hljs-comment">/* 扩展堆大小 */</span>    <span class="hljs-keyword">char</span> *bp;    <span class="hljs-comment">/* Trivial Case */</span>    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">/* 寻找适配 */</span>    <span class="hljs-keyword">if</span>((bp = find_fit(asize, get_index(asize))) != <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> place(bp, asize);    <span class="hljs-comment">/* 未找到适配，分配更多堆空间 */</span>    extendsize = MAX(asize, CHUNKSIZE);    <span class="hljs-keyword">if</span>((bp = extend_heap(extendsize)) == <span class="hljs-literal">NULL</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    <span class="hljs-keyword">return</span> place(bp, asize);&#125;</code></pre><p>​    首先要做好分配大小的对齐，这里定义了一个util函数 align_size 用来对齐块大小。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">align_size</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">/* 调整块大小 */</span>    <span class="hljs-keyword">if</span>(size &lt;= DSIZE) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*DSIZE;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> DSIZE * ((size + (DSIZE) + (DSIZE - <span class="hljs-number">1</span>)) / DSIZE);    <span class="hljs-comment">// Code Never Went Here</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>​    之后逻辑就是通过 find_fit 在空闲链表中寻找适配，如果没找到适配就进行 heap_extend，每次最小扩展 <code>CHUNKSIZE</code> bytes，这里我将 <code>CHUNKSIZE</code> 设为 512</p><p> <strong>(有讲究，如果大于520就会导致realloc2的第一次分配 512 就能够成功，这样之后alloc的块就跟在512块后，就不能成功的将 realloc 的 0 号 block 安排在块位，导致无法通过 extend_heap 来提高性能)</strong></p><p>最后放置空闲块，使用place函数进行分配和分割</p><h3 id="find-fit-寻找适配"><a href="#find-fit-寻找适配" class="headerlink" title="find_fit 寻找适配"></a>find_fit 寻找适配</h3><p>​    我使用的是简单的首次适配，即从小到大遍历分离空闲链表，找到第一块适合的空闲块。由于每个空闲链表内部是按地址顺序排列而非大小排列，所以其效果并非严格等同于 best_fit 但是由于大小分块的组织结构，其效果又好于完全不按空间大小排序的适配方式。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">find_fit</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> seg_idx)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// First Fit</span>    <span class="hljs-keyword">char</span>* res;    <span class="hljs-keyword">while</span>(seg_idx &lt; SEG_LEN)&#123;        <span class="hljs-keyword">char</span> *root = global_list_start_ptr + seg_idx * WSIZE;        <span class="hljs-keyword">char</span> *bp = (<span class="hljs-keyword">char</span> *)SUCC_BLKP(root);        <span class="hljs-keyword">while</span>(bp)&#123;            <span class="hljs-keyword">if</span>((<span class="hljs-keyword">size_t</span>)CRT_BLKSZ(bp) &gt;= size)                <span class="hljs-keyword">return</span> bp;                        bp = (<span class="hljs-keyword">char</span> *)SUCC_BLKP(bp);        &#125;        <span class="hljs-comment">// 在这类中未找到适合，在更大类中寻找</span>        seg_idx++;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;</code></pre><h3 id="place-分配块"><a href="#place-分配块" class="headerlink" title="place 分配块"></a>place 分配块</h3><p>​    分配块这里有说法了，第一层是分配空闲块的时候，如果当前适配的块大小比需要分配的大很多（超出最小空闲块大小 16bytes）那么我们就可以通过分割来减小内部碎片。</p><p>​    并且这个分割也是很有讲究，我们可以设计当需要分配的空间较大时例如大于64 bytes，我们就将其分配在空闲块的后部，将前部分割出来作为新的空闲块。如果小于就直接分配在当前空闲块的前部，将后部分割出来作为新的空闲块。这样的组织方式有两方面好处，</p><ul><li>一方面是其进行了大小分类，有利于块的合并</li><li>另一方面是对于 realloc2 的测试 trace，我们通过前部切分的方式，使 512 块后再次分配的两 128 块占用前部空间，这样可以使 512 块始终是最后一块即其后继块是结尾块，那么在 realloc 它的时候我们就可以直接通过 extend_heap 达到如此一来可以大大提高内存利用率，<strong>将realloc1、2的util提升至近100%！</strong></li></ul><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">place</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *bp, <span class="hljs-keyword">size_t</span> asize)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">size_t</span> blk_size = CRT_BLKSZ(bp);    <span class="hljs-keyword">size_t</span> rm_size = blk_size - asize;    <span class="hljs-keyword">if</span>(!GET_ALLOC(HDRP(bp)))        delete_free_block(bp);    <span class="hljs-comment">// 剩余空间大于最小块大小的可分割的情况</span>    <span class="hljs-keyword">if</span>(rm_size &gt;= <span class="hljs-number">2</span>*DSIZE)&#123;        <span class="hljs-comment">// 当块大小大于 64 时将其有效载荷放在空闲块后部，前部切分出来作为空闲块</span>        <span class="hljs-keyword">if</span>(asize &gt; <span class="hljs-number">64</span>)&#123;            PUT(HDRP(bp), PACK(rm_size, FREE));            PUT(FTRP(bp), PACK(rm_size, FREE));            PUT(HDRP(NEXT_BLKP(bp)), PACK(asize, ALLOCATED));            PUT(FTRP(NEXT_BLKP(bp)), PACK(asize, ALLOCATED));            coalesce(bp);            <span class="hljs-keyword">return</span> NEXT_BLKP(bp);        &#125;        <span class="hljs-keyword">else</span>&#123;            PUT(HDRP(bp), PACK(asize, ALLOCATED));            PUT(FTRP(bp), PACK(asize, ALLOCATED));            PUT(HDRP(NEXT_BLKP(bp)), PACK(rm_size, FREE));            PUT(FTRP(NEXT_BLKP(bp)), PACK(rm_size, FREE));            coalesce(NEXT_BLKP(bp));        &#125;    &#125;    <span class="hljs-comment">// 不可分割情况</span>    <span class="hljs-keyword">else</span>&#123;        PUT(HDRP(bp), PACK(blk_size, ALLOCATED));        PUT(FTRP(bp), PACK(blk_size, ALLOCATED));    &#125;    <span class="hljs-keyword">return</span> bp;&#125;</code></pre><h3 id="mm-free-释放块"><a href="#mm-free-释放块" class="headerlink" title="mm_free 释放块"></a>mm_free 释放块</h3><p>​    直接设置空闲，并释放同时合并，没什么好说的</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mm_free</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DEBUG</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Freeing.....\n&quot;</span>);    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-keyword">char</span> *bp = ptr;    <span class="hljs-keyword">size_t</span> size = CRT_BLKSZ(bp);    PUT(HDRP(bp), PACK(size, FREE));    PUT(FTRP(bp), PACK(size, FREE));    coalesce(bp);&#125;</code></pre><h3 id="mm-realloc-重分配块"><a href="#mm-realloc-重分配块" class="headerlink" title="mm_realloc 重分配块"></a>mm_realloc 重分配块</h3><p>​    mm_realloc 能否做好是分数能否上 90 的关键，其主要策略有两个</p><ul><li><p><strong>空闲块融合</strong></p><p>一在重分配的时候，如果后方有空闲块可以进行融合，再看空间够不够，如果够了就不用释放再分配了。</p><p>（同时前融合也应当有相应的效果，前融合要注意内部载荷数据的移动，但其实观察 trace 文件下的block组织表现，发现其实前融合很少甚至没有，对性能影响不大，之后便在代码中删除了）</p></li><li><p><strong>尾部堆扩展</strong></p><p>就是之前提到的如果要重分配的块是尾部块就执行 extend_heap 就行了，不需要释放再分配。同时注意到了 trace 文件中反复 realloc 首次分配的块，于是和 place 中提到的策略相互结合可以达到将首次分配的块移动到末尾的效果。</p></li></ul><p>其余就是一些基础写法，在注释中已经体现，还有需要注意一下<strong>分配大小的对齐</strong>和特殊情况</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mm_realloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">size_t</span> size)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// 如果 ptr == NULL 直接分配</span>    <span class="hljs-keyword">if</span>(ptr == <span class="hljs-literal">NULL</span>)            <span class="hljs-keyword">return</span> mm_malloc(size);    <span class="hljs-comment">// 如果 size == 0 就释放</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)&#123;        mm_free(ptr);        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;    &#125;    <span class="hljs-keyword">size_t</span> asize = align_size(size), old_size = CRT_BLKSZ(ptr);    <span class="hljs-keyword">size_t</span> mv_size = MIN(asize, old_size);    <span class="hljs-keyword">char</span> *oldptr = ptr;    <span class="hljs-keyword">char</span> *newptr;    <span class="hljs-keyword">if</span>(old_size == asize)        <span class="hljs-keyword">return</span> ptr;        <span class="hljs-keyword">size_t</span> prev_alloc =  GET_ALLOC(FTRP(PREV_BLKP(ptr)));    <span class="hljs-keyword">size_t</span> next_alloc =  GET_ALLOC(HDRP(NEXT_BLKP(ptr)));    <span class="hljs-keyword">size_t</span> next_size = NEXT_BLKSZ(ptr);    <span class="hljs-keyword">char</span> *next_bp = NEXT_BLKP(ptr);    <span class="hljs-keyword">size_t</span> total_size = old_size;    <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; !next_alloc &amp;&amp; (old_size + next_size &gt;= asize))&#123;    <span class="hljs-comment">// 后空闲  </span>        total_size += next_size;        delete_free_block(next_bp);        PUT(HDRP(ptr), PACK(total_size, ALLOCATED));        PUT(FTRP(ptr), PACK(total_size, ALLOCATED));        place(ptr, total_size);    &#125;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!next_size &amp;&amp; asize &gt;= old_size)&#123;   <span class="hljs-comment">// 如果后部是结尾块，则直接 extend_heap</span>        <span class="hljs-keyword">size_t</span> extend_size = asize - old_size;        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>)(mem_sbrk(extend_size)) == <span class="hljs-number">-1</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;                 PUT(HDRP(ptr), PACK(total_size + extend_size, ALLOCATED));        PUT(FTRP(ptr), PACK(total_size + extend_size, ALLOCATED));        PUT(HDRP(NEXT_BLKP(ptr)), PACK(<span class="hljs-number">0</span>, ALLOCATED));         place(ptr, asize);    &#125;    <span class="hljs-keyword">else</span>&#123;   <span class="hljs-comment">// 直接分配</span>        newptr = mm_malloc(asize);        <span class="hljs-keyword">if</span>(newptr == <span class="hljs-literal">NULL</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        <span class="hljs-built_in">memcpy</span>(newptr, ptr, MIN(old_size, size));        mm_free(ptr);        <span class="hljs-keyword">return</span> newptr;    &#125;    <span class="hljs-keyword">return</span> ptr;&#125;</code></pre><h2 id="关于DEBUG"><a href="#关于DEBUG" class="headerlink" title="关于DEBUG"></a>关于DEBUG</h2><p>​    代码中为了 DEBUG 定义了大量 debug util 函数和 Error Handler，如果想清晰的看清楚堆块的组织结构，调用它们是很有帮助的。还有 debug 要善用 gdb…</p><h2 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqqcdfltwxj309s088aal.jpg" alt></p><p>​    在不使用BST和全局数据结构的情况下达到了 97/100 的分数，还不错。</p><h2 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h2><p>​    这个Lab用了我2、3天的时间，是比较难的，需要用心 DEBUG 考验 gdb的使用。Malloc Lab 还是很好玩的，ddl之后我可能会考虑进一步优化，采用BST结构尽量做到接近 100/100</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Malloc</tag>
      
      <tag>VM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 动态内存分配机制详解</title>
    <link href="/2021/05/21/ICS/Dynamic%20Memory%20Allocation/"/>
    <url>/2021/05/21/ICS/Dynamic%20Memory%20Allocation/</url>
    
    <content type="html"><![CDATA[<p>​    动态内存分配是虚拟内存组织中的核心概念，理解它对于帮助整个linux虚拟内存的组织以及堆上内存分配过程。本文会系统介绍动态内存的分配机制以及内存堆块的组织形式，并最后以 CMU CSAPP Malloc Lab 为例来详细讲解。</p><p><strong>Malloc Lab 代码：<a href="https://github.com/ZiYang-xie/Malloc_Lab">ZiYang-xie/Malloc_Lab: CMU Malloc Lab Repo (github.com)</a></strong> </p><p>在开始介绍 malloc 机制前，我们先看一下虚拟内存的组织形式。</p><h1 id="【序】虚拟内存组织形式"><a href="#【序】虚拟内存组织形式" class="headerlink" title="【序】虚拟内存组织形式"></a>【序】虚拟内存组织形式</h1><p>​    linux虚拟内存形式安装堆栈形式组织，栈位于内存高地址，分为内核栈和用户栈，增长方向从高到低。而堆位于内存的低地址，是程序员进行动态内存分配的空间，增长方向由低到高。堆和栈中间是共享映射空间，用于共享库在内存中的映射，这样每次如果有不同代码调用相同的共享库，就不需要再次向内存中复制一份副本，节省了时间和空间。</p><p>​    栈内存的更高地址用于存放一些全局数据结构</p><p>​    堆内存的更低地址按地址从低到高放置着代码段（.text）、已分配数据段（.data）、未分配数据段（.bss）。你可能还听说过 COMMON 段专门储存未初始化全局变量，真正的.bss存储未初始化的静态变量以及初始化为0的全局和静态变量 [1]，组织形式如下</p><pre><code class="hljs c">SECTIONS &#123;   .text : &#123; *(.text) &#125;  .data : &#123; *(.data) &#125;   .bss :  &#123; *(.bss)  *(COMMON) &#125; &#125;</code></pre><p>虚拟内存的大致组成形式如下图所示。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqr0n9olxfj30e80e0gn3.jpg" alt></p><p>​    可以看到代码段从 <em>0x40000000</em> 处开始，从0到0x40000000的内存地址单纯是未被映射，代码段和0地址之间相隔一段距离在早期是为了防止 nullptr 对代码段的修改<em>（此处仅凭记忆，真实性需要进一步验证</em>）。但如今权限设计更加完善，上述意义已不再成立，这就变成了一种约定俗成的规则。</p><p>在了解了虚拟内存的大致组织模式之后，我们便可以开始讲解 Malloc 的基本机制。</p><h1 id="【一】动态内存分配的实现方式"><a href="#【一】动态内存分配的实现方式" class="headerlink" title="【一】动态内存分配的实现方式"></a>【一】动态内存分配的实现方式</h1><p>​    Linux动态内存分配的实现方式是由 mmap, munmap 以及 brk, sbrk 这四个系统函数联合完成的。</p><h2 id="mmap-与-munmap"><a href="#mmap-与-munmap" class="headerlink" title="mmap 与 munmap"></a>mmap 与 munmap</h2><p><strong>mmap</strong></p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr, <span class="hljs-keyword">size_t</span> length, <span class="hljs-keyword">int</span> prot, <span class="hljs-keyword">int</span> flags,</span></span><span class="hljs-function"><span class="hljs-params">           <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> offset)</span></span>;</code></pre><p>mmap 创建一个新的虚拟内存空间和文件设备之间的映射。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqr27vczrhj30jd0a9tah.jpg" alt></p><p>​    其中 addr 代表分配开始地址，fd是相应文件描述符，len是指文件存储部分映射的长度，offset指的是从文件头开始offset距离开始分配。</p><ul><li>prot包含权限位</li></ul><pre><code class="hljs c">PROT_EXEC <span class="hljs-comment">// 可执行</span>PROT_READ <span class="hljs-comment">// 可读</span>PROT_WRITE <span class="hljs-comment">// 可写</span>PROT_NONE <span class="hljs-comment">// 不可访问</span></code></pre><ul><li>Flags 表示映射对象类型</li></ul><pre><code class="hljs c">MAP_ANON <span class="hljs-comment">// 匿名请求二进制零的</span>MAP_PRIVATE <span class="hljs-comment">// 私有的</span>MAP_SHARED <span class="hljs-comment">// 共享的</span></code></pre><p><strong>munmap</strong></p><p>取消相应地址内存块的映射</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">munmap</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr, <span class="hljs-keyword">size_t</span> length)</span></span>;</code></pre><p>很好理解取消开始地址为 addr 长度为 length 的内存映射。</p><h2 id="brk-与-sbrk"><a href="#brk-与-sbrk" class="headerlink" title="brk 与 sbrk"></a>brk 与 sbrk</h2><p>​    brk, sbrk 用来移动 program break 指向的指针来扩展堆内存，program break 位于堆顶未初始化数据段末尾之后，通过移动 program break 指针来动态控制堆的大小。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqri33m8lkj30ic0huq62.jpg" style="zoom:50%;"></p><p><strong>brk</strong></p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">brk</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr)</span></span>;</code></pre><p>​    brk 会在允许的情况下简单的将 program break 设为 addr 地址，来控制堆内存大小。相当于 program break 的绝对移动</p><p><strong>sbrk</strong></p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">sbrk</span><span class="hljs-params">(<span class="hljs-keyword">intptr_t</span> increment)</span></span>;</code></pre><p>​    sbrk 会在允许的情况下将 program break 指针加 increment 值，返回扩展前的 program break 地址。当<code>increment</code>为正值时，堆被扩展；为0时，返回当前 program break 的指针；为负值时，堆被收缩。相当于 program break 的相对移动</p><p>​    值得注意的是，当无法扩展时 (申请了大于允许的内存，或碰到了共享内存段)，sbrk会返回 (void <em>)-1 并且会设置 errorno 为 <em>*ENOMEM</em></em>（ENO Memory）</p><h3 id="关于-sbrk-的更多细节"><a href="#关于-sbrk-的更多细节" class="headerlink" title="关于 sbrk 的更多细节"></a>关于 sbrk 的更多细节</h3><p>​    sbrk 实际上是 linux 的一个上古函数，如今大多数内存分配器都倾向于使用 mmap 而不使用 sbrk，是因为 sbrk 是线程不安全的。由于 sbrk 的组织形式是对 program break 的相对移动来进行对扩展，那么对堆块的组织释放方式只能使用 LIFO。假设 sbrk 函数是原子的，在多进程调用时，如果一个进程要释放一个块，且其正好位于结尾program break处，我们选择 increment 为一个负值进行堆收缩（这是正确的）；但在我们还未释放的时候，另一个进程选择分配内存，调用 sbrk。在分配后我们继续进行释放此时我们需要释放的块后增加了一个新块，再调用 sbrk 会导致另一个进程分配的块被释放从而引发错误。</p><p>​    为了解决这个问题，我们也可以自己设计一个进程安全的 sbrk 函数，称为 sbrk_safe</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">sbrk_safe</span><span class="hljs-params">(<span class="hljs-keyword">intptr_t</span> increment, <span class="hljs-keyword">void</span> *expect_top)</span></span>;</code></pre><p>​    其增加了一个参数expect_top，思想很简单，就是在每次调用 sbrk_safe 的时候将选择释放块的内存地址填入 expect_top，函数中验证其是否是在堆顶，如果不是就返回错误。</p><p>​    （另外 sbrk 可能还有其他问题，比如受到 mmap 分配内存和共享内存的阻碍导致内存分配的间断。这里有待进一步研究探讨）</p><h1 id="【二】动态内存分配器的设计"><a href="#【二】动态内存分配器的设计" class="headerlink" title="【二】动态内存分配器的设计"></a>【二】动态内存分配器的设计</h1><p>​        对于堆上的动态内存分配，我们通常将其组织为“块”的模式，一个块就是指一段连续内存地址，而根据其是否被分配数据又被划分为<strong>空闲块</strong>和<strong>分配块</strong>两种。</p><h2 id="序、内存块结构"><a href="#序、内存块结构" class="headerlink" title="序、内存块结构"></a>序、内存块结构</h2><p>​    首先我们需要了解一个简单的技巧，就是如果有空闲块相邻时我们是可以将其进行合并为一个空闲块的，这样一来我们就可以分配更大的内存，并减少内存的碎片程度。注意到由于我们需要对块进行分配和合并，所以我们必须要知道块的<strong>大小信息</strong>和<strong>块的分类</strong>，因而一个内存块中其并不是所有位置都存储着有效信息。以32位系统为例，双字对齐（8 bytes）我们设计一个块的头部一个字大小（4 bytes）放置着块的大小信息和分配信息，由于是双字对齐的，所以块大小的后3位永远是0（1000）, 因此我们用前29位放大小信息，后3位放置分配信息（实际上是最后一位）001表示已分配、000表示空闲。中间放置有效载荷、即数据段，尾部可有一个填充。</p><p>​    最后注意到我们需要对块进行<strong>合并</strong>（在后文中我们会详细讨论合并策略），所以在尾部也放置一个大小和分配标记有利于下一块相邻块快速找到上一块的分配状态和大小来达成向前合并的操作，所以我们在脚部也增加一个字大小（4 bytes）和头部相同的大小分配标记。这个特征称为<strong>边界标记</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqrjzzz4iaj30go0dwjyj.jpg" style="zoom:50%;"></p><h2 id="一、内存碎片"><a href="#一、内存碎片" class="headerlink" title="一、内存碎片"></a>一、内存碎片</h2><p>​        关于内存分配，首先我们要有一个直观，在组织过程中我们确实可以简单的每次分配内存都创建一个所需大小的块，但经过频繁的分配释放，很快堆上的整块内存就会被划分为十分杂乱的小块。这种情况称之为内存碎片化，内存碎片化是一个十分严重的问题，其可能导致内存极大的浪费，因此要理解动态内存分配器的设计之前首先我们需要理解内存碎片的概念，来帮助我们更好的设计一个性能更加优良的分配器。</p><p>​    关于内存碎片根据其表现形式可以分为两类，内部碎片和外部碎片。</p><h3 id="内部内存碎片"><a href="#内部内存碎片" class="headerlink" title="内部内存碎片"></a>内部内存碎片</h3><p>​    内部内存碎片可以有一个直观的理解（虽然可能有点夸张），就是如果你仅仅需要 1kb 的内存用于存放数据，但是你申请了 2GB 大小的内存空间用来存这 1kb 的数据，那么里面大部分的内存全部都被浪费掉了，这时候如果你再要申请内存，空闲的内存可能就不够了。这就是内部碎片。</p><p>​    这时候有人可能会问，那么我们之间分配需要分配的内存大小就好了啊？那为什么内部碎片还会产生呢？确实说的很对，。但有时候由于内存对齐需要以及分配器策略等影响我们并不能够直接分配正好就是需求大小的内存块，其产生机制我将会在下文中进一步深入讲解</p><h3 id="外部内存碎片"><a href="#外部内存碎片" class="headerlink" title="外部内存碎片"></a>外部内存碎片</h3><p>​    外部内存碎片的产生主要源于频繁的大小不一的内存分配和释放过程。经过一系列的分配释放，最后整块的内存会被切分成空闲块分配块相互交杂的情况，如下图所示，这时候如果我们想要再分配一个 1000 kb 的数据块，可能所有的空闲块加起来是大于 1000 kb 的但是由于没有一个空闲块是大于 1000 kb 的就会导致内存分配的失败。同时由于内存映射已经建立，重整虚拟内存会导致整个程序到虚拟内存，虚拟内存到物理内存的映射表都需要更改，这种花费是我们无法承受的，所以我们需要设计更好的分配方式尽量避免这种碎片化情况的产生。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqrji3uyl1g30b404l3yd.gif" alt></p><h2 id="二、空闲块组织模式"><a href="#二、空闲块组织模式" class="headerlink" title="二、空闲块组织模式"></a>二、空闲块组织模式</h2><p>​    关于动态内存分配器的设计其有不同的设计策略，而一种最为常见的区分方式是通过空闲块的组织模式来区分不同的分配器，这里简单介绍两种来自 CSAPP 的空闲块组织模式。</p><h3 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h3><p>​    关于隐式空闲链表，它组织内存空闲块的形式非常简单，可以说是根本没有任何组织，我们可以通过遍历所有堆块（因为我们知道每一个堆块的大小）并验证其是否空闲来找到所有空闲块。所以将这种空闲块组织模式成为隐式空闲链表组织模式。</p><ul><li><p><strong>优点：</strong>简单、无需其他数据结构、节省空间</p></li><li><p><strong>缺点：</strong>时间复杂度高，每次寻找空闲块都需要 O(n) 时间复杂度遍历所有堆块</p></li></ul><h3 id="显示空闲链表"><a href="#显示空闲链表" class="headerlink" title="显示空闲链表"></a>显示空闲链表</h3><p>​    关于显示空闲链表，其是通过在空闲块中间添加两个指针分别指向前趋空闲块和后继空闲块，将空闲块串联成一个链表的模式。这时候我们在全局需要存储一个入口指针指向第一个空闲块，因为其显示的将所有空闲块进行串联，所以我们称这种组织模式为显示空闲链表</p><ul><li><strong>优势：</strong>速度快效率高，只需要 O(m) 遍历所有空闲块</li><li><strong>缺点：</strong>组织复杂，且最小块大小较大（空闲块需要多两个指针的大小）</li></ul><p>在实际的动态内存分配器中我们常常使用显示空闲链表的模式，因为相比于它的效率提升，其多出的空间花费是微不足道的。</p><h2 id="三、空闲块适配模式"><a href="#三、空闲块适配模式" class="headerlink" title="三、空闲块适配模式"></a>三、空闲块适配模式</h2><p>​    说完了空闲块组织模式，我们来谈谈常见的空闲块适配模式，为什么要适配空闲块？当然是因为请求分配一个内存大小的时候要找到一个相应合适的内存块，空闲块适配这个概念和前面讲到的内存碎片有着很大的联系，如果我们选的太大那么就会导致内部碎片的产生（如果没有其他分割策略），如果外部碎片太多，那么我们可能根本找不到合适的空闲块。</p><p>接下来我主要介绍三类空闲块组织模式，首次适配（First Fit）、再次适配（Next Fit)和最佳适配（Best Fit）</p><ul><li><strong>首次适配：</strong> 遍历空闲块找到的第一个合适的空闲块就用来分配 （速度快，内存不一定节省）</li><li><strong>再次适配：</strong>不从头找起，从上一次分配的空闲块继续往下找，找到的第一个适合的空闲块就用来分配 （默认了分配内存的大小基本一致，需要依赖于程序的内存分配特点和空闲块大小组织方式，效率不固定）</li><li><strong>最佳适配：</strong>遍历所有空闲块，找到一个在能够符合分配条件下最小的空闲块来最大化减少内部碎片的产生（内存利用率最佳，但效率较低）</li></ul><h2 id="四、空闲块顺序安排"><a href="#四、空闲块顺序安排" class="headerlink" title="四、空闲块顺序安排"></a>四、空闲块顺序安排</h2><p>​    空闲块顺序安排这个概念是归属于显示空闲链表组织模式下的，隐式空闲链表就完全不会有这个概念（因为根本没有组织xs）</p><p>​    下面来讲讲空闲块的顺序安排，其主要有两种组织形式，LIFO 顺序和地址顺序</p><ul><li><strong>LIFO 顺序：</strong>把释放块插入到空闲链表的开始处，结合首次适配策略，我们便每次会分配适合分配大小的最近释放的空闲块。</li></ul><p>由于我们每次都在空闲块链表开头插入新释放的空闲块，其释放能够在常数时间内 O(1) 完成。</p><ul><li><strong>地址顺序：</strong> 我们也可以简单地按地址顺序安排空闲块链表，即让空闲块链表中空闲块地址从低到高排序，这样符合堆的地址增长方式。</li></ul><p>通常情况下地址顺序结合首次适配的方式比LIFO结合首次适配拥有<strong>更高的内存利用率</strong>，这是从实验中得出的</p><h2 id="五、空闲块的存储技术"><a href="#五、空闲块的存储技术" class="headerlink" title="五、空闲块的存储技术"></a>五、空闲块的存储技术</h2><h3 id="分离适配与分段空闲链表（-Segregated-Free-List-）"><a href="#分离适配与分段空闲链表（-Segregated-Free-List-）" class="headerlink" title="分离适配与分段空闲链表（ Segregated Free List ）"></a>分离适配与分段空闲链表（ Segregated Free List ）</h3><p>​    在实际应用中，我们可以对空闲块的组织模式进行一定的大小分类，通过分类的方式，我们可以进一步减少空闲块的索引时间。</p><p><strong>（这里的思想是运用的分层级的思想，这一思想在计算机科学中无处不在，例如数据库中的多级索引，多级页表的组织等，其实际上就是用分组的形式形成层级结构，通过使用更多的空间来换取索引的时间，是典型的空间换时间模式）</strong></p><p>我们将根据空闲块大小的分类得出的不同类称为大小类，通常在一个最简单的应用中，我们可以使用二的幂次来对其进行表示。在实现上，我们可以将其组织为一个叫做分段空闲链表（Segregated Free List）的组织形式（如下图所示）。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqrl8pm35nj30wc0u0aj5.jpg" style="zoom:40%;"></p><p>​    例如我们将空闲块按二的幂次分为 MAX_ORDER 个大小类，每个 index = i 维护一个链表，连接着一类大小位于 $ 2^{i - 1}$ ~ $2^i$ 的空闲块，这样的组织形式，我们就可以先根据分配需求索引大类的大小，定位之后再进入链表根据适配规则适配空闲块。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <em>Computer Systems: A Programmer’s Perspective</em>, 3/E (CS:APP3e). Randal E. Bryant and David R. O’Hallaron, Carnegie Mellon University.  Page 469</p><p>[2] <a href="https://lifecs.likai.org/2010/02/sbrk-is-not-thread-safe.html">Life of a Computer Scientist: sbrk() is not thread safe (likai.org)</a></p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Malloc</tag>
      
      <tag>VM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cache Lab 理解高速缓存</title>
    <link href="/2021/04/13/ICS/CacheLab/"/>
    <url>/2021/04/13/ICS/CacheLab/</url>
    
    <content type="html"><![CDATA[<p><em>注：本实验报告为 CMU CSAPP CacheLab 实验报告</em></p><h2 id="一、实验简介"><a href="#一、实验简介" class="headerlink" title="一、实验简介"></a>一、实验简介</h2><p>​    Cache Lab实验主要在于帮助学生理解高速缓存的工作方式，以及如何针对Cache编写程序。实验主体总共分为两个部分 </p><h3 id="PartA"><a href="#PartA" class="headerlink" title="PartA"></a><strong>PartA</strong></h3><p>编写一个Cache的模拟程序用以统计在L\S\M过程中Cache Hit\Miss\Eviction 的总数。</p><p>官方给出了 csim-ref 程序，我们需要编写代码实现其功能，输出 Hit/Miss/Eviction 的总数</p><pre><code class="hljs shell">Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;Options:  -h         Print this help message.  -v         Optional verbose flag.  -s &lt;num&gt;   Number of set index bits.  -E &lt;num&gt;   Number of lines per set.  -b &lt;num&gt;   Number of block offset bits.  -t &lt;file&gt;  Trace file.Examples:<span class="hljs-meta">  linux&gt;</span><span class="bash">  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace</span><span class="hljs-meta">  linux&gt;</span><span class="bash">  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace</span></code></pre><p><strong>测试方法：</strong></p><p>​    使用 test-csim.c 进行测试，测试器会输出你的编译器和标准结果，并进行比较计算分数。</p><pre><code class="hljs shell">xzy@ubuntu:~/Desktop/ICSLAB/CacheLab$ ./test-csim                         Your simulator     Reference simulatorPoints (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace    27TEST_CSIM_RESULTS=27</code></pre><h3 id="PartB"><a href="#PartB" class="headerlink" title="PartB"></a><strong>PartB</strong></h3><p>编写适应Cache的矩阵转置程序，使Cache的miss数尽量的小。</p><p>​    给出总大小1kb，每个 block 为 32byte 的直接映射Cache</p><p>​    共包含3个测试、分别为 32x32 \ 64x64 \ 61x67 大小的矩阵</p><p><strong>测试方法：</strong></p><p>​    使用 test-trans.c 进行测试</p><pre><code class="hljs shell">Usage: ./test-trans [-h] -M &lt;rows&gt; -N &lt;cols&gt;Options:  -h          Print this help message.  -M &lt;rows&gt;   Number of matrix rows (max 256)  -N &lt;cols&gt;   Number of  matrix columns (max 256)Example: ./test-trans -M 8 -N 8</code></pre><hr><h2 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h2><h3 id="PartA-1"><a href="#PartA-1" class="headerlink" title="PartA"></a>PartA</h3><ul><li><strong>关于 Cache 的结构组成</strong></li></ul><p>​    在 PartA 中我们需要在 csim.c 中编写模拟 Cache 运行的程序。学习过CSAPP第六章我们知道，Cache 的结构是由一行一个valid位，t个tag和一个长度为B的block组成的，总共分为多个Set，每个Set有E行。总共组成 Cache 大小 $C = B \times E \times S$ ( valid 和 tag 不计入 )</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gphwionzxcj30e30930t7.jpg" alt></p><ul><li><p><strong>关于 Evict 机制</strong></p><p>同时由于采取 LRU 策略 （最近最少使用策略），我们需要维护一个 timestamp 来标记其访问时间的远近。可以一开始赋值 INF，然后逐渐减小，LRUstamp 最小的，就会被 Evict。</p></li></ul><p>由此我们确定了 Cache 的组成形式，我们一个 Line 由 valid 位，tag位，LRUstamp，和一个B字节的 Block 组成。由于是模拟Cache，所以其实DataBlock可以不编写，但是为了尽量模拟真实Cache，还是分配了Block的内存</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> </span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> valid; <span class="hljs-comment">// 0/1 : invalid/valid</span>    <span class="hljs-keyword">int</span> tag;    <span class="hljs-keyword">int</span> LRUstamp; <span class="hljs-comment">// 越小代表越早使用，可以evict</span>    <span class="hljs-keyword">int</span>* Block; <span class="hljs-comment">// B（2^b） 字节</span>&#125; Line_t;</code></pre><pre><code class="hljs c"><span class="hljs-comment">// s个Set组成Cache</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>    <span class="hljs-keyword">int</span> S; <span class="hljs-comment">// Set 个数 (2^s)</span>    <span class="hljs-keyword">int</span> E; <span class="hljs-comment">// 每个 Set 中 Line 的数量</span>    <span class="hljs-keyword">int</span> B; <span class="hljs-comment">// Block 大小 (2^b)</span>    Line_t*** cache_;&#125; Cache_t;</code></pre><p>我在Cache中设置了S, E, B以方便管理Cache大小，不用每次传参，并编写对应设置函数。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initCache</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> E, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b)</span> </span><span class="hljs-function"></span>&#123;    Cache.S = (<span class="hljs-number">1</span> &lt;&lt; s), Cache.E = E, Cache.B = (<span class="hljs-number">1</span> &lt;&lt; b);&#125;</code></pre><ul><li><p><strong>关于内存管理</strong></p><p>之后便是编写函数来进行 Cache的内存分配和释放。这个没什么好说的，就是要养成分配完释放的好习惯，避免内存泄漏。</p><pre><code class="hljs c"><span class="hljs-comment">/* 分配 Cache */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mallocCache</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Cache.cache_ = (Line_t***)<span class="hljs-built_in">malloc</span>(Cache.S* <span class="hljs-keyword">sizeof</span>(Line_t **));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Cache.S; ++i)        Cache.cache_[i] = (Line_t **)<span class="hljs-built_in">malloc</span>(Cache.E * <span class="hljs-keyword">sizeof</span>(Line_t *));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Cache.S; ++i)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; Cache.E; ++j)            Cache.cache_[i][j] = (Line_t *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Line_t));    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Cache.S; ++i)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; Cache.E; ++j) &#123;            Cache.cache_[i][j]-&gt;valid = <span class="hljs-number">0</span>;            Cache.cache_[i][j]-&gt;tag = <span class="hljs-number">0</span>;            Cache.cache_[i][j]-&gt;LRUstamp = <span class="hljs-number">1e9</span>;            Cache.cache_[i][j]-&gt;Block = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(Cache.B * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));        &#125;&#125;</code></pre><pre><code class="hljs c"><span class="hljs-comment">/* 释放 Cache */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">freeCache</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Cache.S; ++i)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; Cache.E; ++j)            <span class="hljs-built_in">free</span>(Cache.cache_[i][j]-&gt;Block);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Cache.S; ++i)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; Cache.E; ++j)            <span class="hljs-built_in">free</span>(Cache.cache_[i][j]);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Cache.S; ++i)        <span class="hljs-built_in">free</span>(Cache.cache_[i]);    <span class="hljs-built_in">free</span>(Cache.cache_);&#125;</code></pre></li></ul><ul><li><p><strong>关于 getter 函数</strong></p><p>为了方便valid、tag等信息的查找，我编写了一系列getter函数。</p><pre><code class="hljs c"><span class="hljs-comment">/* 获得 Valid bit */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getValid</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> E)</span> </span>&#123;<span class="hljs-keyword">return</span> Cache.cache_[s][E]-&gt;valid;&#125;<span class="hljs-comment">/* 获得 Tag */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getTag</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> E)</span> </span>&#123;<span class="hljs-keyword">return</span> Cache.cache_[s][E]-&gt;tag;&#125;<span class="hljs-comment">/* 获得LRUstamp */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLRU</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> E)</span> </span>&#123;<span class="hljs-keyword">return</span> Cache.cache_[s][E]-&gt;LRUstamp;&#125;</code></pre></li></ul><ul><li><p><strong>对于Hit和Miss的判定</strong></p><p>判定hit和miss，就是在Cache对应Set中对比valid和tag，如果valid为1标明有效，并且tag相同，则说明Hit，不然则Miss。</p><pre><code class="hljs c"><span class="hljs-comment">/* 查看是否命中 */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">HitOrMiss</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> tag)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Cache.E; ++i)        <span class="hljs-keyword">if</span>(getValid(s, i) &amp;&amp; getTag(s, i) == tag)            <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 命中</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Miss </span>&#125;</code></pre></li></ul><ul><li><p><strong>关于是否Evict</strong></p><p>根据上文，我们知道我们采取LRU的evict策略，那么在写的时候，如果valid位为1，而tag不一致发生写miss的情况，就要进行evict。evict的位置是LRUstamp最小的那一个。我们维护LRUstamp，在每次操作时，将其赋值为INF (1e9) 并将其余的LRUstamp减1，取最小的 LRUstamp 进行evict，用最新的 tag 和 数据 进行替换</p></li></ul><pre><code class="hljs c"><span class="hljs-comment">/* 更新LRU，越小越早使用 */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lruUpdate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> E)</span></span><span class="hljs-function"></span>&#123;    Cache.cache_[s][E]-&gt;LRUstamp = <span class="hljs-number">1e9</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Cache.E; ++i)    &#123;        <span class="hljs-keyword">if</span>(i != E)            Cache.cache_[s][i]-&gt;LRUstamp--;    &#125;&#125;<span class="hljs-comment">/* 更新Cache */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WriteCache</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> E, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> tag)</span></span><span class="hljs-function"></span>&#123;    Eviction(s, E, tag);    Cache.cache_[s][E]-&gt;valid = <span class="hljs-number">1</span>;    Cache.cache_[s][E]-&gt;tag = tag;    lruUpdate(s, E);&#125;</code></pre><ul><li>关于模拟Cache</li></ul><p>最后进行Cache的模拟，如果Hit了就值更新LRUstamp，Miss了就获取EvictionPose，并将其替换。</p><pre><code class="hljs c"><span class="hljs-comment">/* 模拟Cache，获得 Hit 和 Miss 的次数 */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getAns</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> tag)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> hit_flag = HitOrMiss(s, tag);    <span class="hljs-keyword">if</span>(hit_flag != <span class="hljs-number">-1</span>) &#123; <span class="hljs-comment">// Hit</span>        Hit++;        <span class="hljs-keyword">if</span>(verbose)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hit &quot;</span>);        lruUpdate(s, hit_flag);    &#125;    <span class="hljs-keyword">else</span>  &#123;        Miss++;        <span class="hljs-keyword">if</span>(verbose)            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;miss &quot;</span>);        WriteCache(s, getEvictPos(s), tag);    &#125;&#125;</code></pre><p>最后完整代码，附于提交 <code>csim.c</code> 中</p><ul><li>完成通过</li></ul><pre><code class="hljs c">Your simulator     Reference simulatorPoints (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts     <span class="hljs-number">3</span> (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)       <span class="hljs-number">9</span>       <span class="hljs-number">8</span>       <span class="hljs-number">6</span>       <span class="hljs-number">9</span>       <span class="hljs-number">8</span>       <span class="hljs-number">6</span>  traces/yi2.trace     <span class="hljs-number">3</span> (<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)       <span class="hljs-number">4</span>       <span class="hljs-number">5</span>       <span class="hljs-number">2</span>       <span class="hljs-number">4</span>       <span class="hljs-number">5</span>       <span class="hljs-number">2</span>  traces/yi.trace     <span class="hljs-number">3</span> (<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)       <span class="hljs-number">2</span>       <span class="hljs-number">3</span>       <span class="hljs-number">1</span>       <span class="hljs-number">2</span>       <span class="hljs-number">3</span>       <span class="hljs-number">1</span>  traces/dave.trace     <span class="hljs-number">3</span> (<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)     <span class="hljs-number">167</span>      <span class="hljs-number">71</span>      <span class="hljs-number">67</span>     <span class="hljs-number">167</span>      <span class="hljs-number">71</span>      <span class="hljs-number">67</span>  traces/trans.trace     <span class="hljs-number">3</span> (<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)     <span class="hljs-number">201</span>      <span class="hljs-number">37</span>      <span class="hljs-number">29</span>     <span class="hljs-number">201</span>      <span class="hljs-number">37</span>      <span class="hljs-number">29</span>  traces/trans.trace     <span class="hljs-number">3</span> (<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>)     <span class="hljs-number">212</span>      <span class="hljs-number">26</span>      <span class="hljs-number">10</span>     <span class="hljs-number">212</span>      <span class="hljs-number">26</span>      <span class="hljs-number">10</span>  traces/trans.trace     <span class="hljs-number">3</span> (<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)     <span class="hljs-number">231</span>       <span class="hljs-number">7</span>       <span class="hljs-number">0</span>     <span class="hljs-number">231</span>       <span class="hljs-number">7</span>       <span class="hljs-number">0</span>  traces/trans.trace     <span class="hljs-number">6</span> (<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)  <span class="hljs-number">265189</span>   <span class="hljs-number">21775</span>   <span class="hljs-number">21743</span>  <span class="hljs-number">265189</span>   <span class="hljs-number">21775</span>   <span class="hljs-number">21743</span>  traces/<span class="hljs-keyword">long</span>.trace    <span class="hljs-number">27</span></code></pre><hr><h3 id="PartB-1"><a href="#PartB-1" class="headerlink" title="PartB"></a>PartB</h3><p>​    在完成了Cache基本的组织架构之后，我们现在要开始编写Cache友好的程序，以矩阵转置为例。源代码中包含一个最naive的矩阵转置，也是我们平常经常写的。</p><pre><code class="hljs c"><span class="hljs-comment">/* </span><span class="hljs-comment"> * trans - A simple baseline transpose function, not optimized for the cache.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">char</span> trans_desc[] = <span class="hljs-string">&quot;Simple row-wise scan transpose&quot;</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trans</span><span class="hljs-params">(<span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> A[N][M], <span class="hljs-keyword">int</span> B[M][N])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i, j, tmp;    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; M; j++) &#123;            tmp = A[i][j];            B[j][i] = tmp;        &#125;    &#125;    &#125;</code></pre><p>测试之后会发现，对于4x4的矩阵，其miss次数有22次之多</p><pre><code class="hljs shell">func 1 (Simple row-wise scan transpose): hits:15, misses:22, evictions:19</code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gphxvxlx02j312d0iw40v.jpg" style="zoom:50%;"></p><p>我们可以发现，对于4x4的矩阵，由于Block大小是32bytes且为直接映射Cache，所以每8个int会在同一个Block/Set当中，4x4的矩阵被分在两个不同的 Block 中，对于A矩阵的访问是行优先的，而B矩阵的访问是列优先的。我们可以模拟这个过程</p><blockquote><p>访问到 $A<em>{00}$  Cache cold miss，将 $B</em>{A_{1}}$ 加入 Cache 中</p><p>访问到 $B<em>{00}$  由于B和A有相同的组索引，所以导致相对位置相同的地方被映射到Cache的同一组中，造成tag不一致，产生miss将会把之前Load到Cache里的A进行驱逐，将 $B</em>{A<em>{1}}$ 驱逐 将 $B</em>{B_{1}}$ 加入 Cache 中</p><p>访问到 $A<em>{01}$  同理，将 $B</em>{B<em>{1}}$ 驱逐 将 $B</em>{A_{1}}$ 加入 Cache 中</p><p>之后 $B<em>{B</em>{2}}$ 和  $B<em>{A</em>{1}}$ 很幸运能够不产生thrash，有几次Cache hit，但是大部分情况下，还是会发生如同上面所描述的抖动。</p></blockquote><p>因此，对于这种情况，我们应该如何修改代码，使其适应Cache，能够尽可能少的Miss呢？</p><ul><li><p><strong>暴力方法</strong></p><p>有一种最暴力的方式，就是考虑到目前矩阵的大小比较小，所以我们可以采取定义8个局部变量的方法，一次性将一个Block全部Load到寄存器中，然后再进行转置，这样就不会发生如上面所描述的 Cache thrash。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transpose_4x4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> A[N][M], <span class="hljs-keyword">int</span> B[M][N])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">3</span>; x += <span class="hljs-number">2</span>)&#123;tmp0 = A[x][<span class="hljs-number">0</span>], tmp1 = A[x][<span class="hljs-number">1</span>], tmp2 = A[x][<span class="hljs-number">2</span>], tmp3 = A[x][<span class="hljs-number">3</span>];tmp4 = A[x + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], tmp5 = A[x + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], tmp6 = A[x + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], tmp7 = A[x + <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];B[<span class="hljs-number">0</span>][x] = tmp0, B[<span class="hljs-number">1</span>][x] = tmp1, B[<span class="hljs-number">2</span>][x] = tmp2, B[<span class="hljs-number">3</span>][x] = tmp3; B[<span class="hljs-number">0</span>][x + <span class="hljs-number">1</span>] = tmp4, B[<span class="hljs-number">1</span>][x + <span class="hljs-number">1</span>] = tmp5, B[<span class="hljs-number">2</span>][x + <span class="hljs-number">1</span>] = tmp6, B[<span class="hljs-number">3</span>][x + <span class="hljs-number">1</span>] = tmp7; &#125;&#125;</code></pre><pre><code class="hljs angelscript">func <span class="hljs-number">0</span> (Transpose submission): hits:<span class="hljs-number">29</span>, misses:<span class="hljs-number">8</span>, evictions:<span class="hljs-number">6</span></code></pre><p>可以看到miss降到了8，有极大的改进，我们用partA中写的csim进行分析。</p><pre><code class="hljs shell">xzy@ubuntu:~/Desktop/ICSLAB/CacheLab$ ./csim -v -s 5 -E 1 -b 5 -t trace.f0S 18e08c,1 miss #系统missL 18e0a0,8 miss #系统missL 18e084,4 hit L 18e080,4 hit L 10e080,4 miss eviction L 10e084,4 hit L 10e088,4 hit L 10e08c,4 hit L 10e090,4 hit L 10e094,4 hit L 10e098,4 hit L 10e09c,4 hit S 14e080,4 miss eviction S 14e090,4 hit S 14e0a0,4 miss eviction # 多一次missS 14e0b0,4 hit S 14e084,4 hit S 14e094,4 hit S 14e0a4,4 hit S 14e0b4,4 hit L 10e0a0,4 miss eviction L 10e0a4,4 hit L 10e0a8,4 hit L 10e0ac,4 hit L 10e0b0,4 hit L 10e0b4,4 hit L 10e0b8,4 hit L 10e0bc,4 hit S 14e088,4 hit S 14e098,4 hit S 14e0a8,4 miss eviction S 14e0b8,4 hit S 14e08c,4 hit S 14e09c,4 hit S 14e0ac,4 hit S 14e0bc,4 hit S 18e08d,1 miss eviction #系统misshits:29 misses:8 evictions:6</code></pre><p>可以看到除了前后3次系统固定的miss之外，距离理论下限4次还有1次，这一次发生在Store矩阵B的时候，由于B是列优先，所以在访问到$B<em>{B</em>{2}}$的时候会多发生一次miss。</p><h4 id="32x32-矩阵转置"><a href="#32x32-矩阵转置" class="headerlink" title="32x32 矩阵转置"></a>32x32 矩阵转置</h4></li></ul><p>​        了解了之后我们来看32x32的矩阵转置，其正好是Cache 1kb的总大小，能够全部装进Cache。所以我们需要避免的就是连续在A,B</p><p>之间切换访问相对位置相同的区域（映射到同一个Block）从而导致的Cache thrash。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpi2azu5g2j31dl0qz42z.jpg" style="zoom:50%;"></p><p>我们可以采取 8*8分块的方式，对于每一块中每一行属于同一个Block，经过8x8分块后我们发现，除了对角线的分块之外，其他分块的A、B互不影响，不会产生thrash。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transpose_32x32</span><span class="hljs-params">(<span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> A[N][M], <span class="hljs-keyword">int</span> B[M][N])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i, j, x, y;<span class="hljs-keyword">int</span> tmp;      <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">8</span>)        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">8</span>)          <span class="hljs-keyword">for</span>(x = i; x &lt; i + <span class="hljs-number">8</span>; ++x)              <span class="hljs-keyword">for</span>(y = j; y &lt; j + <span class="hljs-number">8</span>; ++y)              &#123;                tmp = A[x][y], B[y][x] = tmp;              &#125;  <span class="hljs-comment">/*</span><span class="hljs-comment">    注意，这里应该学习示例程序中的 tmp = A[x][y], B[y][x] = tmp; </span><span class="hljs-comment">    因为我们无法确定调用者是否会使A，B指向内存中的同一块区域从而造成意想不到的后果。</span><span class="hljs-comment">  */</span>&#125;</code></pre><pre><code class="hljs shell">func 0 (Transpose submission): hits:1735, misses:350, evictions:318 # 8x8 分块func 1 (Simple row-wise scan transpose): hits:870, misses:1183, evictions:1151# Naive</code></pre><p>可以看到相比于最初naive的版本1183miss，已经有了极大的改善，但是还是没有达到要求的小于300miss。</p><p>我们可以发现，除对角线之外的分块已经达到miss的下限，所以对角线是需要解决的地方。对于对角线上的分块，我们的处理和Naive方式没有什么区别，都会造成thrash。</p><p>有了前面4x4矩阵的铺垫，我们已经知道了应该如何处理这类情况，我们按照之前的解决方法类似解决。</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transpose_32x32</span><span class="hljs-params">(<span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> A[N][M], <span class="hljs-keyword">int</span> B[M][N])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i, j, x, y;    <span class="hljs-keyword">int</span> tmp, tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">8</span>)        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">8</span>)<span class="hljs-keyword">for</span>(x = i; x &lt; i + <span class="hljs-number">8</span>; ++x)&#123;<span class="hljs-keyword">if</span>(i == j)&#123;tmp0 = A[x][j], tmp1 = A[x][j + <span class="hljs-number">1</span>], tmp2 = A[x][j + <span class="hljs-number">2</span>], tmp3 = A[x][j + <span class="hljs-number">3</span>];tmp4 = A[x][j + <span class="hljs-number">4</span>], tmp5 = A[x][j + <span class="hljs-number">5</span>], tmp6 = A[x][j + <span class="hljs-number">6</span>], tmp7 = A[x][j + <span class="hljs-number">7</span>];B[j][x] = tmp0, B[j + <span class="hljs-number">1</span>][x] = tmp1, B[j + <span class="hljs-number">2</span>][x] = tmp2, B[j + <span class="hljs-number">3</span>][x] = tmp3; B[j + <span class="hljs-number">4</span>][x] = tmp4, B[j + <span class="hljs-number">5</span>][x] = tmp5, B[j + <span class="hljs-number">6</span>][x] = tmp6, B[j + <span class="hljs-number">7</span>][x] = tmp7; &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span>(y = j; y &lt; j + <span class="hljs-number">8</span>; ++y)&#123;tmp = A[x][y], B[y][x] = tmp;&#125;&#125;&#125;&#125;</code></pre><pre><code class="hljs angelscript">func <span class="hljs-number">0</span> (Transpose submission): hits:<span class="hljs-number">1766</span>, misses:<span class="hljs-number">287</span>, evictions:<span class="hljs-number">255</span></code></pre><p>​    成功将miss降到了287。实际的理论下限是256，我们注意到这种操作方式A矩阵的miss已经达到了下限，而B矩阵的对角线还是会固定miss。这是因为在Load A之前，B矩阵的对角线行已经被前一个转置Load进去，所以会被evict掉，再次调用时就会产生一次Miss。所以我们可以对其进行展开，最后可以做到259次的miss（3次系统miss）由于代码可读性太低，这里不做展开。</p><hr><h4 id="64x64矩阵转置"><a href="#64x64矩阵转置" class="headerlink" title="64x64矩阵转置"></a>64x64矩阵转置</h4><p>​    对于64x64矩阵转置，我们注意到其已经超过了Cache的大小，我们首先用8分块尝试一下。</p><pre><code class="hljs shell">func 0 (Transpose submission): hits:3586, misses:4611, evictions:4579 # 8分块func 1 (Simple row-wise scan transpose): hits:3474, misses:4723, evictions:4691 # naive</code></pre><p>发现没有什么改进，这是什么原因？我们从Cache大小的角度出发</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpi5dme0pcj31ok0tnteo.jpg" alt></p><p>我们进行4x4分块试验一下</p><pre><code class="hljs c"><span class="hljs-keyword">int</span> i, j, x, y;    <span class="hljs-keyword">int</span> tmp, tmp0, tmp1, tmp2, tmp3;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">4</span>)        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">4</span>)<span class="hljs-keyword">for</span>(x = i; x &lt; i + <span class="hljs-number">4</span>; ++x)&#123;<span class="hljs-keyword">if</span>(i == j)&#123;tmp0 = A[x][j], tmp1 = A[x][j + <span class="hljs-number">1</span>], tmp2 = A[x][j + <span class="hljs-number">2</span>], tmp3 = A[x][j + <span class="hljs-number">3</span>];B[j][x] = tmp0, B[j + <span class="hljs-number">1</span>][x] = tmp1, B[j + <span class="hljs-number">2</span>][x] = tmp2, B[j + <span class="hljs-number">3</span>][x] = tmp3; &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span>(y = j; y &lt; j + <span class="hljs-number">4</span>; ++y)&#123;tmp = A[x][y], B[y][x] = tmp;&#125;&#125;&#125;</code></pre><pre><code class="hljs shell">func 0 (Transpose submission): hits:6402, misses:1795, evictions:1763</code></pre><p>​    可以看到结果好了很多，但是还是没能达到1300的要求。其原因其实还是在最开始讲的4x4分块的例子中，由于B矩阵是按列访问，在4x4分块之后，访问对角两块的时候，会每一块都会各产生2次miss，有一个小的thrash。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpi5iw1wfdj31or0tj0vq.jpg" style="zoom:33%;"></p><p>​    对自己电脑寄存器数量有自信的选手可能会选择开16个临时变量来一次性完成转置，但那样太过粗暴而不稳定。我们想是否有什么办法能够使4x4区域中的miss次数降低到1次？我们回去考虑8x8的分块情况。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpi5pdjqnuj31tk0laq79.jpg" alt></p><ul><li><p><strong>对于A矩阵</strong></p><p>我们的策略是一次load掉4行的内容，以防多次访问</p></li><li><p><strong>对于B矩阵</strong></p><p>我们发现，其实对于2、3两块分块，如果在2处出现miss，那么3其实也被加入了Cache不会发生miss，所以就有了如下策略。</p></li></ul><p>  <strong>解决方案：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gpi5wquog6j30vb0t4jtx.jpg" style="zoom:25%;"></p><ol><li><p>我们可以先一次性Load A1、A2两块到B1、B2两块中，这样只会1次miss。</p></li><li><p>我们按行将A3转置到B2中， 再将B2中原来放置的A2转置到A3中 (B2 Hit -&gt; B3 miss -&gt;下次B2 miss之后 B2、B3在Cache中便不会miss了) 共2次miss</p></li><li>之后再将A4转置到B4中，这样会miss1次</li></ol><p>总共miss4次，这样一来对于8x8 的 B矩阵，相当于每个4x4只miss了一次，完成了要求。</p><p><em>&lt; 代码太长见附件 &gt;</em></p><p>测试一下，效果拔群！</p><pre><code class="hljs angelscript">func <span class="hljs-number">0</span> (Transpose submission): hits:<span class="hljs-number">9082</span>, misses:<span class="hljs-number">1163</span>, evictions:<span class="hljs-number">1131</span></code></pre><hr><h4 id="61x67矩阵"><a href="#61x67矩阵" class="headerlink" title="61x67矩阵"></a>61x67矩阵</h4><p>对于这类非方阵，我们采用最简单的分块策略进行测试。</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">4x4</th><th style="text-align:center">8x8</th><th style="text-align:center">16x16</th><th style="text-align:center">17x17</th></tr></thead><tbody><tr><td style="text-align:center">miss数</td><td style="text-align:center">2425</td><td style="text-align:center">2118</td><td style="text-align:center">1992</td><td style="text-align:center">1950</td></tr></tbody></table></div><p>个人测试了 4x4 \ 8x8 \ 16x16 发现16x16可以满足miss数小于 2k 的要求。参考网上资料[1]后，发现 17x17是最优选择，miss数为1950</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transpose_61x67</span><span class="hljs-params">(<span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> N, <span class="hljs-keyword">int</span> A[N][M], <span class="hljs-keyword">int</span> B[M][N])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i, j, x, y, tmp;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i += <span class="hljs-number">17</span>)        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; M; j += <span class="hljs-number">17</span>)<span class="hljs-keyword">for</span>(x = i; x &lt; N &amp;&amp; x &lt; i + <span class="hljs-number">17</span>; ++x)<span class="hljs-keyword">for</span>(y = j; y &lt; M &amp;&amp; y &lt; j + <span class="hljs-number">17</span>; ++y)&#123;tmp = A[x][y];B[y][x] = tmp; &#125;&#125;</code></pre><hr><h2 id="三、实验结论"><a href="#三、实验结论" class="headerlink" title="三、实验结论"></a>三、实验结论</h2><p>最后我们运行 <code>drive.py</code> 来测试我们的总分</p><pre><code class="hljs shell">Part A: Testing cache simulatorRunning ./test-csim                        Your simulator     Reference simulatorPoints (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace    27Part B: Testing transpose functionRunning ./test-trans -M 32 -N 32Running ./test-trans -M 64 -N 64Running ./test-trans -M 61 -N 67Cache Lab summary:                        Points   Max pts      MissesCsim correctness          27.0        27Trans perf 32x32           8.0         8         287Trans perf 64x64           8.0         8        1163Trans perf 61x67          10.0        10        1950          Total points    53.0        53</code></pre><p>满分 53.0/53</p><h2 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h2><p>[1] <em>Computer Systems: A Programmer’s Perspective</em>, 3/E (CS:APP3e). Randal E. Bryant and David R. O’Hallaron, Carnegie Mellon University</p><p>[2] <a href="https://blog.csdn.net/xbb224007/article/details/81103995">https://blog.csdn.net/xbb224007/article/details/81103995</a></p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ELF头简介</title>
    <link href="/2021/03/22/Readelf/"/>
    <url>/2021/03/22/Readelf/</url>
    
    <content type="html"><![CDATA[<p><em>项目地址： <a href="https://github.com/ZiYang-xie/Readelf">https://github.com/ZiYang-xie/Readelf</a></em> （My Readelf Implement）</p><hr><p>​    在linux中我们常用readelf指令来读取ELF (Executable and Linkable Format) 文件中的信息，本文首先介绍ELF头的基本信息，在下篇文章中将会介绍一下个人实现的一个简单的读取ELF头的程序，等效于readelf -h <file></file></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Elf-layout--en.svg/260px-Elf-layout--en.svg.png" alt="ELF文件结构"></p><h3 id="ELF头"><a href="#ELF头" class="headerlink" title="ELF头"></a>ELF头</h3><p>elf头是位于elf文件的头部，里面存储着一些机器和该ELF文件的基本信息。</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>   e_ident[EI_NIDENT];        Elf64_Half      e_type;        Elf64_Half      e_machine;        Elf64_Word      e_version;        Elf64_Addr      e_entry;        Elf64_Off       e_phoff;        Elf64_Off       e_shoff;        Elf64_Word      e_flags;        Elf64_Half      e_ehsize;        Elf64_Half      e_phentsize;        Elf64_Half      e_phnum;        Elf64_Half      e_shentsize;        Elf64_Half      e_shnum;        Elf64_Half      e_shstrndx;&#125; Elf64_Ehdr;</code></pre><p>我们分别介绍其含义</p><hr><h4 id="1、e-ident"><a href="#1、e-ident" class="headerlink" title="1、e_ident"></a>1、e_ident</h4><ul><li><strong>长度：16字节</strong></li><li><strong>简介：包含着文件和操作系统信息</strong></li><li><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosklimwgzj30m00fmq55.jpg" style="zoom:50%;"></li></ul><h5 id="Magic-Num-e-ident-0-3"><a href="#Magic-Num-e-ident-0-3" class="headerlink" title="Magic Num - e_ident[0:3]"></a>Magic Num - e_ident[0:3]</h5><p>​    前四个字节包含着一个 magic number，表示该文件是一个 ELF 文件</p><h5 id="EI-Class-e-ident-4"><a href="#EI-Class-e-ident-4" class="headerlink" title="EI_Class - e_ident[4]"></a>EI_Class - e_ident[4]</h5><p>​    指示文件类型，是ELF32还是ELF64位</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskl3oqhyj30dq05qq3h.jpg" style="zoom:50%;"></p><h5 id="EI-DATA-e-ident-5"><a href="#EI-DATA-e-ident-5" class="headerlink" title="EI_DATA - e_ident[5]"></a>EI_DATA - e_ident[5]</h5><p>​    指示文件的编码方式，是大端法还是小端法</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskkp5pdjj30fy05ggm5.jpg" style="zoom:50%;"></p><p>​    <strong>ELFDATA2LSB - 小端法</strong></p><p>​    <strong>ELFDATA2MSB - 大端法</strong></p><h5 id="EI-Version-e-ident-6"><a href="#EI-Version-e-ident-6" class="headerlink" title="EI_Version - e_ident[6]"></a>EI_Version - e_ident[6]</h5><p>​    标识ELF Version, 该值等于EV_CURRENT，目前为1</p><h5 id="EI-OSABI-e-ident-7"><a href="#EI-OSABI-e-ident-7" class="headerlink" title="EI_OSABI - e_ident[7]"></a>EI_OSABI - e_ident[7]</h5><p>​    表示着该文件运行的操作系统</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskk8xx2wj30oi0jmadb.jpg" alt="操作系统类型对应" style="zoom:50%;"></p><h5 id="EI-ABIVERSION-e-ident-8"><a href="#EI-ABIVERSION-e-ident-8" class="headerlink" title="EI_ABIVERSION - e_ident[8]"></a>EI_ABIVERSION - e_ident[8]</h5><p>​    标志着 ABI （应用二进制接口）的版本，ABI相当于硬件层级的API（见下图）</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosknnji29j31400u0qd8.jpg" alt="ABI解释" style="zoom:40%;"></p><h5 id="EI-PAD-e-ident-8-15"><a href="#EI-PAD-e-ident-8-15" class="headerlink" title="EI_PAD - e_ident[8:15]"></a>EI_PAD - e_ident[8:15]</h5><p>​    填充位，用零填充用以对齐，可以预留给未来使用</p><h4 id="2、e-type"><a href="#2、e-type" class="headerlink" title="2、e_type"></a>2、e_type</h4><ul><li><p><strong>长度：2字节</strong></p></li><li><p><strong>简介：</strong>指示文件类型</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosm36oov3j30he0da40a.jpg" style="zoom:50%;"></p></li></ul><p>​    </p><h4 id="3、e-machine"><a href="#3、e-machine" class="headerlink" title="3、e_machine"></a>3、e_machine</h4><ul><li><p><strong>长度：2字节</strong></p></li><li><p><strong>简介：</strong>指示机器类型</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosm42l3lxj30u00x2wkc.jpg" alt="部分机器类型" style="zoom:50%;"></p></li></ul><h4 id="4、e-version"><a href="#4、e-version" class="headerlink" title="4、e_version"></a>4、e_version</h4><p>​    <strong>长度：4字节</strong></p><p>​    <strong>简介：指示文件版本</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosm8c0knij30dk04gglx.jpg" style="zoom:50%;"></p><h4 id="5、e-entry"><a href="#5、e-entry" class="headerlink" title="5、e_entry"></a>5、e_entry</h4><p>​    <strong>长度：4字节（32位）/8字节（64位）</strong></p><p>​    <strong>简介：进程开始的虚拟地址</strong></p><h4 id="6、e-phoff"><a href="#6、e-phoff" class="headerlink" title="6、e_phoff"></a>6、e_phoff</h4><p>​    <strong>长度：4字节（32位）/8字节（64位）</strong></p><p>​    <strong>简介：指向程序头部表的开始</strong>    </p><h4 id="7、e-shoff"><a href="#7、e-shoff" class="headerlink" title="7、e_shoff"></a>7、e_shoff</h4><p>​    <strong>长度：4字节（32位）/8字节（64位）</strong></p><p>​    <strong>简介：指向节头部表的开始</strong>    </p><h4 id="8、e-flags"><a href="#8、e-flags" class="headerlink" title="8、e_flags"></a>8、e_flags</h4><p>​    <strong>长度：4字节</strong></p><p>​    <strong>简介：意义取决于目标架构</strong>    </p><h4 id="9、e-ehsize"><a href="#9、e-ehsize" class="headerlink" title="9、e_ehsize"></a>9、e_ehsize</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：该文件头部的大小</strong></p><h4 id="10、e-phentsize"><a href="#10、e-phentsize" class="headerlink" title="10、e_phentsize"></a>10、e_phentsize</h4><p>​    <strong>长度：2字节</strong>    </p><p><strong>简介：程序头部的大小</strong>    </p><h4 id="11、e-phnum"><a href="#11、e-phnum" class="headerlink" title="11、e_phnum"></a>11、e_phnum</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：程序头部的条目数</strong></p><h4 id="12、e-shentsize"><a href="#12、e-shentsize" class="headerlink" title="12、e_shentsize"></a>12、e_shentsize</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：节头部表的大小</strong></p><h4 id="13、e-shnum"><a href="#13、e-shnum" class="headerlink" title="13、e_shnum"></a>13、e_shnum</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：节头部表的条目数</strong></p><h4 id="14、e-shstrndx"><a href="#14、e-shstrndx" class="headerlink" title="14、e_shstrndx"></a>14、e_shstrndx</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：节头部表的条目和其位置 (idx) 的对应关系</strong></p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">https://en.wikipedia.org/wiki/Executable_and_Linkable_Format</a></p><p>[2] <a href="https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html">https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Link</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CaDDN论文阅读</title>
    <link href="/2021/03/09/Research/CaDDN-Paper/"/>
    <url>/2021/03/09/Research/CaDDN-Paper/</url>
    
    <content type="html"><![CDATA[<h1 id="Categorical-Depth-Distribution-Network-for-Monocular-3D-Object-Detection"><a href="#Categorical-Depth-Distribution-Network-for-Monocular-3D-Object-Detection" class="headerlink" title="Categorical Depth Distribution Network for Monocular 3D Object Detection"></a><strong>Categorical Depth Distribution Network for Monocular 3D Object Detection</strong></h1><p><strong>关键词： 单目3d检测、绝对深度分配网络</strong></p><p><strong>论文链接：</strong><a href="https://arxiv.org/pdf/2103.01100.pdf">https://arxiv.org/pdf/2103.01100.pdf</a></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1godx97xntnj30bl08p0wn.jpg" alt></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    单目3D检测的难点一直在于对深度的预测，实例从3D空间被映射到2D平面的图像上丢失了深度信息，对深度的处理一直是单目3D目标检测研究的重点方向，目前主流的方法主要分为三类。</p><p><strong>1、直接检测  (Direct Methods)</strong></p><p>​    直接检测方法没有显式的对深度进行学习，比较有代表性的是关键点检测方法，通过关键点结合几何特征来帮助3D-Bbox的检测，好处是简单直接且高效，但这类方法由于没有显式的学习深度信息，往往导致深度预测的结果不尽理想。</p><p><strong>2、基于深度  (Depth-Based Methods)</strong></p><p>​    基于深度的方法通常先会通过一个单目深度预测分支来得到一张深度图作为网络的输入从而辅助对深度的检测，由于有了深度信息其可被转换成点云来处理（可以用上3d检测的方法)。但由于其深度和目标检测分离训练的结构，导致其可能会丢失一些隐含的信息。</p><p><strong>3、基于网格  (Grid-Based Methods)</strong></p><p>​    基于网格的方法避免了对深度的直接预测，而是通过预测一个 BEV grid 的表达来作为3D检测网络的输入，OFT[1]提出了一种体素网格，通过把体素投影到图像平面上进而采样图像特征将其转换成BEV的形式。但这也会导致大量体素和特征的重叠从而降低检测的准确性。</p><p>​    <strong>CaDDN</strong> 网络对上面三种情况的优点进行结合，整体网络结构是同时训练了深度预测和3D检测（jointly）以期待其能够解决方法2中的问题，同时利用也将图像平面转换成了BEV的形式来提高检测的准确性。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1godxz73f1jj30nm0dntcy.jpg" alt="网络结构"></p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><h3 id="Frustum-Feature-Network"><a href="#Frustum-Feature-Network" class="headerlink" title="Frustum Feature Network"></a>Frustum Feature Network</h3><ul><li><strong>Depth Distribution Network</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1godzoe00t7j30b908dabe.jpg" alt></p><p>对于特征提取网络，其输出形似一个截角锥形，因而作者称其为Frustum feature Network，其输入是原始图像 $I \in R^{W_1\times H_1\times 3}$ 输出 $G \in R^{W_F\times H_F\times D \times C}$ 其中 W和H是特征的宽高，D 是深度桶，用以深度预测，C 是特征的维度。图像特征被用以在每个像素上预测绝对的深度分布 $D \in R^{W_F\times H_F\times D}$ 网络对每个像素预测其落入某一深度桶（深度离散化）的概率，总共D个。</p><p>（这一网络其是从 DeepLabV3[2] 上魔改过来的。）</p><ul><li>Image Channel Reduce</li></ul><p>同时在分配深度桶的同时，网络另一分支用1x1卷积 + BN + ReLU 把特征的维数从256降到了64。</p><p>​    经过这两个分支后，将预测出来的深度桶和特征像素做外积得到了带有深度信息的特征图（$G(u,v) = D(u,v) \otimes F(u,v)$）且由于特征桶的结构，具有较高的容错性。称 G 为 frustum features</p><h3 id="Frustum-to-Voxel-Trans"><a href="#Frustum-to-Voxel-Trans" class="headerlink" title="Frustum to Voxel Trans"></a>Frustum to Voxel Trans</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1godzokeng2j30b907ujsr.jpg" alt></p><p>​    G 之后将被转换成体素的形式，这里的问题是在第分辨率的frustum features进行高分辨率的体素采样会导致过采样，导致出现大量相同的体素特征，浪费算力不说还降低预测准确性。所以这边作者直接把降采样前的特征层拉了过来，来保证不会出现上述问题。</p><h3 id="Voxel-Collapse-to-BEV-gt-Detection"><a href="#Voxel-Collapse-to-BEV-gt-Detection" class="headerlink" title="Voxel Collapse to BEV -&gt; Detection"></a>Voxel Collapse to BEV -&gt; Detection</h3><p>​    由于BEV在保证同等检测效果的情况下能够节省计算资源，作者将体素的 Z 轴和 channels 直接连接起来，继续用1x1卷积 + BN + ReLU 将体素块压缩成 BEV的形式。然后接着在 BEV 特征块上连接检测头进行 3D目标检测。</p><h2 id="深度离散化"><a href="#深度离散化" class="headerlink" title="深度离散化"></a>深度离散化</h2><p>​    本文的主要亮点就是其对于深度的处理，其对每个像素位置分配了离散化的深度桶，预测其属于某一深度的概率。这里的深度离散化作者使用的是 LID (Linear-increasing discretization)[3] 因为其对不同深度之间提供了最为平衡的预测概率。对于检测任务的深度我们最需要的是检测目标的深度信息，而更少去在意背景点的深度。</p><p>​                                                            <script type="math/tex">d_c = d_min + \frac{d_{max}-d_{min}}{D(D+1)}\cdot{d_i}{(d_1+1)}</script></p><p>​    <em>（其中 $d<em>c$ 是连续深度值，[$d</em>{min},d_{max}$]是离散化的上下界，D是深度桶的数量，$d_i$ 是下标）</em></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goe03wlr9sj30dn0bd0tp.jpg" alt></p><h2 id="实验效果"><a href="#实验效果" class="headerlink" title="实验效果"></a>实验效果</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goe0ckxhf6j30r10fgn17.jpg" alt="KITTI实验效果"></p><p>​    可以看到其在车辆和新人检测上都打破了目前最好的检测方法，对骑行者的检测不如 MonoPSR 但也大大超过了其余检测模型。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goe0gh8vyhj30dw07jdgw.jpg" alt></p><p>这张表可以看出其将深度预测和特征融合所得到的 frustum features 确实有助于提升检测效果。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>​    个人觉得这篇paper的主要成功点在于其对于单目深度预测的创新解决方法，不同于传统的深度预测模型，提出了离散化深度将每个像素的深度概率离散化分配在不同的深度桶中，避免了网络过度依赖于深度的准确检测。但同时其也没有从根本上解决深度预测的问题，同时其中间对于特征图进行体素化投影再转为 BEV 的过程较为复杂，虽然其把降采样前的特征层拿来转成体素形式但是仍然还是无法避免会有损失。</p><p>​    个人觉得可以借鉴该模型的深度预测方法，应用在现有的模型上或者对该模型的网络结构进行简化，可能会带来更好的效果。</p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1]  Thomas Roddick, Alex Kendall, and Roberto Cipolla. Ortho graphic feature transform for monocular 3D object detection.<em>BMVC</em>, 2018</p><p>[2] Liang-Chieh Chen, George Papandreou, Florian Schroff, andHartwig Adam. Rethinking atrous convolution for semantic image segmentation. <em>arXiv preprint</em>, 2017</p><p>[3] Yunlei Tang, Sebastian Dorn, and Chiragkumar Savani. Center3d: Center-based monocular 3d object detection with joint depth understanding. <em>arXiv preprint</em>, 2020</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>Object Detection</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Monocular OD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法及编译器优化效果对比</title>
    <link href="/2021/03/08/ICS/ICS_Normal/"/>
    <url>/2021/03/08/ICS/ICS_Normal/</url>
    
    <content type="html"><![CDATA[<h2 id="ICS-Normal-第一周作业"><a href="#ICS-Normal-第一周作业" class="headerlink" title="ICS (Normal) 第一周作业"></a><em>ICS (Normal) 第一周作业</em></h2><h3 id="冒泡与快排用时对比"><a href="#冒泡与快排用时对比" class="headerlink" title="冒泡与快排用时对比"></a>冒泡与快排用时对比</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocut0coevj31do0sggpl.jpg" alt="冒泡排序"></p><h3 id="相同算法在-GCC-编译优化下用时对比"><a href="#相同算法在-GCC-编译优化下用时对比" class="headerlink" title="相同算法在 GCC 编译优化下用时对比"></a>相同算法在 GCC 编译优化下用时对比</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocvbzmuy0j31cy0s842c.jpg" alt="冒泡排序"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocut5qwjwj31a80smjvj.jpg" alt="快速排序"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocutaoylej31b40sqtcm.jpg" alt="优化快速排序"></p><h3 id="不同排序算法在不同GCC优化下的变化"><a href="#不同排序算法在不同GCC优化下的变化" class="headerlink" title="不同排序算法在不同GCC优化下的变化"></a>不同排序算法在不同GCC优化下的变化</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocutf9rb3j31cs0s8dih.jpg" alt="冒泡排序"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocuthxygzj31b20t4jtt.jpg" alt="快速排序"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocutkvifhj31b20swdi8.jpg" alt="优化快速排序"></p><hr><h3 id="改进快速排序"><a href="#改进快速排序" class="headerlink" title="改进快速排序"></a>改进快速排序</h3><p>对于快速排序的改进策略一般有两种</p><ul><li><strong><em>Pivot 三值取中</em></strong></li></ul><p>快速排序最坏情况是枢纽元为最大或者最小数字，那么所有数都划分到一个序列去了时间复杂度为O(n^2)，为了保证最坏情况不出现，尽量使pivot能够二分序列，我们采用三值取中法，既开头、中间、结尾三个元素选取大小中等的元素与首元交换成为Pivot，避免最坏情况出现。</p><p><strong>效果：</strong>在应用三值取中后可以发现优化快排的排序速度变得较为稳定，不像普通版本一样依赖于序列的形态。</p><ul><li><strong><em>小规模插入排序</em></strong></li></ul><p>即当快速排序所划分的子序列的长度小于某个定值k时，该子序列基本有序，可以采用插入排序的办法对子序列进行排序，从而使整体算法的时间复杂度的期望下降为 $O(nk+nlg(\frac{n}{k}))$</p><h3 id="实验效果"><a href="#实验效果" class="headerlink" title="实验效果"></a>实验效果</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocuto6qwgj317w0t076c.jpg" alt></p><p>可以看到在同等数据量下，对于快速排序具有一定优化效果</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocutsrs9ij31au0sctcp.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocutvjlj6j31bg0rkwig.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocutym2uij31bm0sotct.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocuu1tn5uj31b20swdk0.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocuu4kk90j31b20s4n1a.jpg" alt></p><p>可以看到，随着优化等级的增加，优化的快排几乎成线性，更加稳定，而普通快排有所波动。</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DETR 论文阅读</title>
    <link href="/2021/01/22/Research/DETR/"/>
    <url>/2021/01/22/Research/DETR/</url>
    
    <content type="html"><![CDATA[<h1 id="End-to-End-Object-Detection-with-Transformers"><a href="#End-to-End-Object-Detection-with-Transformers" class="headerlink" title="End-to-End Object Detection with Transformers"></a>End-to-End Object Detection with Transformers</h1><p><em>关键词： 目标检测， Transformer，End-to-End</em></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    Detr 这篇文章抛弃了传统 Fast-RCNN 基于 ROI 的目标检测方式，使用了Transformer以及其提出的 bipartite matching 做到位置无关和生成唯一的目标检测框，以此省去了 Anchor 和 NMS。以非常简单的架构达到媲美甚至超越 Fast-RCNN 的准确率，在能够做目标检测的同时，该模型还有较好的迁移能力，在原论文中通过 Transformer 的 Attention 机制实现了全景分割。</p><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmwgc8ubqoj310s07t435.jpg" alt="网络结构图"></p><p>​    DETR 的网络结构很简单，分为三个部分，第一部分是一个传统 CNN 用于提取图片特征到更高维度，第二部分一个Transformer 的 Encoder 和 Decoder 来提取 Bounding Box，最后使用 Bipartite matching loss 来训练网络。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmwghk322pj30m8069adc.jpg" alt="结构细节"></p><p>​        更加细致的划分可划分为 CNN backbone 部分，Transformer 中的 Encoder 和 Decoder 部分，预测前馈网络 (FFN) 部分。接下来会详细讲解。</p><h3 id="CNN-部分"><a href="#CNN-部分" class="headerlink" title="CNN 部分"></a>CNN 部分</h3><p>​    DETR 的第一部分用了一个 CNN backbone 将 $x_{img} \in R^{3 \times H_0 \times W_0}$ (3 的 RGB 深度) 转换为 $f \in R^{C \times H \times W}$ 的特征层。论文中用了 $C = 2048, H = \frac{H_0}{32}, W = \frac{W_0}{32}$ </p><h3 id="Transformer-部分"><a href="#Transformer-部分" class="headerlink" title="Transformer 部分"></a>Transformer 部分</h3><h4 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h4><p>​    先用 1x1 的卷积核将纬度从 C 降到 d，获得一个新的特征图 $R^{ d \times H \times W}$ 。由于 Encoder 需要一个序列，我们要将特征图拉平成为 $d \times HW$ 的向量，输入到 encoder 中，每一个 encoder 都是同样的结构，由一个多头注意力模块和一个前馈网络（FFN）组成。不像RNN，transformer 的输入是顺序无关的，于是我们也学 NLP 对每一个注意力层加一个位置编码 （position encodings）。将状态编码和之前拉平的特征图向量相加之后喂入 encoder 中。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmwioerjhbj30ea0ghgq4.jpg" style="zoom:80%;"></p><h4 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h4><p>​    decoder 的输入有两个，一个是 Object Queries 另一个是刚刚 Encoder 的输出，结构和传统 Transformer 差不多。比较有意思的是这个输入的 Object Queries，由于 Transformer 是 fixed size，如果我们需要 N 个 Bounding Box 那么我们就需要 N 个输入，同时这个 Object Queries 顺便充当了 decoder 的 position encodings，是通过学习得来的。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmwi2hocbcj30eh0gb421.jpg" style="zoom:80%;"></p><p>​    encoder 的输出直接喂到的是 Encoder-Decoder Attention 层，这 N 个位置嵌入要先通过自注意力层才获得 encoder 的信息。作者将这 N 个 序列最后生成的 Bounding Box 拿出来可视化，结果非常 Amazing 啊。</p><p>​    <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmwinw5iwbj30wn075ale.jpg" alt></p><p>​    图中的不同颜色的点代表不同大小形态的 Bounding Box，绿色代表较小的 Bounding Box，紫色代较大的 Bounding Box，红色代表大的水平的 boxes，蓝色代表大的竖直的 boxes。 对于每一个输入序列，其都有所侧重，有的侧重与左侧的小 Bounding Box 有的侧重于中间大的Bounding Box。</p><h3 id="Bipartite-matching-loss"><a href="#Bipartite-matching-loss" class="headerlink" title="Bipartite matching loss"></a>Bipartite matching loss</h3><p>​    之前检测器往往通过anchor和groundtruth的IOU来确定正负样本，而DETR使用了bipartite matching loss 来确定正负样本。</p><p>​    <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmzoqacu30j307d01waa0.jpg" alt="bipartite matching loss"></p><p>​    其中 $L_{match}$ 是 ground true 和预测 bounding boxes 之间的 pair-wise matching cost （一一配对 penalty）</p><p>​    <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmzoq11i5jj303405hmxa.jpg" alt="bipartite matching"> </p><p>​    通过一一配对，就不需要再采取传统的 NMS 了，因为一个bounding box 只能和一个 ground true 进行匹配，必然会引入 loss。算法实现采用的是<strong>匈牙利算法</strong>，这个后期我会写在博客上。</p><h3 id="FFN"><a href="#FFN" class="headerlink" title="FFN"></a>FFN</h3><p>​    最后得出结果的网络，是一个三层的感知机，activation function 用的是 ReLU，以及一个线性映射层。输出的是每一个 bounding box 的中心坐标，以及它的宽高 $(x,y,w,h)$ 以及物体的分类。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>​    原文在 COCO 2017 数据集上做的实验，模型虽然简单但却消耗了大量的训练时间 （Training the baseline model for 300 epochs on 16 V100 GPUs takes 3 days, with 4 images per GPU），最后效果媲美甚至超过了经过良好调教的 Fast-RCNN 类的人工 head + anchor 的模式。</p><p>​    <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmzpkgtz3xj30gj06n75k.jpg" alt="实验结果"> </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    这篇文章还是相当惊艳的，一直以来不管是 anchor based 还是 anchor free 的目标检测方法都难以脱离人工定义 anchor 的过程，而本篇文章通过使用 Transformer + positional encoding 达到甚至超越了传统方法的性能，里面特别是 positional encodings 的 object queries 非常耐人寻味，这些 queries 学到的真的只是 positional encoding吗？这个 queries 是否有可能是 tasks 无关的？如果是能不能通过预训练的方式来提高训练速度，这些问题都是后期值得探索的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] Nicolas Carion, Francisco Massa, Gabriel Synnaeve, Nicolas Usunier, Alexander Kirillov, Sergey Zagoruyko: “End-to-End Object Detection with Transformers”, 2020; <a href="http://arxiv.org/abs/2005.12872">arXiv:2005.12872</a></p><p>[2] 如何评价FAIR的新论文DETR？ <a href="https://www.zhihu.com/question/397692959/answer/1258046044">https://www.zhihu.com/question/397692959/answer/1258046044</a> </p><p>[3] 如何看待End-to-End Object Detection with Transformers? <a href="https://www.zhihu.com/question/397624847/answer/1250143331">https://www.zhihu.com/question/397624847/answer/1250143331</a></p><p>[4] 详解Transformer （Attention Is All You Need）<a href="https://zhuanlan.zhihu.com/p/48508221">https://zhuanlan.zhihu.com/p/48508221</a></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>Object Detection</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS_PJ Y86 Extended CPU</title>
    <link href="/2021/01/06/ICS/ICS_PJ/"/>
    <url>/2021/01/06/ICS/ICS_PJ/</url>
    
    <content type="html"><![CDATA[<p><em>项目地址： <a href="https://github.com/fdu2019xzy/ICS_Y86">https://github.com/fdu2019xzy/ICS_Y86</a></em></p><hr><h2 id="一、项目基本信息"><a href="#一、项目基本信息" class="headerlink" title="一、项目基本信息"></a>一、项目基本信息</h2><h3 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1. 项目简介"></a>1. 项目简介</h3><p>Y86-Extended 是由谢子飏和王少文组队合作完成的项目，作为复旦大学 ICS (上) 的期末PJ，<br>本项目在实现了本项目在基础流水线处理器架构之上添加了<strong>更高级的分支预测</strong>、<strong>硬件栈</strong>、 <strong>y86 指令集扩展</strong>，并编写了一个<strong>汇编器</strong> yyas (支持宏定义)，以及其他特殊功能。结合精美的前端，根据上传文件性质不同 (yo/ys) 可以在普通模式和编译模式下运行程序, 具有较高的鲁棒性, 能够直观的看到基本信息、所有的寄存器信息 (包括流水线寄存器)、运行进度、当前指令和其他信息。</p><p>支持任意<strong>前进回溯</strong>、<strong>设置断点</strong>、<strong>终端输出</strong> (包含<strong>彩色矩阵</strong>)等扩展功能</p><h3 id="2-项目分工"><a href="#2-项目分工" class="headerlink" title="2. 项目分工"></a>2. 项目分工</h3><p>王少文：后端 CPU 主体设计及汇编器<br>谢子飏： (中) 前端及测试</p><h3 id="3-项目架构及设计思路"><a href="#3-项目架构及设计思路" class="headerlink" title="3. 项目架构及设计思路"></a>3. 项目架构及设计思路</h3><p>我们的项目使用<strong>前后端分离</strong>开发策略，考虑到运行速度后端由 C++ 编写，中前端使用 Python, Vue.js, Js 开发。</p><ul><li>项目架构图</li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sAvtMV.png" style="width:500px"></p><ul><li>交互逻辑和运行过程</li></ul><p>整个交互逻辑和运行过程分为，前端上传 ys/yo 文件 post 到中端的 lauch.py 的flask服务器，flask驱动编译器编译并将编译好的yo文件传到 CPU 中。CPU 按设计跑完输出 data.json 文件，前端 fetch 后端 CPU 生成的 data.json 在前端按操作逻辑进行展示。</p><p>由于后端 C++ 跑的非常快，我们前端在上传后几乎能够即时获得 data, 而这样前后端分离的好处在于，我们前端可以非常自由的展现数据，所有的前进回溯甚至跳跃，都可以在 O(1) 内实现，不会出现很大的限制。</p><hr><h2 id="二、使用方式及功能详解"><a href="#二、使用方式及功能详解" class="headerlink" title="二、使用方式及功能详解"></a>二、使用方式及功能详解</h2><h3 id="1-具体使用方法"><a href="#1-具体使用方法" class="headerlink" title="1. 具体使用方法"></a>1. 具体使用方法</h3><p>(见项目目录下 README.md)</p><h3 id="2-功能详解"><a href="#2-功能详解" class="headerlink" title="2. 功能详解"></a>2. 功能详解</h3><ul><li>主体功能介绍图</li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sAv8Gn.png" alt></p><p><img src="https://s3.ax1x.com/2021/01/06/sAv3Ps.png" alt></p><ul><li>当前指令模块</li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sAvV2t.png" style="width:250px"></p><p>当前指令显示我们当前运行到的指令 (PC 所指)，并包含前后文2条指令的信息。</p><p><strong>隐藏断点设置</strong></p><p>为了前端的布局美观和统一性，断点设置被隐藏进了当前指令卡片中，点击当前指令卡片即可设置断点。</p><p><img src="https://s3.ax1x.com/2021/01/06/sAvE8I.png" style="width:400px"></p><p>可以任意设置增删断点</p><ul><li><strong>终端字符及彩色矩阵输出</strong></li></ul><p>根据后端的内存映射，我们可以让终端输出字符以及彩色矩阵。</p><p><img src="https://s3.ax1x.com/2021/01/06/sAvJx0.png" style="width:300px"></p><ul><li>附带我们编写的 YYAS 汇编器，能够实现 ys 到 yo 的编译</li></ul><hr><h2 id="三、代码详解"><a href="#三、代码详解" class="headerlink" title="三、代码详解"></a>三、代码详解</h2><h3 id="1-前端代码架构分析"><a href="#1-前端代码架构分析" class="headerlink" title="1. 前端代码架构分析"></a>1. 前端代码架构分析</h3><ul><li>前端代码架构图</li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sAvl5j.png" alt></p><p>前端设计采用 Vue.js 和前端框架 iView 设计，由于 Vue 的<strong>响应式渲染</strong>性质，非常适合我们本次的前端要求，同时为了保持多平台使用的可能性，Vue并没有使用脚手架，所有的 Vue.js、jQuery 都采用了 <strong>CDN 引入</strong>模式。</p><p>其中 Index 是主页面入口，Index.js 包括 Vue app 的创建和 Vue 页面路由， Index.html 包含主页面的 DOM 树</p><p>Pages 里面包含了主要的界面，主页面是 main.js 包含 cpu 的主要功能。<br>所有的 Pages 作为 export 模块被引入到 Index.js 中进行路由。<br>main.js 里面包含了 main 页面所有<strong>逻辑函数</strong>，<strong>声明周期钩子</strong>，以及 main 页面的 DOM 树， 其他页面也是同样架构。</p><p>（由于是 CDN 引入 main 页面要插入路由的话， DOM 树应当是字符串形式传入 template 中）</p><p>CSS 里面包含了所有主要的样式表，对功能和作用区域的不同做了简单的分类。</p><p>Static 里面包含了需要读取的 Json data 信息，以及当前处理编译文件放置在 Source 中。</p><ul><li><strong>中台前后端链接代码</strong></li></ul><p>前后端连接使用的是 python flask 服务器，通过接前端上传表单的 post，将获得的文件传入编译器编译之后喂入 CPU 中，获得 data.json 前端再 getData。</p><h3 id="2-后端代码架构分析"><a href="#2-后端代码架构分析" class="headerlink" title="2. 后端代码架构分析"></a>2. 后端代码架构分析</h3><ul><li>后端代码架构图</li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sAvQaQ.png" alt></p><ul><li>汇编器部分<ul><li>汇编器的可执行文件为yyas.py，这是包含了所有代码（不需要import）的最终文件，试试./yyas -v 和 ./yyas -h，有惊喜</li><li>instr.py为Y86所有指令的信息（不含Y86 Extended的扩展部分）</li><li>striper.py为Stage1时，将yo文件转化为yoraw的脚本，目前已经被弃用，仅作为存档提交。现在实现相同功能请使用./yyas -r -np</li></ul></li><li>CPU部分<ul><li>Controller.cpp 为CPU的控制器，主要包含了流水线的控制逻辑</li><li>Device.cpp 为CPU流水线的核心，包含了FDEMW五个阶段的运行逻辑</li><li>Output.cpp 有一些用于输出的函数，用于Stage1输出至命令行或Stage2输出至json文件</li><li>Util.cpp包含了一些辅助的函数，例如In函数和Format函数（这里用了很多modern cpp的魔法）</li></ul></li></ul><hr><div style="page-break-after: always;"></div><h2 id="四、-实现细节"><a href="#四、-实现细节" class="headerlink" title="四、 实现细节"></a>四、 实现细节</h2><h4 id="前端细节"><a href="#前端细节" class="headerlink" title="前端细节"></a>前端细节</h4><p>前端搭建了 anywhere 服务器 (用于解决跨域问题, 踩坑经历可以看第五节)，主要函数在 main.js 文件中， 通过各类声明周期函数和写的 handle 来处理上传，运行，停止，重置，以及断点设置等功能，此处不展开细讲，主要是后端。</p><p>（前端使用了 anywhere 服务器 + 中端 flask 服务器的双服务器架构，其主要是因为我们前端在 import 模块时不开本地服务器会产生跨域问题。对于跨域问题我们最开始遇到是在获取 data.json 的时候，踩坑过程中我们曾尝试通过jsonp 解决跨域问题，并且成功了，但在 import 模块时再次遇到了跨域问题，为了一劳永逸，我们直接使用了 anywhere 直接开了一个本地服。）</p><h4 id="后端细节"><a href="#后端细节" class="headerlink" title="后端细节"></a>后端细节</h4><ol><li><p><strong>关于流水线</strong>：为了尽可能的靠近实际的硬件架构，我们的CPU核心实现分成了<strong>wire</strong>和<strong>reg</strong>两种struct，用来模拟verilog硬件语言中的wire和reg，reg是实际存在的寄存器，而wire只是用于逻辑中转。为了模拟CPU的并行化，我们采用了如下的逻辑</p><ol><li>利用Reg中的数据计算F D E M W，写入wire变量（实际不存在）</li><li>利用现在的wire上的值，更新流水线及其他状态</li><li>将wire的值写入下一个Reg，例如f_wire写入D_Reg，当流水线状态为NORMAL时回到a</li></ol></li><li><p>每个阶段的具体实现逻辑， 与CSAPP上的电路实现差别不大，此处不再赘述</p></li><li><p><strong>关于扩展指令集</strong>：我们的指令集扩展见<strong>ISA.md</strong>，具体到流水线上只需少许修改各个阶段的逻辑，与官方设计思路差不太多，依次修改FDEMW就行。</p></li><li><p><strong>关于分支预测策略</strong>：我们的分支预测采用的是<strong>2比特溢出预测器</strong>，该预测器采用的逻辑如下图</p><p><img src="https://s3.ax1x.com/2021/01/06/sAvG2q.png" alt="预测器"></p><ol><li>当JXX的信号不是Jmp时，更新上述的状态机</li><li>若状态机信号为3或者2，则进行跳转</li><li>若状态机信号为1或者0，则不进行跳转</li></ol><p>除此之外，我们也需要相应的改变分支错判的逻辑，需要加一个IfJump信号，当E阶段输出的信号与IfJump信号不同，说明分支预测错误，需要清空流水线。</p><p>这样的分支预测器，据统计可以达到90%的正确率（<a href="https://en.wikipedia.org/wiki/Branch_predictor），在我们的测试中，一般情况下可以提升10%-30%的性能">https://en.wikipedia.org/wiki/Branch_predictor），在我们的测试中，一般情况下可以提升10%-30%的性能</a></p></li><li><p><strong>关于复杂指令</strong>：在我们增加的指令中，有一些指令如mulq、divq和remq都是很耗时的指令，如果强行让他们在一个周期内完成，我们的CPU时钟频率就会非常低。因此我们假定这部分指令所需要的时间为其他指令最长耗时的10倍，在E阶段设置一个counter，建立一个递减的状态机，使用下面的控制逻辑</p><ol><li>如果指令属于上述复杂指令，将状态机置于10</li><li>如果状态机不为0，则使F D阶段进入STALL阶段，E阶段继续计算，但阻断E到M的输入，状态机减1</li><li>如果状态机为0，则流水线继续执行</li></ol><p>这样就可以实现维持较高CPU频率的同时，实现复杂指令。（即不会因为加了这个指令使其他指令的执行变慢）</p></li><li><p><strong>关于硬件栈</strong>：为了避免每次调用ret指令时两个时钟周期的浪费，我们采用了CSAPP上的硬件栈。在硬件上，硬件栈可以由多路选择器和多个寄存器构成，在这里我们简单的使用Stack实现（大小为0x20）。采用如下的控制逻辑：</p><ol><li>如果调用call指令，在栈没有满时，将地址载入硬件栈</li><li>如果调用ret指令，在栈非空时，弹栈，将值读出</li><li>在M阶段执行后，判断硬件栈的预测是否正确<ol><li>若正确，则继续执行</li><li>若不正确，则清空 F D E的流水线</li></ol></li></ol><p>使用硬件栈后，最差的情况即是与无硬件栈情况相同，最好情况在我们的测试中，可以增加30%+的性能。</p></li><li><p>关于指令不可写和非指令不可读保护：我们的汇编器会计算yo文件中，最后一个是指令的位置，在CPU运行时，会进行动态的判断</p><ol><li>在Fetch阶段读取不可读的位置，会产生INS错误</li><li>在其他阶段写入不可写的位置，会产生ADR错误</li></ol></li><li><p>关于宏定义：为了CPU的扩展性和兼容性，我们使用了宏定义来动态的开关某些特性，例如 <code>OUTPUT_JSON</code> 宏定义后即可输出 data_json 供前端使用。</p></li></ol><h4 id="汇编器细节"><a href="#汇编器细节" class="headerlink" title="汇编器细节"></a>汇编器细节</h4><p>我们的汇编器采用了依次处理的方式，如下(Code Explains itself)</p><pre><code class="hljs python">lines = gen_list(lines) <span class="hljs-comment">#解析关键词</span>lines = remove_single_line_annot(lines) <span class="hljs-comment">#去除单行注释</span>lines = remove_multi_line_annot(lines) <span class="hljs-comment">#去除多行注释</span>lines = detach_label(lines) <span class="hljs-comment">#找到对应的label</span>lines_ref = copy.deepcopy(lines) <span class="hljs-comment">#复制一份用于输出</span>mem = get_memaddr(lines) <span class="hljs-comment">#找到内存对应的地址</span>labels = get_def_label(lines) <span class="hljs-comment">#处理.define</span>lines = replace_label(lines, mem, labels) <span class="hljs-comment">#处理label</span>byte_code = gen_byte_code(lines) <span class="hljs-comment">#产生yo代码</span></code></pre><h4 id="测试细节"><a href="#测试细节" class="headerlink" title="测试细节"></a>测试细节</h4><p>我们采用Google Test 和 Python Unitest来辅助我们进行我们的程序测试。其在我们项目文件的 test 文件夹下，我们通过 shell 脚本和 python 脚本将模拟器的输出进行处理，转换成 gtest 代码以便于我们进行测试。</p><p>基本语句即为 <code>EXPECT_EQ(x, y)</code></p><ul><li>测试代码结构</li></ul><p><img src="/2021/01/06/ICS/ICS_PJ/测试代码架构.png" alt></p><p>使用 Google Test 我们能够清晰的看到测试点信息。</p><ul><li>普通 yo_test</li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sAvZxP.png" style="width:300px"></p><ul><li>Hornor 测试</li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sAvmKf.png" style="width:300px"></p><ul><li>附加测试</li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sAvMVg.png" style="width:400px"></p><hr><div style="page-break-after: always;"></div><h3 id="五、特点和创新"><a href="#五、特点和创新" class="headerlink" title="五、特点和创新"></a>五、特点和创新</h3><ol><li><p><strong>汇编器创新</strong>：我们兼容现有的所有ys文件的基础上，还添加了一些伪指令和语法</p><ol><li>不需要写逗号了：现在所有的ys指令操作数之间可以使用空格隔开</li><li>mrmovq和rmmovq：现在不需要强制写括号，可以直接mov至常数地址（此时寄存器为RNONE，我们的CPU也做了相应的修改）如rmmovq %rax $800</li><li>伪指令<ol><li>.define 类似C语言的宏定义</li><li>.string “mystring” 将后面的mystring转化为对应的ASCII码写入</li><li>.byte .hword .word支持</li></ol></li><li>能够生成yo文件和yoraw文件，生成的yo文件比官方的yo文件漂亮不少，完全对齐</li><li>有完整的命令行参数</li></ol><pre><code class="hljs"><span class="hljs-attribute">usage</span>: yyas [-h] [-o OUTFILE] [-r] [-np] [-v] sourcefile<span class="hljs-attribute">yyas</span>: Assemble .ys file to .yo file or/and .yo file to raw byte filepositional arguments:  sourcefile            The source file to be assembledoptional arguments:  -h, --help            show this help message and exit  -o OUTFILE, --output OUTFILE                        Assign the output file  -r, --raw             Generate raw byte file  -np, --noprefix       Do not generate prefix in raw output  -v, --version         show version</code></pre></li><li><p><strong>处理器创新</strong>（见具体实现）</p><ol><li>更好的分支预测器</li><li>硬件栈</li><li>几乎三倍的指令集支持（及其扩展含义）</li><li>复杂指令集的多周期支持</li></ol></li></ol><hr><h3 id="六、总结与回顾"><a href="#六、总结与回顾" class="headerlink" title="六、总结与回顾"></a>六、总结与回顾</h3><h4 id="PJ-心得总结及致谢"><a href="#PJ-心得总结及致谢" class="headerlink" title="PJ 心得总结及致谢"></a>PJ 心得总结及致谢</h4><p>本次 PJ 让我们更加深入的理解了现代流水线处理器的原理，各种硬件栈，扩展指令集的设计也拓展了我们的技术边缘，非常不错的体验。最后非常感谢助教和金老师一学期的辛苦工作。在很多方面帮助了我们，助教的 Lab 非常精彩有趣，金老师的课十分幽默风趣，非常感谢各位的付出。</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>期末 DDL + TODOList</title>
    <link href="/2020/12/17/final_todo/"/>
    <url>/2020/12/17/final_todo/</url>
    
    <content type="html"><![CDATA[<h1 id="期末季DDL"><a href="#期末季DDL" class="headerlink" title="期末季DDL"></a>期末季DDL</h1><h3 id="这周的-数据结构-离散-数逻-作业"><a href="#这周的-数据结构-离散-数逻-作业" class="headerlink" title="这周的 数据结构/离散/数逻 作业"></a>这周的 数据结构/离散/数逻 作业</h3><h4 id="预计需要-4h"><a href="#预计需要-4h" class="headerlink" title="- 预计需要: 4h+"></a>- 预计需要: 4h+</h4><h3 id="实验室-Reading-Group-ddl-12-23-下周三"><a href="#实验室-Reading-Group-ddl-12-23-下周三" class="headerlink" title="实验室 Reading Group ( ddl: 12/23 下周三 )"></a>实验室 Reading Group ( <em>ddl: 12/23 下周三</em> )</h3><h4 id="预计需要-2-3h"><a href="#预计需要-2-3h" class="headerlink" title="- 预计需要: 2 ~ 3h"></a>- 预计需要: 2 ~ 3h</h4><h3 id="毛概实践报告-ddl-12-24-下周四"><a href="#毛概实践报告-ddl-12-24-下周四" class="headerlink" title="毛概实践报告 ( ddl: 12/24 下周四 )"></a>毛概实践报告 ( <em>ddl: 12/24 下周四</em> )</h3><ul><li><ol><li>字数5k字<h4 id="预计需要-2-3h-1"><a href="#预计需要-2-3h-1" class="headerlink" title="- 预计需要: 2 ~ 3h"></a>- 预计需要: 2 ~ 3h</h4><h4 id="安排时间：今晚毛概课给它干掉！"><a href="#安排时间：今晚毛概课给它干掉！" class="headerlink" title="- 安排时间：今晚毛概课给它干掉！"></a>- 安排时间：今晚毛概课给它干掉！</h4></li></ol></li></ul><h3 id="ICSPJ-Stage2-ddl-12-24-下周四"><a href="#ICSPJ-Stage2-ddl-12-24-下周四" class="headerlink" title="ICSPJ-Stage2 ( ddl: 12/24 下周四 )"></a>ICSPJ-Stage2 ( <em>ddl: 12/24 下周四</em> )</h3><ul><li><ol><li>前端优化添加功能 ( 10h )</li></ol></li><li><ol><li>PPT ( 3h )<h4 id="预计需要-15h"><a href="#预计需要-15h" class="headerlink" title="- 预计需要: 15h+"></a>- 预计需要: 15h+</h4></li></ol></li></ul><h3 id="美国文学选读考试-ddl-12-27-下周日晚上"><a href="#美国文学选读考试-ddl-12-27-下周日晚上" class="headerlink" title="美国文学选读考试 ( ddl: 12/27 下周日晚上 )"></a>美国文学选读考试 ( <em>ddl: 12/27 下周日晚上</em> )</h3><ul><li><ol><li>文本复习 ( 5h )</li></ol></li><li><ol><li>作者复习 ( 5h )<h4 id="预计需要-1day"><a href="#预计需要-1day" class="headerlink" title="- 预计需要 ( 1day )"></a>- 预计需要 ( 1day )</h4></li></ol></li></ul><h3 id="数据结构上机考-ddl-12-28-下下周一"><a href="#数据结构上机考-ddl-12-28-下下周一" class="headerlink" title="数据结构上机考 ( ddl: 12/28 下下周一 )"></a>数据结构上机考 ( <em>ddl: 12/28 下下周一</em> )</h3><ul><li><ol><li>复习算法 ( 8h )</li></ol></li><li><ol><li>复习上机题 ( 10h+ )<h4 id="预计需要-20h"><a href="#预计需要-20h" class="headerlink" title="- 预计需要: 20h+"></a>- 预计需要: 20h+</h4></li></ol></li></ul><h3 id="数逻-LAB7-ddl-12-29-下下周二"><a href="#数逻-LAB7-ddl-12-29-下下周二" class="headerlink" title="数逻 LAB7 ( ddl: 12/29 下下周二 )"></a>数逻 LAB7 ( <em>ddl: 12/29 下下周二</em> )</h3><h4 id="预计需要-3h"><a href="#预计需要-3h" class="headerlink" title="- 预计需要: 3h+"></a>- 预计需要: 3h+</h4><h3 id="毛概考试-ddl-12-29-下下周二"><a href="#毛概考试-ddl-12-29-下下周二" class="headerlink" title="毛概考试 ( ddl: 12/29 下下周二 )"></a>毛概考试 ( <em>ddl: 12/29 下下周二</em> )</h3><ul><li><ol><li>复习 ( 1h )<h4 id="预计需要-1h"><a href="#预计需要-1h" class="headerlink" title="- 预计需要: 1h+"></a>- 预计需要: 1h+</h4></li></ol></li></ul><h3 id="ICS-LAB5-ddl-12-30-下下周三"><a href="#ICS-LAB5-ddl-12-30-下下周三" class="headerlink" title="ICS-LAB5 ( ddl: 12/30 下下周三 )"></a>ICS-LAB5 ( <em>ddl: 12/30 下下周三</em> )</h3><h4 id="预计需要-3h-1"><a href="#预计需要-3h-1" class="headerlink" title="- 预计需要: 3h"></a>- 预计需要: 3h</h4><h3 id="近代中国思想与人物期末论文-ddl-未知"><a href="#近代中国思想与人物期末论文-ddl-未知" class="headerlink" title="近代中国思想与人物期末论文 ( ddl: 未知 )"></a>近代中国思想与人物期末论文 ( <em>ddl: 未知</em> )</h3><h4 id="预计需要-1day-1"><a href="#预计需要-1day-1" class="headerlink" title="- 预计需要: 1day"></a>- 预计需要: 1day</h4><h3 id="数据结构PJ-ddl-1-3-下下周日"><a href="#数据结构PJ-ddl-1-3-下下周日" class="headerlink" title="数据结构PJ ( ddl: 1/3 下下周日 )"></a>数据结构PJ ( <em>ddl: 1/3 下下周日</em> )</h3><h4 id="预计需要-12h"><a href="#预计需要-12h" class="headerlink" title="- 预计需要: 12h+"></a>- 预计需要: 12h+</h4><h3 id="数据结构考试-ddl-1-5-下下下周二"><a href="#数据结构考试-ddl-1-5-下下下周二" class="headerlink" title="数据结构考试 ( ddl: 1/5 下下下周二 )"></a>数据结构考试 ( <em>ddl: 1/5 下下下周二</em> )</h3><ul><li><ol><li>复习课本 ( 5h )<h4 id="预计需要-5h"><a href="#预计需要-5h" class="headerlink" title="- 预计需要: 5h+"></a>- 预计需要: 5h+</h4></li></ol></li></ul><h3 id="数逻考试-ddl-1-11-下下下下周一"><a href="#数逻考试-ddl-1-11-下下下下周一" class="headerlink" title="数逻考试 ( ddl: 1/11 下下下下周一 )"></a>数逻考试 ( <em>ddl: 1/11 下下下下周一</em> )</h3><h4 id="预计需要-1d"><a href="#预计需要-1d" class="headerlink" title="- 预计需要: 1d+"></a>- 预计需要: 1d+</h4><h3 id="离散考试-ddl-1-12-下下下下周二"><a href="#离散考试-ddl-1-12-下下下下周二" class="headerlink" title="离散考试 ( ddl: 1/12 下下下下周二 )"></a>离散考试 ( <em>ddl: 1/12 下下下下周二</em> )</h3><h4 id="预计需要-2d"><a href="#预计需要-2d" class="headerlink" title="- 预计需要: 2d+"></a>- 预计需要: 2d+</h4>]]></content>
    
    
    <categories>
      
      <category>TODO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TODO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PointCNN论文阅读</title>
    <link href="/2020/12/08/Research/PointCNN/"/>
    <url>/2020/12/08/Research/PointCNN/</url>
    
    <content type="html"><![CDATA[<h1 id="PointCNN"><a href="#PointCNN" class="headerlink" title="PointCNN"></a>PointCNN</h1><p>回顾之前读过的 PointNet++ 是受到 CNN 启发，通过局部的特征提取器和hierarchy 结构解决了 PointNet 在 local 上的劣势。但同时这种基于 PointNet 的顺序不依赖性使用的 symmetry function 最终总会导致一部分的信息丢失，PointCNN 直接使用 CNN 架构和一种自定义的 $\chi -Conv$ 操作，使常规的卷积也能处理点云。</p><hr><h2 id="关键问题-PointCloud-上的卷积"><a href="#关键问题-PointCloud-上的卷积" class="headerlink" title="关键问题 - PointCloud 上的卷积"></a>关键问题 - PointCloud 上的卷积</h2><p>我们都知道普通的 2d 卷积的实现方式，因为在图片上像素都是紧密相连的，很好实现，但对于 3d 的 Points 点的空间位置，距离，顺序都会对卷积造成挑战和影响，下图就展示了普通的 2d卷积 和 3d PointCloud 卷积的区别。</p><p><img src="https://s3.ax1x.com/2020/12/08/r9iVTU.png" alt></p><p>显然 PointCloud 上的卷积和形状(即点的相对位置) 和输入顺序有关。如果直接在上面做卷积就会发生灾难。</p><p><img src="https://s3.ax1x.com/2020/12/08/r9infJ.png" alt></p><p>上图我们看出，直接做卷积的话 $f<em>{ii}$ 和 $f</em>{iii}$ 不同的形状信息被丢失了（这正是我们希望保留的），而 $f<em>{iii}$ 与 $f</em>{iv}$ 之间仅因为顺序不同而造成了结果不同，即顺序有关，这是我们不希望看到的。</p><p>对于这个的解决方式，PointCNN 的作者使用了一个 $\chi$ - transformer 矩阵，先对 sample point 作用 $\chi$ 变换矩阵，再进行 Convolution 从而做到顺序无关的同时，不像 symmetry function 会丢失信息。</p><p><img src="https://s3.ax1x.com/2020/12/08/r9ilOx.png" alt="有点懒得翻译了，直接放原文"></p><p>可以看出这个 $\chi$ - transformation 是通过训练一个多层感知机获得的。同时产生输入点集的权重和排序，进而直接作用一个经典的卷积。</p><p><img src="https://s3.ax1x.com/2020/12/08/r9imY4.png" alt></p><p>简单来说就是我们希望对于 $\chi<em>{iii}$ 、 $\chi</em>{iv}$ 对于 $f<em>{iii}$ 、 $f</em>{iv}$ 的作用能够得到相同的feature，一种简单的实现方式就是找到一个变换矩阵 $\Pi$ 使得 $f<em>{iii}^{T} = \Pi \times f</em>{iv}^T$ 这样  $\chi<em>{iii} = \chi</em>{iv} \times \Pi$ 就可以达到目标。</p><p>值得注意的是，多层感知机得出的 $\Pi$ 并非一定是理想化的0101矩阵，而是有如0.1，0.9这样接近01的值，也可以将其理解为 feature 的权重这样得到的结果并不是完美的 即 $f<em>{iii}^{T} ≈ \Pi \times f</em>{iv}^T$</p><hr><h2 id="点云的平移不变性"><a href="#点云的平移不变性" class="headerlink" title="点云的平移不变性"></a>点云的平移不变性</h2><p>对于平移不变性的处理 PointCNN 很简单的使用了局部坐标系的转换，对于分割问题，采用最远点采样方式，然后对于采样点取 k - nearnest neighbours 将坐标系转换到采样点为中心的局部坐标系(即减去采样点坐标)</p><p><img src="https://s3.ax1x.com/2020/12/08/r9iekF.png" alt></p><p>对于卷积层，具体算法如下</p><p><img src="https://s3.ax1x.com/2020/12/08/r9i3m6.png" alt></p><ul><li>先做feature的选点和聚合，先转换到采样点局部坐标系</li><li>利用MLP将每个点变换到高维空间$C_{\delta}$ （这里用的是一维卷积）</li><li>Concat 其他特征信息</li><li><strong>对每个局部区域中的点使用MLP，得到变换矩阵X</strong></li><li>将得到的 $\chi$ 作用在 $F<em>*$ 上生成顺序不依赖的 $F</em>{\chi}$</li><li>对顺序不依赖的 $F_{\chi}$ 做 Convolution (这里也是一维卷积)</li></ul><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p><img src="https://s3.ax1x.com/2020/12/08/r9i80K.png" alt></p><p>对于 $\chi$ - transformer 的效果有上图的 visualization 可以看到 $F<em>*$ 中不同的 class 还是有overlap的因为对于 $F</em>*$ 其仅将特征提取到了高维，但其结果还是依赖于输入的顺序，所以不能够很好的划分featrue，而经过了 $\chi$ - transformer 不同的feature 被划分开来且更为密集，结果较好。</p><h2 id="模型效果"><a href="#模型效果" class="headerlink" title="模型效果"></a>模型效果</h2><p><img src="https://s3.ax1x.com/2020/12/08/r9iMlR.png" alt></p><p>可以看到准确率保持在一个比较高的水平。</p><p><img src="https://s3.ax1x.com/2020/12/08/r9iQ61.png" alt></p><p>同时 PointCNN 具有更少的参数 (0.6M) 以及极快的速度 (0.012s)<br>PointCNN 极具前景可以将 CNN 现有的工作进行应用。后续会看 PointCNN++ 等论文。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PointCNN 直接将点云和CNN结合将点云的工作引入到了一个开阔的领域，但近来也有一些工作在质疑 CNN 的必要性，google 的论文 Attention is all you need 就指出在 NLP 领域 transformer attention based 方法巨大的前景，也为 3D instance segmentation 提供了新思路。<br>关于 PointCNN 这篇经典读的还不是很透，关于 sample 选点的顺序问题和一些训练细节还没有弄的很懂，之后找时间细看。</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PointCNN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PointNet++论文阅读</title>
    <link href="/2020/12/08/Research/PointNetpp/"/>
    <url>/2020/12/08/Research/PointNetpp/</url>
    
    <content type="html"><![CDATA[<h1 id="PointNet"><a href="#PointNet" class="headerlink" title="PointNet++"></a>PointNet++</h1><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>回顾一下 PointNet ，我们说PointNet解决了 PointCloud 输入的顺序无关问题，但其有一个缺点就是无法获取局部特征，即没有很好的处理 local information，使其在复杂场景下表现乏力。PointNet++正是针对PointNet这一弱点进行改进。</p><ul><li>主要改进方式</li></ul><ol><li><p>受到 CNN 神经元感受野不断扩大的启发，利用空间距离，使 PointNet对点集局部区域进行特征迭代提取。</p></li><li><p>使用最远点提取方式，能够实现较为均匀的点采样</p></li></ol><h2 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h2><p>一、如何做点集划分 (怎么划分空间)</p><p>二、如何利用特征提取器提取局部特征信息 (怎么提取特征)</p><p>这两个问题是相关的，如果和 CNN 做一个类比，在CNN中卷积核是基本的特征提取器，每个卷积核对应一个 n*n 的像素区域，在PointCloud中同样要找到结构相同的子区域和对应的特征提取器。</p><p>那么在 PointNet++ 中作者使用欧式空间中的邻接球作为子区域做点集的 Partition 使用 PointNet 作为特征提取器。</p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p><img src="https://pic1.zhimg.com/80/v2-f3f9a70d0052be1949a18c6e556572b8_1440w.jpg" alt></p><p>主要包括三部分</p><h3 id="Sample-layer"><a href="#Sample-layer" class="headerlink" title="Sample layer"></a>Sample layer</h3><p>主要对输入点进行采样，使用最远点采样法，选择$N$个点，能够更均匀的覆盖整个点集。<br><img src="https://img-blog.csdnimg.cn/20200923132734170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1FUVkxD,size_16,color_FFFFFF,t_70#pic_center" alt></p><h3 id="Grouping-layer"><a href="#Grouping-layer" class="headerlink" title="Grouping layer"></a>Grouping layer</h3><p>确定点的局部划分，即确定邻接球的半径和内部的点的数量。<br>一种是 ball query 看半径，还有就是用 KNN 看内部点的数量</p><h3 id="PointNet-layer"><a href="#PointNet-layer" class="headerlink" title="PointNet layer"></a>PointNet layer</h3><p>通过 PointNet 进行特征提取，假设每个 Group 中有 $n$ 个点，那么通过 PointNet 将 $n\times 3$ 的矩阵转换成 $n\times K$ 的矩阵。迭代进行操作，感受野逐渐扩大，维数逐渐提升。</p><h2 id="不均匀点云数据"><a href="#不均匀点云数据" class="headerlink" title="不均匀点云数据"></a>不均匀点云数据</h2><p>我们知道点云数据不像图片中的信息是紧密连接的，空间中的点有稀疏和稠密之分。这时候如果平均采样那么会在空间中点稀疏的地方造成浪费，在点密集的地方却不足以提取到足够的信息。为此 PointNet++ 作者提出了两种方式来保证更加优化的特征提取。</p><p><img src="https://pic1.zhimg.com/80/v2-5389688194b56daf0311e926360f8e6c_1440w.jpg" alt></p><h3 id="多尺度组合-multi-scale-grouping-MSG"><a href="#多尺度组合-multi-scale-grouping-MSG" class="headerlink" title="多尺度组合 (multi-scale grouping, MSG)"></a>多尺度组合 (multi-scale grouping, MSG)</h3><p>对于同一个点多次采用不同的Grouping，过PointNet之后将特征 concat，增加了很多计算量，耗时。</p><h3 id="多分辨率组合（multi-resolution-grouping-MRG）"><a href="#多分辨率组合（multi-resolution-grouping-MRG）" class="headerlink" title="多分辨率组合（multi-resolution grouping, MRG）"></a>多分辨率组合（multi-resolution grouping, MRG）</h3><p>相当于多层之间采用了不同的分辨率，先用小的grouping通过两层正常提取出的特征，和一次大的grouping提取出的特征进行一个concat，组合了两种分辨率的信息。</p><hr><h2 id="实验效果"><a href="#实验效果" class="headerlink" title="实验效果"></a>实验效果</h2><p><img src="https://s3.ax1x.com/2020/12/08/rpkt39.png" alt></p><p>从实验效果上我们可以看出其准确率明显好于单一的PointNet，并且在使用了 MSG 和 MRG 后对于大量点集的鲁棒性明显提升了。</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PointNet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>素数筛法 (2020-12-7)</title>
    <link href="/2020/12/07/DS/DataStructureNote2/"/>
    <url>/2020/12/07/DS/DataStructureNote2/</url>
    
    <content type="html"><![CDATA[<h1 id="素数筛法"><a href="#素数筛法" class="headerlink" title="素数筛法"></a>素数筛法</h1><p>我们今天来讲讲筛法，今天上机出其不意的考了一手筛法，我居然天真的在写暴力素数判断。所以今天就来复习(重学)一下筛法。</p><p>如果我们想要判断一个数是否是素数有什么方法呢？ 暴力判断肯定是最容易想到的方法，按定义素数不能被1和其自身以外的数整除，我们自然会想到从 x - 1到2全判一遍的算法。但显然，我们做了很多重复的工作。</p><p>实际上我们可以发现，如果我们判断出了一个素数，那么它的倍数显然就不可能是素数，这样就可以直接将其开除“素籍“，踢出待选区域。这种筛选素数的方法就像一个筛子，每碰到一个素数就筛掉一批非素数，大大降低了复杂度。</p><p><img src="https://images2015.cnblogs.com/blog/927750/201612/927750-20161229220529101-1487746442.png" alt></p><h2 id="埃拉托斯特尼筛法"><a href="#埃拉托斯特尼筛法" class="headerlink" title="埃拉托斯特尼筛法"></a>埃拉托斯特尼筛法</h2><p>按上述思想写出代码，就是埃氏筛法。</p><ul><li>代码实现</li></ul><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Eratosthenes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i)         is_prime[i] = <span class="hljs-number">1</span>;    is_prime[<span class="hljs-number">0</span>] = is_prime[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)     &#123;        <span class="hljs-keyword">if</span> (is_prime[i]) <span class="hljs-comment">// 直接从2开筛不会放进来一个非素数</span>        &#123;            prime[p++] = i;             <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)i * i &lt;= n)                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * i; j &lt;= n; j += i)                    <span class="hljs-comment">// 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i 的 i倍开始，提高了运行速度</span>                    is_prime[j] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 是i的倍数的均不是素数</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> p;&#125;</code></pre><h3 id="复杂度计算"><a href="#复杂度计算" class="headerlink" title="复杂度计算"></a>复杂度计算</h3><p>关于埃氏筛法的复杂度计算，我们来做一个推导，首先我们可以看出每次循环中，若当前素数是p，那么单次循环执行 n/p 次， 所以总的表达式就是 n 乘上所有素数的倒数和 $n\sum_{p} \frac{1}{p}$</p><p>关于所有素数的倒数和，在欧拉相关的论文中有明确的估计。</p><script type="math/tex; mode=display">\sum_{p\le x} \frac{1}{p} = \ln\ln(x) + \gamma + \sum_{m = 2}^{\infty}{\mu (m){\frac{\zeta(m)}{m} + \delta}}</script><p>论文链接 [<a href="https://arxiv.org/pdf/math/0504289.pdf">https://arxiv.org/pdf/math/0504289.pdf</a>]</p><p>可知埃氏筛法的复杂度为 $O(nloglogn)$</p><hr><h2 id="欧拉筛法-（线性筛）"><a href="#欧拉筛法-（线性筛）" class="headerlink" title="欧拉筛法 （线性筛）"></a>欧拉筛法 （线性筛）</h2><p>TODO</p>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Number theory</tag>
      
      <tag>Multiplication algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PointNet论文阅读</title>
    <link href="/2020/12/06/Research/PointNet/"/>
    <url>/2020/12/06/Research/PointNet/</url>
    
    <content type="html"><![CDATA[<h3 id="PointCloud"><a href="#PointCloud" class="headerlink" title="PointCloud"></a>PointCloud</h3><p>何谓点云，点云数据和普通的照片又有什么不同？实际上点云并非什么高深的东西，下图就是一张点云的可视化数据。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1607249767189&amp;di=e4964b8b875326b97e5ab06da6196601&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fq_70%2Cc_zoom%2Cw_640%2Fimages%2F20180118%2F537a4b5eab09459881f9bc6ca18834f9.jpeg" alt="点云街道"></p><ul><li><strong>位置信息</strong><br>不同于原先2D的图像，每个像素点仅有RGB信息，点云自带了欧式空间中的位置信息，即坐标(x,y,z) 之后会附带一些RGB灰度值之类的普通图像像素就具有的东西。</li></ul><p>了解了点云之后我们来解析一下PointNet这篇论文[1]</p><hr><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>不同于当时许多处理3D点云任务时，直接将3D点云转化成体素矩阵(Voxel grid)的方式，但由于3D空间不同于2D大量的空间里都是空的(zero grid)，将他们全部体素化会造成不必要的浪费。PointNet可以<strong>直接输入点云</strong>信息，来解决这一问题，同时避免一些转换中造成的其他问题。</p><h3 id="点云数据的特点"><a href="#点云数据的特点" class="headerlink" title="点云数据的特点"></a>点云数据的特点</h3><p><strong>1. 无序性 （Unordered）</strong><br>我们都知道在欧式空间的度量中点和点之间是不存在像一维二维空间中的序关系的。(可能不严谨，数学不太好，暂时就这样理解)<br>对于点云数据信息，每个点<strong>喂入的顺序不应当影响到结果</strong></p><p><strong>2. 局部相关性 (Interaction among points)</strong><br>我们知道在<strong>空间中的点和其周边点之间的位置关系信息是有意义的</strong>，它代表了物体的形状特征。这正是我们在2D CNN工作中卷积层所提取的东西，因而我们要保留这个特征信息。</p><p><strong>3. 不变性 （Invariance under transformation）</strong><br>对于点云数据应该满足一些<strong>空间变换的不变性</strong>，例如平移和旋转，这些都不会影响最终的结果</p><p>PointNet的工作就是尝试解决这三个问题。</p><hr><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="https://pic1.zhimg.com/80/v2-8dc76710bd09c25d5c8196d6aff56fec_1440w.jpg" alt></p><p>我们看一下 PointNet 的网络架构，首先喂入原始的 PointNet，是一个 $N\times 3$ 的矩阵(n个点,xyz)先通过一个 $T-Net$ 层进行对齐，然后用感知机 mlp 进行特征提取，装换到 $N\times 1024$ 1024维空间上再进行 Max Pooling 提取出 Global feature，然后就干自己该干的事去了，对分类任务，将全局特征通过mlp来预测最后的分类分数；对分割任务，将全局特征和之前学习到的各点云的局部特征进行串联，再通过mlp得到每个数据点的分类结果。<br>下文会展开更详细的讲解</p><h3 id="解决无序性-symmetry-function"><a href="#解决无序性-symmetry-function" class="headerlink" title="解决无序性 (symmetry function)"></a>解决无序性 (symmetry function)</h3><p>对于无序性 PointCloud 数据的处理当时一般有三种方法，</p><ul><li>1）对数据进行排序成 canonical order. </li></ul><p>对于这种方法，其实不存在一种高维空间的排序。由于CNN中数据抽象纬度很高，要保证高维中的点向一维的稳定映射无关数据顺序是十分困难的，所以其效果有限。</p><ul><li>2) 用大量打乱数据序列训练一个 RNN，寄希望于这种方式能消除顺序依赖</li></ul><p>这种方法看上去可行，然而其仍然无法做到完全顺序无关，在[2]中有详细证明。实验表示，这种方法对于小型数据具有一定鲁棒性，但对于大量point的场景仍然表现疲软。</p><p><strong>3) 通过一个简单的对称函数来处理每个点，获得每个点的 Global signature</strong></p><p>这是本文所使用的方法，很简单却很有效，我们知道一个symmetry function 的输出是无关顺序的, 例如我们熟悉的加法和乘法，这里选用了CNN中常用的 max 函数作为 symmetry function，通过 max pooling 消除数据顺序的影响。</p><p><img src="https://s3.ax1x.com/2020/12/08/rpks4e.png" alt></p><p>$f$ 这个函数输出一个数据不依赖的值作为该组数据的 <em>Global signature</em> 每一个输入值 $x_{1\to n}$ 是PointCloud中的点，带有 (x,y,z)位置信息以及一些rgb信息，组成共 $NxN$ 的矩阵，$h$ 是一个变换方程，将 $1\times N$的向量转换为 $1\times K$，然后 $g$ 就是我们的 symmetry function 将 $N\times K$ 的矩阵映射到一个值 $R$ 就能够代表这组数据，因为 symmetry function 的顺序无关性，我们能够保证这个值对于相同数据的不同排列是相同的。</p><hr><h3 id="局部和全局数据聚合-Local-and-Global-Information-Aggregation"><a href="#局部和全局数据聚合-Local-and-Global-Information-Aggregation" class="headerlink" title="局部和全局数据聚合 (Local and Global Information Aggregation)"></a>局部和全局数据聚合 (Local and Global Information Aggregation)</h3><p>这边先讲一下我自己的想法，我很怀疑它到底有没有做局部信息的处理，既解决第二个问题，据PointNet这篇文章自己写的这一章，他说他做了。然后后面PointNet++ 说他没做。我这段看的也比较迷惑，但我个人倾向于原作者尝试去做但做的比较弱。</p><h3 id="理论证明可行性-Theory-Analysis"><a href="#理论证明可行性-Theory-Analysis" class="headerlink" title="理论证明可行性 (Theory Analysis)"></a>理论证明可行性 (Theory Analysis)</h3><p><img src="https://pic3.zhimg.com/80/v2-1bee125c29ac11faba0e0a095207a396_1440w.jpg" alt="拟合可行性"></p><p>这个定理说我们通过之前讲的 $h$ 和 Max pooling 操作能够拟合任意的连续集合函数 $f$<br>最坏的拟合就是将其转换成空间中的体素，但通常来说我们的神经网络在调校的过程中都会得到更好的 $h$ 来完成这一过程。</p><p>TODO: 详细证明过程在附录中我还没看</p><p><img src="https://pic1.zhimg.com/80/v2-43d9f406855cf5e4681cb3de08382b80_1440w.jpg" alt="扰动下的鲁棒性"></p><p>定理二告诉了我们该模型在扰动之下具有鲁棒性，只要不影响关键点集 $C_S$，或者超出最密上限点集 $N_s$ 该模型所得出的 Global signature 都是相同的，(2) 指出关键点集的上限在于我们的转换函数 $h$ 转换的维数 $K$</p><p>对于定理二原论文中有直观的图解帮助大家构造 intuition<br><img src="https://pic2.zhimg.com/80/v2-c1fc6e865ab685dcaefd18e8c063bef1_1440w.jpg" alt></p><p>最后的结果在当时看来是非常不错的。<br><img src="https://s3.ax1x.com/2020/12/08/rpk2jI.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PointNet 开创了3D点云的新纪元，日后的PointNet++，PointCNN等网络都是在其基础上发展起来的，作为点云的奠基其用十分简单的方式解决了3D点云数据的顺序 (symmetry function) 和空间不变性 (high demension). 但它没有很好的解决 Local 数据的关系，这一问题会在PointNet++中得到解决。</p><p>最后说点自己的话，感觉现在读论文并不是很静得下心来，读的也很笼统不深入，被太多乱七八糟的事情困扰心烦意乱。但事情总得做下去，状态是在做事的过程中一点点找回来的，干等等不来。注重积累一点点来，相信自己在不久的将来能够做出一点自己的东西。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] PointNet论文链接：<a href="https://arxiv.org/abs/1612.00593">https://arxiv.org/abs/1612.00593</a><br>[2] O. Vinyals, S. Bengio, and M. Kudlur. Order matters: Sequence to sequence for sets. arXiv preprint arXiv:1511.06391, 2015.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PointNet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构笔记 (2020-11-30 ~ 2020-12-05)</title>
    <link href="/2020/12/05/DS/DataStructureNote1/"/>
    <url>/2020/12/05/DS/DataStructureNote1/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构-DataStructure"><a href="#数据结构-DataStructure" class="headerlink" title="数据结构 - DataStructure"></a>数据结构 - DataStructure</h1><p>数据结构这周依然是树上操作，课上学了AVL树，然后讲了之前用过的Hash，然后作业里面主要学会了LCA的倍增和不太熟练的欧拉序RMQ，最后学会了并查集的使用（就可以学最后的Tarjan LCA算法了) ，然后这周作业题主要是并查集，带有一道树上差分算法。</p><hr><h2 id="LCA-问题"><a href="#LCA-问题" class="headerlink" title="LCA 问题"></a>LCA 问题</h2><p>LCA (Least Common Ancestors) 最近公共祖先问题，顾名思义既要找到两个节点最近的公共祖先，朴素做法是，两个节点中深的那个节点向上跳，直到两个节点深度相同，两个节点再同时向上跳（询问父节点）如果他们跳到最后的父节点是同一个那么这个节点就是他们的最近公共祖先。</p><p>这种朴素的算法很好思考，但复杂度也是很高的，单次询问时间复杂度 O(n) 因为最坏要把所有节点都跳一遍。</p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1414039454,330983716&amp;fm=26&amp;gp=0.jpg" alt></p><h3 id="LCA-倍增算法"><a href="#LCA-倍增算法" class="headerlink" title="LCA - 倍增算法"></a><strong>LCA - 倍增算法</strong></h3><p>倍增算法是LCA的经典算法，如同二分算法的本质一样，都是通过每次尽量把问题规模缩减2的幂次，从而达到 O(lgn) 的时间复杂度。</p><p>我们简单讲解一下，倍增算法就是我不再像朴素算法一样一个个往上跳，我直接跳2的幂次，从大到小枚举，如果符合题意就跳，直到 2^0 跳一个节点，这样一次遍历下来，总能覆盖所有情况而满足题意跳到要跳的地方，但复杂度却大大降低减为 O(lgn)</p><ul><li>代码实现<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span></span><span class="hljs-function"></span>&#123;    up[u][<span class="hljs-number">0</span>] = fa;  <span class="hljs-comment">// 预处理父亲</span>    dep[u] = dep[fa] + <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v : tree[u])    &#123;        <span class="hljs-keyword">if</span>(v == fa)            <span class="hljs-keyword">continue</span>;        dfs(v, u);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; k) &lt;= n; ++k)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)            up[i][k] = up[up[i][k - <span class="hljs-number">1</span>]][k - <span class="hljs-number">1</span>];             <span class="hljs-comment">// 预处理所有的上跳</span>            <span class="hljs-comment">// 状态转移方程 跳 2^k 步，等于先跳2^k-1步再往上跳2^k-1步</span>            <span class="hljs-comment">// 2 ^ k = 2 ^ (k - 1) + 2 ^ (k - 1)</span>&#125;   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(dep[x] &lt; dep[y])        swap(x, y); <span class="hljs-comment">// 让深度大的为x</span>    <span class="hljs-keyword">if</span>(dep[x] != dep[y])    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">31</span>; k &gt;= <span class="hljs-number">0</span>; --k)        &#123;            <span class="hljs-keyword">if</span>(dep[up[x][k]] &gt;= dep[y])                x = up[x][k];   <span class="hljs-comment">// 调整为同一深度</span>        &#125;    &#125;    <span class="hljs-keyword">if</span>(x == y)        <span class="hljs-keyword">return</span> x;           <span class="hljs-comment">// 如果一个是另外一个的长辈那么这时候两个直接就相等了，直接返回</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">31</span>; k &gt;= <span class="hljs-number">0</span>; --k)    &#123;        <span class="hljs-keyword">if</span>(up[x][k] != up[y][k])    <span class="hljs-comment">// 同时上跳不过头</span>        &#123;            x = up[x][k];               y = up[y][k];        &#125;    &#125;    <span class="hljs-keyword">return</span> up[x][<span class="hljs-number">0</span>];    <span class="hljs-comment">// 最后 lca 就是里面任意一个的父亲</span>&#125;</code></pre></li></ul><hr><h3 id="LCA-欧拉序RMQ算法"><a href="#LCA-欧拉序RMQ算法" class="headerlink" title="LCA - 欧拉序RMQ算法"></a><strong>LCA - 欧拉序RMQ算法</strong></h3><p>这边涉及到RMQ问题，我们就先来讲一讲RMQ问题。</p><ul><li><em>RMQ 问题</em><br>RMQ 是英文 Range Maximum/Minimum Query 的缩写，表示区间最大（最小）值。</li></ul><p>RMQ问题一般可以使用单调栈、ST表、线段树来解决</p><p>通过欧拉序将LCA问题转为RMQ问题后，我们一般使用ST表来解决RMQ问题。因为ST表在时间复杂度上表现优秀，需要 O(nlgn)的预处理，就能做到O(1)的询问。而写起来又较为简单，不像线段树一样复杂。可以处理大部分不需要在线修改的 RMQ 问题。</p><p>另一方面如果我们使用单调栈和线段树在单次询问的时间复杂度仍然是 O(lgn) 级别的本没有做到比倍增算法更优，但在代码方面却比倍增算法更为复杂，因而我们选择ST表进行处理。</p><h3 id="ST表-Sparse-table"><a href="#ST表-Sparse-table" class="headerlink" title="ST表 - Sparse table"></a><strong>ST表 - Sparse table</strong></h3><p>我们说 ST 表可以用来解决可重复贡献问题，因为ST表涉及到区间重叠，我们要保证区间重叠不会影响到我们要求的问题。所以ST表只能解决可重复贡献问题，例如最值和gcd。</p><p>ST表运用的也是倍增的思想，通过倍增区间覆盖来解决问题。</p><pre><code class="hljs cpp"><span class="hljs-comment">// ST表</span><span class="hljs-keyword">int</span> f[Max][lgn], Logn[Max], a[Max];<span class="hljs-comment">// f[i][k] 表示区间 i ~ i + 2^k - 1 的最值</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Logn[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; Max; ++i)        Logn[i] = Logn[i / <span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 状态转移：</span>    <span class="hljs-comment">// 前者表示 i ~ i + 2^(k - 1) - 1 的区间最值</span>    <span class="hljs-comment">// 后者表示 i + 2^(k - 1) ~ i + 2^k - 1 的区间最值</span>    <span class="hljs-comment">// 合并即为 i ~ i + 2^k - 1的区间最值</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preSet</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)        f[i][<span class="hljs-number">0</span>] = a[i]; <span class="hljs-comment">// 显然 f[i][0] = a[i]</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; lgn; ++k)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>)) &lt;= n; ++i)            f[i][k] = max(f[i][k - <span class="hljs-number">1</span>], f[i + (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>))][k - <span class="hljs-number">1</span>]);&#125;<span class="hljs-comment">// 查询操作：</span>    <span class="hljs-comment">// 如果我们要查询 区间 l ~ r 的最值, 我们根据ST表性质知道</span>    <span class="hljs-comment">// f[i][k] 表示 l ~ l + 2^k - 1 的区间最值</span>    <span class="hljs-comment">// r - 2^k + 1 ~ r 的区间最值就可以用 f[r - 1 &lt;&lt; k + 1][k] 表示</span>    <span class="hljs-comment">// 那么我们需要这两个区间覆盖整个查询区间且不超过</span>    <span class="hljs-comment">// 则 l + 2^k - 1 &gt;= r - 2^k + 1 且 l + 2^k - 1 &lt;= r 且 r - 2^k + 1 &gt;= l</span>    <span class="hljs-comment">// 则 k &gt;= lg(r - l + 2) - 1 且 k &lt;= floor(lg(r - l + 1));</span>    <span class="hljs-comment">// 我们直接取 k == floor(lg(r - l + 1))</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> k = Logn[r - l + <span class="hljs-number">1</span>];    <span class="hljs-keyword">return</span> max(f[i][k], f[r - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]); <span class="hljs-comment">// O(1) 查询</span>&#125;</code></pre><p>这样一个ST表就写好了，回到正题，我们是通过欧拉序把 LCA问题转换为RMQ问题，我们现在来看这是如何进行的。</p><p>在看欧拉序之前我们先看一看基本的 dfs 序是怎么做的（真就递归学习呗）</p><p><img src="https://img-blog.csdnimg.cn/20191008210415266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3djeHlreQ==,size_16,color_FFFFFF,t_70" alt="dfs序"></p><p>正常的dfs序是深度优先不记录回溯的，如上图 dfs 序就是<br><strong>A-&gt;B-&gt;D-&gt;E-&gt;G-&gt;C-&gt;F-&gt;H</strong><br>每个节点在dfs序中出现且仅出现一次</p><p>而我们再来看欧拉序</p><p><img src="https://img-blog.csdnimg.cn/20191008210445328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3djeHlreQ==,size_16,color_FFFFFF,t_70" alt="欧拉序"></p><p>它不同于dfs序将栈pop的元素也加入队列中，从而就形成了上图“逆时针”的模式<br>上图欧拉序就是<br><strong>A-&gt;B-&gt;D-&gt;B-&gt;E-&gt;G-&gt;E-&gt;B-&gt;A-&gt;C-&gt;F-&gt;H-&gt;F-&gt;C-&gt;A</strong><br>一种intuition就是欧拉序是一种正常人走路遍历所有节点的顺序，只要叶节点大于2个的树就不可能是欧拉图或半欧拉图，那么必然要走回头路，在dfs序的基础上将回头路线画出就是欧拉序。</p><p>我们来观察欧拉序可以发现，其首尾必然是根节点，然后除了叶节点仅出现一次，其余点出现2次以上(取决于是几叉树)，如果我们默认是二叉树，那么欧拉序的大小就不会超过 2n - 1 (考虑单链或就两叉到底的最坏情况)</p><p>如果我们在欧拉序节点旁配上它的深度再结合图来观察<br><strong>A(0)-&gt;B(1)-&gt;D(2)-&gt;B(1)-&gt;E(2)-&gt;G(3)-&gt;E(2)-&gt;B(1)-&gt;A(0)-&gt;C(1)-&gt;F(2)-&gt;H(3)-&gt;F(2)-&gt;C(1)-&gt;A(0)</strong><br>我们根据欧拉序的性质不难发现一个节点的左右子树必然夹在其在欧拉序中第二次出现的位置的左右两边，例如 B 的 左右子树 D, E 出现在B第二次出现位置[3]的两边[2]、[4]。<br>那么我们想如果我们找，两个节点的 LCA 就直接找两个节点第一次出现的位置，将其作为区间左右，在中间找深度最小的点就行了，这样找到的一定就是他们的LCA (不可能找到更浅的祖先) 。 当然其中包含了左边一个节点的子树，但为了方便我们就统一取第一次出现的位置即可。</p><p>这样我们就在线性的时间内将LCA问题转化成了RMQ问题，然后通过之前O(nlgn)的预处理我们可以做到 O(1)的询问，这样LCA问题的总复杂度就是ST表预处理的 O(nlogn) 的复杂度。</p><p>似乎总体没有比倍增更优，但单次询问比倍增快了很多，适合需要及时快速反馈的应用场景。</p><ul><li>代码实现</li></ul><pre><code class="hljs cpp"><span class="hljs-comment">// get eula array</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa, <span class="hljs-keyword">int</span> level)</span></span><span class="hljs-function"></span>&#123;    pos[u] = cnt_2;    find_u[cnt_2++] = u;    dep[u] = level;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; i != <span class="hljs-number">-1</span>; i = e[i].nex)    &#123;        <span class="hljs-keyword">int</span> v = e[i].v;                <span class="hljs-comment">// 欧拉序，回溯也放入</span>        pos[v] = cnt_2;        find_u[cnt_2++] = v;        dep[v] = level + <span class="hljs-number">1</span>;        dfs(v, u, level + <span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ST</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// Preset Log</span>    Logn[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)        Logn[i] = Logn[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)        f[i][<span class="hljs-number">0</span>] = find_u[i];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= logn; ++j)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)            f[i][j] = dep[f[i][j - <span class="hljs-number">1</span>]] &lt; dep[f[i + (j &lt;&lt; <span class="hljs-number">1</span>)][j - <span class="hljs-number">1</span>]] ? f[i][j - <span class="hljs-number">1</span>] : f[i + (j &lt;&lt; <span class="hljs-number">1</span>)][j - <span class="hljs-number">1</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l = pos[u], r = pos[v];    <span class="hljs-keyword">int</span> j = Logn[r - l + <span class="hljs-number">1</span>];    <span class="hljs-comment">// 直接找区间最小深度的节点</span>    <span class="hljs-keyword">int</span> ans = min(f[l][j], f[r - (<span class="hljs-number">1</span> &lt;&lt; j) + <span class="hljs-number">1</span>][j]);    <span class="hljs-keyword">return</span> pos[ans];    <span class="hljs-comment">// 返回节点位置...</span>&#125;</code></pre><hr><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>再来讲讲这周学的并查集</p><p>并查集顾名思义支持且仅支持两种操作</p><ol><li>合并两个集合</li><li>查询元素所在的集合</li></ol><p>并查集是一种树上的操作，通过根节点直接代表整棵树，初始化的时候根节点父节点为自身。</p><ul><li>合并操作</li></ul><p>合并操作相对比较简单，由于我们通过根节点来代表这个集合，那么合并两个集合只需要将其中一个的根节点作为另一个的子节点连接上即可。但同时我们要注意整棵树的深度会影响我们的时间复杂度，因而我们要尽可能不加深或是少加深树的深度，所以我们采用将深度较小的树连接到深度较大的树上，每次这样操作，树深度每次至多 +1，这种策略称之为<strong>按秩合并（启发式合并）</strong></p><p><img src="https://oi-wiki.org/ds/images/dsu1.png" alt></p><ul><li>代码</li></ul><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unionSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> tmp_x = find(x);    <span class="hljs-keyword">int</span> tmp_y = find(y);    <span class="hljs-keyword">if</span>(tmp_x == tmp_y)  <span class="hljs-comment">// 本来就在同一集合中</span>        <span class="hljs-keyword">return</span>;     <span class="hljs-keyword">if</span>(sz[tmp_x] &gt; sz[tmp_y])        swap(tmp_x, tmp_y); <span class="hljs-comment">// 让 tmp_x 是深度小的集合</span>    fa[tmp_x] = tmp_y; <span class="hljs-comment">// 将 tmp_x 连接到 tmp_y 上</span>&#125;</code></pre><ul><li>查询操作</li></ul><p>我们来讲并查集关键的查询操作，并查集的查询操作给出一个节点，我们查询其父节点，如若其父节点不是自身就继续向上查询，直到查询到根节点（父节点为自身）返回根节点作为这个集合的代表。</p><p>我们不难看出这样的查询操作单次是 $O(n)$ 的，原因是我们每次查询都要走完完整的一条链，但是其实我们并不关心该节点的父节点是谁，我们只想知道其根节点是什么。所以我们可以直接让它的父节点直接是根节点，这样虽然在第一次操作的时候，我们还是要走完一条链，但之后该节点的父节点直接就是根节点。这种操作称为<strong>路径压缩</strong></p><p><img src="https://oi-wiki.org/ds/images/dsu2.png" alt></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(fa[x] == x)        <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> fa[x] = find(fa[x]); <span class="hljs-comment">// 路径压缩</span>&#125;</code></pre><ul><li><strong>复杂度分析</strong></li></ul><p>我们现在来分析一下复杂度，朴素算法毫无疑问单次操作是 $O(mn)$ 的<br>如果我们使用了路径压缩，在Tarjan大神的论文[1] 中给出了复杂度的证明，只使用路径压缩不使用按秩合并的最坏时间复杂度是 $O(mlogn)$ 已经满足大部分题的需求，所以一般只需要路径压缩就能过题。<br>在姚期智的论文 [2] 中，证明了只路径压缩的平均复杂度为 $O(m\alpha{(m,n)})$<br><em>注： $\alpha$ 是阿克曼函数的反函数，其增长极其缓慢，也就是说其单次操作的平均运行时间可以认为是一个很小的常数。</em></p><p>如果我们同时使用了路径压缩和按秩合并，那么我们可以做到 $O(m\alpha{(m,n)})$ 的最坏时间复杂度。相当于单次询问是常数级别复杂度。</p><p>Ackermann 函数</p><script type="math/tex; mode=display">A(m,n) =\left\{\begin{array}{l}    n + 1, \; m = 0 \\    A(m - 1, 1), m > 0 \;and\; n = 0 \\    A(m - 1, A(m, n - 1)),\;othercases\end{array}\right.</script><p>$A(4, 3)$ 大的惊人，其反函数增长就相对应慢的惊人，直接可看为常数</p><hr><h2 id="树上差分算法"><a href="#树上差分算法" class="headerlink" title="树上差分算法"></a>树上差分算法</h2><p>讲一下这周作业题里涉及到的树上差分算法<br>树上差分问题可以用树链剖分解决，但我目前还不太会，就写一下现在会一点的树上差分。</p><p>树上差分分为两种，边差分和点差分。</p><ul><li>边差分<br>考虑一个经典问题，<strong>给出两点x, y 将其路径上的边权加1，最后给出所有边权。</strong></li></ul><p><img src="https://s3.ax1x.com/2020/12/08/r99w60.png" alt="图源:https://www.cnblogs.com/zhwer/p/12800475.html"></p><p>我们看这张图，数组 c[k] 是差分数组只不过我们是自下而上加的，为不影响其他子树的结果，我们的统计在回溯过程中完成，因而是自下而上的，那么这个边权修改过程就可以看做是 c[x]++, c[y]++, 然后 根节点到lca(x, y)被加了两次，我们都要减去 c[lca(x, y)] -= 2</p><p>既然是差分那么对于权值的更新，我们就可以如同前缀和一样计算，这不过这里的”前缀”是所有的子树权值，我们将所有子树权值收集起来到父节点上。</p><ul><li>代码实现</li></ul><pre><code class="hljs cpp"><span class="hljs-comment">// 已求出差分数组c</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getAns</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span></span><span class="hljs-function"></span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; i != <span class="hljs-number">-1</span>; i = e[i].nex)    &#123;        <span class="hljs-keyword">int</span> v = e[i].v;        <span class="hljs-keyword">if</span>(v != fa)        &#123;            getAns(v, u);            c[u] += c[v] <span class="hljs-comment">// 收集子树权值更新c为原本数组</span>            <span class="hljs-comment">// 更新后的c就代表其和其父节点连接边的边权</span>        &#125;    &#125;&#125;</code></pre><ul><li>点差分<br>点差分和边差分差不多，但这回每个点都代表的是自己了。<br><img src="https://s3.ax1x.com/2020/12/08/r990XV.png" alt="图源:https://www.cnblogs.com/zhwer/p/12800475.html"></li></ul><p>和边差分不同的是，这回lca不需要减2了，因为每个点代表的就是自己，在统计的时候 x, y 路径上是有 lca(x, y) 的，因而只需要减去一次重复计算即可。但这边lca在计算”前缀和”的时候会 +1，差分数组某一地方值的变动会影响到后面所有的值（这就是差分数组的精髓和意义所在）但lca的父亲并不应该 +1 所以我们要将 c[fa[lca(x,y)]]— 这个过程之后，我们的差分数组就完成了。<br>最后自下而上的收集一下，就能得到所有节点的权值了。</p><ul><li>思想总结</li></ul><p>差分的思想就是将原来本不相干的值联系到了一起，把后面点的部分信息移到了前面的点中，形成了区间的覆盖，这种效果正好能够用于解决区间修改问题，避免了暴力算法对每个点都进行操作，很巧妙的思想。</p><hr><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>本周DS主要学习这些内容，AVL树很惭愧虽然上课讲了但还没有深入去看，线段树和树链剖分还不太会，树状数组也快忘记了。最近又重新听到了《蜗牛》这首歌，隔了这么多年，再听还是很感动。“历经的伤都不感觉疼”，“任风吹干流过的泪和汗，总有一天我有属于我的天。”<br>每周都在不断吸收新知识，很充实也很疲倦，每天都学到12点之后。就是希望能够在未来有一片自己的天。科研也在不断做，但进度很慢，时间分配越来越不够了，最近越来越感到拔尖班的藏龙卧虎，个个都是人才，让我感到了很大的压力。但就像《蜗牛》中说的即使我很慢，拖着重重的壳，只要我每天一步一步的向上爬，我总能触碰到那片属于我的蓝天。</p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]Tarjan, R. E., &amp; Van Leeuwen, J. (1984). Worst-case analysis of set union algorithms.<br>[2]Yao, A. C. (1985). On the expected performance of path compression algorithms. SIAM Journal on Computing, 14(1), 129-133.</p>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LCA</tag>
      
      <tag>UFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近期进展 (2020-11-15 ~ 2020-11-27)</title>
    <link href="/2020/11/27/Recent-Progress%20(2020-11-15%20~%202020-11-27)/"/>
    <url>/2020/11/27/Recent-Progress%20(2020-11-15%20~%202020-11-27)/</url>
    
    <content type="html"><![CDATA[<h1 id="最近进展"><a href="#最近进展" class="headerlink" title="最近进展"></a>最近进展</h1><p>近来比较忙，一直没时间写博客，就暂将这段时间的进展写作一个综述发在博客上</p><hr><h2 id="学业方面"><a href="#学业方面" class="headerlink" title="学业方面"></a><strong>学业方面</strong></h2><h3 id="数据结构-DataStructure"><a href="#数据结构-DataStructure" class="headerlink" title="数据结构 - DataStructure"></a>数据结构 - DataStructure</h3><p>数据结构这几周以来都是学的树相关的操作, 对树的相关操作进行了学习和进一步的探究</p><h4 id="已经掌握"><a href="#已经掌握" class="headerlink" title="已经掌握"></a>已经掌握</h4><h5 id="树的储存"><a href="#树的储存" class="headerlink" title="树的储存"></a>树的储存</h5><ol><li><p>邻接表形式</p><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; Tree[Max]</code></pre></li><li><p>链式前向星形式</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> v;    <span class="hljs-keyword">int</span> w;    <span class="hljs-keyword">int</span> nex;&#125;;edge e[Max];<span class="hljs-keyword">int</span> head[Max], cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// init -1</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span></span><span class="hljs-function"></span>&#123;    e[cnt].v = v;    e[cnt].w = w;    e[cnt].nex = head[u];    head[u] = cnt++;&#125;<span class="hljs-comment">//遍历方式</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; i != <span class="hljs-number">-1</span>; i = e[i].nex)</code></pre><blockquote><p>邻接表相比链式前向星更为动态，但有些阴间题会卡掉邻接表</p></blockquote></li></ol><hr><h5 id="深度优先搜索-dfs"><a href="#深度优先搜索-dfs" class="headerlink" title="深度优先搜索 (dfs)"></a>深度优先搜索 (dfs)</h5><p>基本原则是一种与广度优先搜索对立的，能搜到子节点就往子节点走的搜索方式，既“深度”优先，我们熟知的二叉树的前序和后序遍历都是深度优先搜索的一种。</p><ol><li><p>代码实现 (邻接表形式)</p> <pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v : tree[u])    &#123;        <span class="hljs-keyword">if</span>(v == fa)            <span class="hljs-keyword">continue</span>;        dfs(v, u)    &#125;&#125;</code></pre><p> 其中 dfs(v,u) 是 dfs 的精华， 指代如若没搜到叶节点那么则继续向深度搜索，这时候当前节点的子节点作为下一个节点，而当前节点成为其子节点的父节点，因而有从 dfs(u, fa) 到 dfs(v, u) 的向深度搜索</p></li><li><p>前序遍历 - PreOrder (先出根再出子节点)</p> <pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode* root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(!root)        <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, root-&gt;val);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> child : root-&gt;children)        preOrder(root-&gt;child)    <span class="hljs-comment">//递归子树</span>&#125;</code></pre></li><li><p>后序遍历 - PosOrder (先出子节点再出根)</p> <pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">posOrder</span><span class="hljs-params">(TreeNode* root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(!root)        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> child : root-&gt;children)        preOrder(root-&gt;child)    <span class="hljs-comment">//递归子树</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, root-&gt;val);&#125;</code></pre><p>通过两次 dfs 我们可以求树的直径，一次 dfs 到直径的端点，再一次求出直径长度。</p></li></ol><p>dfs 所使用的数据结构是栈，这种数据结构隐含在函数的递归调用中，而对于 bfs 所使用的数据结构是队列，我们就需要</p><hr><h5 id="广-宽-度优先搜索-bfs"><a href="#广-宽-度优先搜索-bfs" class="headerlink" title="广(宽)度优先搜索 (bfs)"></a>广(宽)度优先搜索 (bfs)</h5><p>bfs 不同于 dfs 是深度优先的搜索，bfs是将同层的节点全部搜索过后再进入到下一次，既注重 “广度” 的搜索模式</p><ol><li><p>代码实现 (邻接表形式)</p><pre><code class="hljs cpp">bfs(s) &#123;    q = <span class="hljs-keyword">new</span> <span class="hljs-built_in">queue</span>();    q.push(s), visited[s] = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">while</span> (!q.empty())     &#123;        u = q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v : tree[u])        &#123;            <span class="hljs-keyword">if</span> (!visited[v])             &#123;                q.push(v);                visited[v] = <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;&#125;</code></pre></li><li><p>层序遍历<br> 层序遍历就是一种典型的 bfs，先将同层的打印出来之后再深入一层，代码同上。当然也可以通过 dfs 实现层序这时候就要区分节点的层数</p></li></ol><pre><code class="hljs cpp"><span class="hljs-comment">//dfs版本层序</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa, <span class="hljs-keyword">int</span> level)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(level &gt; ans.size())        ans.emplace_back(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;())    ans[level - <span class="hljs-number">1</span>].emplace_back(u);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v : tree[u])    &#123;        <span class="hljs-keyword">if</span>(v == fa)            <span class="hljs-keyword">continue</span>;        dfs(v, u, level + <span class="hljs-number">1</span>)    &#125;&#125;</code></pre><hr><h5 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h5><p>树形dp，顾名思义是在树上进行的dp，在dfs或bfs的过程中进行动态更新。例如通过树形dp求树的直径</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span></span><span class="hljs-function"></span>&#123;    vis[x] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> d1 = <span class="hljs-number">0</span>, d2 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v : tree[u])    &#123;        <span class="hljs-keyword">if</span>(v == fa)            <span class="hljs-keyword">continue</span>;        tmp = dfs(v, u) + <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(tmp &gt; d1)        &#123;            d2 = d1;            d1 = tmp;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp &gt; d2)            d2 = tmp;        d = max(d, d1 + d2);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre><hr><h4 id="尚未熟练-TODO"><a href="#尚未熟练-TODO" class="headerlink" title="尚未熟练 - TODO"></a><strong>尚未熟练 - TODO</strong></h4><ol><li>LCA问题</li><li>树状数组</li><li>线段树</li><li>树链剖分</li></ol><hr><h3 id="计算机系统-ICS"><a href="#计算机系统-ICS" class="headerlink" title="计算机系统 - ICS"></a>计算机系统 - ICS</h3><p>最近布置了 y86-64 的 PJ，学习了 CPU 的顺序以及流水线设计模式，开始做PJ。</p><h4 id="PJ进展"><a href="#PJ进展" class="headerlink" title="PJ进展:"></a>PJ进展:</h4><h5 id="设计模式-C-with-Class"><a href="#设计模式-C-with-Class" class="headerlink" title="设计模式 - C with Class"></a>设计模式 - C with Class</h5><p>在面向过程的 Fetch -&gt; Decode -&gt; Execute -&gt; Memory -&gt; WriteBack 基础上套instr的类壳</p><h5 id="后端进度"><a href="#后端进度" class="headerlink" title="后端进度"></a>后端进度</h5><ol><li>完成了Prototype设计<ul><li>目前 CC 的 OF 有一点 BUG</li></ul></li><li>完成了 UniTest 的 Generater<ul><li>准备用宏改为 gtest 移植到cpp上</li></ul></li></ol><ul><li>TODO:<ol><li>完成 python 到 cpp 的移植</li><li>尝试添加寄存器</li><li>实现硬件栈</li></ol></li></ul><h5 id="前端进度"><a href="#前端进度" class="headerlink" title="前端进度"></a>前端进度</h5><p>TODO中，思考如何设计</p><ul><li>可选方案:<ol><li>Python 作为中间件用 jinja 模板替换</li><li>C++ 作为后端 js 前端接口（学习中）</li><li>CGI</li></ol></li></ul><hr><h2 id="科研进度-CNN"><a href="#科研进度-CNN" class="headerlink" title="科研进度 - CNN"></a>科研进度 - CNN</h2><h3 id="目前方向"><a href="#目前方向" class="headerlink" title="目前方向"></a>目前方向</h3><p>3D Instance Segmentation</p><h3 id="论文收集"><a href="#论文收集" class="headerlink" title="论文收集"></a>论文收集</h3><ol><li>(RDCNet)mini ResNet in 2d Instance Seg</li><li>Attention Based 3d instance segmentation</li><li>Learning Gaussian Instance Segmentation in Point Clouds</li><li>3D Sementic &amp; Instance Segmentation via Salient Point Clustering Optimization</li></ol><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ol><li>实现 ResNet Backbone</li><li>复现 Fast R-CNN &amp; Mask R-CNN</li></ol>]]></content>
    
    
    <categories>
      
      <category>Summary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Summary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS-Lab4.2 各种链接姿势</title>
    <link href="/2020/11/15/ICS/ICS_Lab3/"/>
    <url>/2020/11/15/ICS/ICS_Lab3/</url>
    
    <content type="html"><![CDATA[<h3 id="Task0-简单链接"><a href="#Task0-简单链接" class="headerlink" title="Task0 - 简单链接"></a>Task0 - 简单链接</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;some.h&quot;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    testPrint();    testPrint(<span class="hljs-number">5</span>);    notATest();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li><strong>错误分析</strong></li></ul><blockquote><p>我们可以看到main函数中调用了三个函数，全是外部的，在链接时，符号表会进行搜索匹配。我们再来看some.h中定义了哪些函数.</p></blockquote><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testPrint</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testPrint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>;</code></pre><blockquote><p>发现只有两个test函数,而没有notATest定义的函数，根据这个离谱的名字我们可以断定在cstdio中也没有同名函数。<br>所以最后符号表中没有匹配上，会引发链接错误。</p></blockquote><ul><li><strong>解决方法</strong></li></ul><blockquote><p>直接将 notATest() 注释掉, 再在 makefile 中使用<br><pre><code class="hljs css"><span class="hljs-selector-tag">g</span>++ <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> <span class="hljs-selector-tag">some</span><span class="hljs-selector-class">.cpp</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">main</span></code></pre></p></blockquote><hr><h3 id="Task1-链接与重复包含问题"><a href="#Task1-链接与重复包含问题" class="headerlink" title="Task1 - 链接与重复包含问题"></a>Task1 - 链接与重复包含问题</h3><ul><li><strong>解题过程</strong></li></ul><p>通过阅读代码，我们可以发现改题的代码会根据宏DEBUG是否被定义而有不同的行为，决定是否打印更加详细的内容</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;function0.h&quot;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func0</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-meta"># <span class="hljs-meta-keyword">ifdef</span> DEBUG</span>    printDebug(); <span class="hljs-comment">//打印debug信息 (详细操作在shared.cpp中)</span>    <span class="hljs-meta"># <span class="hljs-meta-keyword">else</span></span>    print(); <span class="hljs-comment">//打印正常信息</span>    <span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span>&#125;</code></pre><blockquote><p>根据题意，我们需要在 Makefile 中,对于要求的 main1 需要做一个相等的条件判断</p></blockquote><pre><code class="hljs makefile"><span class="hljs-section">main0:</span>    g++ main0.cpp function0.cpp function1.cpp shared.cpp -o main0debug = False<span class="hljs-section">main1:</span><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(debug)</span>,True) g++ main1.cpp -DDEBUG function0.cpp function1.cpp shared.cpp -o main1<span class="hljs-keyword">else</span>g++ main1.cpp function0.cpp function1.cpp shared.cpp -o main1<span class="hljs-keyword">endif</span></code></pre><p><em>值得注意的是，makefile中 if 语句前不能有 tab 或者空格</em></p><p><strong>Include 路径</strong><br><img src="https://s3.ax1x.com/2020/11/15/DFeVyt.png" alt></p><ul><li><strong>问题</strong></li></ul><ol><li>为什么两个function.h都引⽤了shared.h⽽没有出问题？本来有可能出什么问题。</li></ol><blockquote><p>因为 shared.h 中仅包含函数声明，而不包含函数的定义，因而不会有重定义问题。如果 #include shared.cpp 则会出现重定义问题。</p></blockquote><ol><li>如果把shared.h中注释掉的变量定义取消注释会出什么问题？为什么？</li></ol><blockquote><p>会出现变量重定义问题，由于全局变量 string 被两次 include 到func0 和 func1 中，最后被同时引用至 main 中，导致重定义。在符号表中产生冲突，报错。</p></blockquote><ol><li>通常使⽤shared.h中另外被注释掉的宏命令(#开头的那些⾏)来规避重复引⽤的⻛险，原理是什么？取消这些注释之后上⼀题的问题解除了吗？背后的原因是什么？</li></ol><blockquote><p>通过宏定义，在第一次 include 的时候定义宏为函数名，之后再次include 的时候由于已经 define 就不再次 include。这种方式的缺点是如果有已有宏名与函数名重复时，将会报错。使用 #pragama once 则是由c++编译器保证 include 一次，不会有宏名重复问题。</p><p>上题的问题并没有解决，因为FOO是全局变量，其赋了初值，被链接器标记为strong，被重复 include 到了 main 中，两个 strong 标记冲突报错。</p></blockquote><hr><h3 id="Task2-静态链接库"><a href="#Task2-静态链接库" class="headerlink" title="Task2 - 静态链接库"></a>Task2 - 静态链接库</h3><p>在这个 Task 中我们需要编译2个静态链接库，并链接3个静态链接库，完成编译。</p><p><strong>A Makefile</strong><br><pre><code class="hljs makefile"><span class="hljs-section">libA:</span>g++ -c A.cpp ar -r libA.a A.o</code></pre></p><blockquote><p>先用g++ -c编译出A.o可重定位目标文件，再通过 ar 命令编译静态链接库。（libC 同理）</p></blockquote><p><strong>Main Makefile</strong><br><pre><code class="hljs makefile">main : cd A &amp;&amp; make libAcd C &amp;&amp; make libCg++ main.cpp B/libB.a A/libA.a C/libC.a -o main</code></pre></p><blockquote><p>再 CD 入每个目录进行 make 编译， 最后把静态链接库进行链接。 </p></blockquote><ul><li><strong>静态库链接搜索路径顺序：</strong></li></ul><ol><li>ld会去找GCC命令中的参数-L</li><li>再找gcc的环境变量LIBRARY_PATH</li><li>再找内定目录 /lib /usr/lib /usr/local/lib </li></ol><ul><li><strong>问题</strong></li></ul><ol><li><p>若有多个静态链接库需要链接，写命令时需要考虑静态链接库和源⽂件在命令中的顺序吗？是否需要考虑是由什么决定的？</p><blockquote><p><strong>需要考虑</strong>，链接器在链接过程中按命令中输入的顺序进行符号表匹配，可以将这个匹配过程抽象的看作链接器在维护三个集合 E(待合并文件), U(被引用且尚未匹配), D（已匹配），根据顺序动态更新E, 和U,D, 最后如果 U 为空则正常整合 E 生成可执行文件，不然则报错有符号被引用了但未能匹配。所以如果我们的静态库都是相互独立的，那么顺序是没关系的。但如果互相依赖，那么我们必须保证在对某个符号的引用的库后，必然有一个库中存在对其的定义，不然则会报错。</p></blockquote></li><li><p>可以使⽤size main命令来查看可执⾏⽂件所占的空间，输出结果的每⼀项是什么意思？</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">text</th><th style="text-align:center">data</th><th style="text-align:center">bss</th><th style="text-align:center">dec</th><th style="text-align:center">hex</th><th style="text-align:center">filename</th></tr></thead><tbody><tr><td style="text-align:center">22721</td><td style="text-align:center">712</td><td style="text-align:center">288</td><td style="text-align:center">23721</td><td style="text-align:center">5ca9</td><td style="text-align:center">main</td></tr></tbody></table></div><ul><li><strong>text:</strong> 机器代码字节</li><li><strong>data:</strong> 包含静态变量和已经初始化的全局变量的数据段字节数大小</li><li><strong>bss:</strong> Block Started by Symbol (better save space) 存放程序中未初始化的全局变量的字节数大小，BBS段属于静态内存分配, 不占真实内存空间（仅占位符）</li><li><strong>dec:</strong> = test + data + bss</li><li><strong>hex:</strong> 16进制的dec</li><li><strong>filename:</strong> 顾名思义，文件名</li></ul><hr><h3 id="Task3-动态链接库"><a href="#Task3-动态链接库" class="headerlink" title="Task3 - 动态链接库"></a>Task3 - 动态链接库</h3><p>整体操作和上一个Task很像，只是链接的是动态链接库 .so</p><p><strong>A Makefile</strong><br><pre><code class="hljs makefile"><span class="hljs-section">libA:</span>g++ -fPIC -c A.cppg++ -shared -fPIC A.o -o libA.so</code></pre></p><blockquote><p>在 A 中先编译出 A.o 再用 -shared 编译出动态链接库 .so</p></blockquote><p><strong>Main Makefile</strong><br><pre><code class="hljs makefile">main : cd A &amp;&amp; make libAcd C &amp;&amp; make libCg++ main.cpp A/libA.so ./libB.so C/libC.so -o main</code></pre></p><blockquote><p>直接 cd 进去 make 出动态链接库后，再进行链接。</p></blockquote><ul><li><strong>问题</strong></li></ul><ol><li><p>动态链接库在运⾏时也需要查找库的位置，在Linux中，运⾏时动态链接库的查找顺序是怎样的？</p><blockquote><p><strong>动态链接时、执行时搜索路径顺序:</strong></p><ol><li>编译目标代码时指定的动态库搜索路径</li><li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</li><li>配置文件/etc/ld.so.conf中指定的动态库搜索路径</li><li>默认的动态库搜索路径/lib</li><li>默认的动态库搜索路径/usr/lib</li></ol></blockquote></li><li><p>使⽤size main查看编译出的可执⾏⽂件占据的空间，与使⽤静态链接库相⽐占⽤空间有何变化？哪些部分的哪些代码（也要具体到本task）会导致编译出⽂件的占⽤空间发⽣这种变化？</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">text</th><th style="text-align:center">data</th><th style="text-align:center">bss</th><th style="text-align:center">dec</th><th style="text-align:center">hex</th><th style="text-align:center">filename</th></tr></thead><tbody><tr><td style="text-align:center">3089</td><td style="text-align:center">720</td><td style="text-align:center">96</td><td style="text-align:center">3905</td><td style="text-align:center">f41</td><td style="text-align:center">main</td></tr></tbody></table></div><blockquote><p><strong>占用空间变小了</strong>，因为不同于静态链接库将所有的静态库都整合入可执行文件中，动态链接库是在程序开始或正在运行时被链接加载的，所有可执行文件本身的空间占用会大幅缩小。</p><p>main 中调用了 A, B, C 函数，所以其中的函数以及静态全局变量 A_name, B_name 会被被置于动态链接库.so中动态加载</p></blockquote><ol><li>编译动态链接库时-fPIC的作⽤是什么，不加会有什么后果？<br>-fPIC 含义是 Generate position-independent code (PIC)，例如在汇编的 jmp 语句中通常使用的是固定的内部地址<pre><code class="hljs angelscript"><span class="hljs-number">100</span>: COMPARE REG1, REG2<span class="hljs-number">101</span>: JUMP_IF_EQUAL <span class="hljs-number">111</span>...<span class="hljs-number">111</span>: NOP</code></pre><blockquote><p>而通过 -fPIC 参数 jmp 语句所指向的是相对地址<br>使用的是代码段和数据段的OFFSET，从而实现位置无关，可以动态加载到内存中，不同进程可以共享。</p></blockquote></li></ol><pre><code class="hljs angelscript"><span class="hljs-number">100</span>: COMPARE REG1, REG2<span class="hljs-number">101</span>: JUMP_IF_EQUAL CURRENT+<span class="hljs-number">10</span>...<span class="hljs-number">111</span>: NOP</code></pre><blockquote><p>如果不加，在某些系统下不会有很大的问题，但一般在 -shared 后面最好加上 -fPIC 来保证动态链接库是位置无关的，不然无法实现动态链接（由于位置相关即分配绝对内存地址，导致多个副本存在于内存中，无法实现动态链接）</p></blockquote><p><strong>info in gcc manual</strong></p><ul><li><strong>-shared:</strong>  Produce a shared object which can then be linked with other objects to forman executable. Not all systems support this option. For predictable results,<br>you must also specify the same set of options used for compilation (‘-fpic’,‘-fPIC’, or model suboptions) when you specify this linker option.*</li></ul><ol><li>现在被⼴泛使⽤的公开的动态链接库如何进⾏版本替换或共存（以linux系统为例）？</li></ol><blockquote><p>通过动态链接，如果开发者需要维护程序的某一部分（某几个功能的函数），仅需要维护修改所在的动态链接库即可，然后将其发布。用户只需要替换动态链接库，在程序运行的时候自然会动态链接到新的链接库，<strong>在接口保持不变</strong>的情况下完成很自然流畅的版本更新。</p></blockquote><hr><h3 id="Task4-ld手动链接"><a href="#Task4-ld手动链接" class="headerlink" title="Task4 - ld手动链接"></a>Task4 - ld手动链接</h3><ul><li><strong>解题过程</strong><br>这题要求我们用ld链接器，进行手动链接，我们先试一下直接链接会发生什么</li></ul><pre><code class="hljs makefile"><span class="hljs-comment">#链接代码</span>ld -o main main.o some.o</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">//报错信息</span>ld: warning: cannot find entry symbol _start; defaulting to <span class="hljs-number">00000000004000b</span>0some.o: In function `notATest()<span class="hljs-string">&#x27;:</span>some.cpp:(.text+0xc): undefined reference to `puts&#x27;some.o: In function `testPrint()<span class="hljs-string">&#x27;:</span>some.cpp:(.text+0x1f): undefined reference to `puts&#x27;some.o: In function `testPrint(<span class="hljs-keyword">int</span>)<span class="hljs-string">&#x27;:</span>some.cpp:(.text+0x52): undefined reference to `printf&#x27;Makefile:2: recipe for target &#x27;main&#x27; failedmake: *** [main] Error <span class="hljs-number">1</span></code></pre><blockquote><p>发现主要报错信息是 undefined reference to ‘puts’, ‘printf’, 说明标准库中的函数符号没有被成功匹配，我们需要把 stdc 加进去</p></blockquote><pre><code class="hljs makefile"><span class="hljs-comment"># 链接代码</span>ld -o main main.o some.o -lc<span class="hljs-comment"># 通过 -lc 命令直接添加标准库，也可以自行指定libc.so路径</span></code></pre><blockquote><p>可以发现main被成功编译出来，但运行时候发现bash报目录中无此文件<br><pre><code class="hljs bash">bash: ./main: No such file or directory</code></pre></p><p>也就是我们并不能运行这个可执行文件，查找资料之后我们尝试指定使用的动态链接器再进行编译，就可以运行了</p></blockquote><pre><code class="hljs makefile">ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o main main.o some.o -lc</code></pre><blockquote><p>我查询了ld的手册试图查找原因，但并未发现为什么必须要使用—dynamic-linker指令</p></blockquote><div style="page-break-after: always;"></div><ul><li><strong>—dynamic-linker=file</strong><blockquote><p>   Set the name of the dynamic linker.  This is only meaningful when generating dynamically linked ELF executables.  <strong>The default dynamic linker is normally correct; don’t use this unless you know what you are doing.</strong></p></blockquote></li></ul><blockquote><p>接下去，我们的程序虽然能够运行起来了，但在 main 函数跑完之后会出现 <em>Segmentation fault (core dumped)</em> 提示，这也提示了我们对于 main 函数的初始化和结束可能并未正常执行。</p></blockquote><ul><li><strong>GDB查看正常程序</strong></li></ul><p><img src="https://s3.ax1x.com/2020/11/15/DFeZOP.png" alt></p><blockquote><p>通过 gdb 查看正常程序我们发现，正常的 main 函数执行栈中需要有两个函数为其保证环境 <em>__lib_csu_init</em> 和 <em>__libc_start_main</em></p></blockquote><ul><li><strong>__libc_start_main</strong><br>我们需要知道，在linux中，main函数的初始化环境和参数传递以及返回值处理工作是由 __libc_start_main 来保证的。一个正常的程序执行需要包含以下要素。</li></ul><ol><li>performing any necessary security checks if the effective user ID is not the same as the real user ID.</li><li>initialize the threading subsystem.</li><li>registering the <em>rtld_fini</em> to release resources when this dynamic shared object exits (or is unloaded).</li><li>registering the <em>fini</em> handler to run at program exit.</li><li>calling the initializer function <em>(</em>init)()*.</li><li>calling <em>main()</em> with appropriate arguments.</li><li>calling <em>exit()</em> with the return value from <em>main()</em>.</li></ol><blockquote><p>具体的初始化和结束调用路径异常复杂，在此不多赘述，放一张图有待进一步研究。</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/15/DFemef.png" alt></p><p><em>图片来源: <a href="https://luomuxiaoxiao.com/?p=516">https://luomuxiaoxiao.com/?p=516</a></em></p><hr><p>然后介绍完了主函数的初始化和返回，我们需要知道保证上述的两个函数在哪个动态链接库中，这就涉及到了 <em>crt1.o, crti.o, crtbegin.o, crtend.o, crtn.o</em> 这几个库<br><em>参考： <a href="https://blog.csdn.net/farmwang/article/details/73195951">https://blog.csdn.net/farmwang/article/details/73195951</a></em></p><blockquote><p><strong>crt是c runtime 的缩写</strong>,用于执行进入main之前的初始化和退出main之后的扫尾工作。</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">目标文件</th><th style="text-align:center">crt1.o</th><th style="text-align:center">crti.o</th><th style="text-align:center">crtbegin.o</th><th style="text-align:center">crtend.o</th><th style="text-align:center">crtn.o</th></tr></thead><tbody><tr><td style="text-align:center">作用</td><td style="text-align:center">启动</td><td style="text-align:center">初始化</td><td style="text-align:center">构造</td><td style="text-align:center">析构</td><td style="text-align:center">结束</td></tr></tbody></table></div><blockquote><p>在标准的linux平台下,link的顺序是</p></blockquote><pre><code>ld crt1.o crti.o [user_objects] [system_libraries] crtn.o</code></pre><p>所以我们按照顺序进行链接有如下命令</p><pre><code class="hljs makefile"><span class="hljs-comment"># 链接指令</span>ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o main /usr/lib/x86_64-linux-gnu/crt1.o main.o some.o -lc /usr/lib/x86_64-linux-gnu/crti.o /usr/lib/x86_64-linux-gnu/crtn.o</code></pre><blockquote><p>成功的手动完成了程序的链接工作。</p></blockquote><p>以上艰苦的工作告诉我们，不要轻易尝试手动链接，除非你知道你在干什么。平时好好用 gcc。</p><ul><li>动态链接器⼀个操作系统中只需要⼀个吗？为什么？<blockquote><p>一般来说只要有一个支持的动态链接器即可，完成程序的动态链接工作。 但linux中可能有两个 ld 的版本</p></blockquote></li></ul><ol><li>ld.so针对a.out格式的二进制可执行文件</li><li>ld-linux.so针对ELF格式的二进制可执行文件</li></ol><p>a.out是旧版类Unix系统中用于执行档、目的码和后来系统中的函数库的一种文件格式，该版本的链接器仍被保留用以向前支持。</p><hr><h3 id="Task5-运行时打桩"><a href="#Task5-运行时打桩" class="headerlink" title="Task5 - 运行时打桩"></a>Task5 - 运行时打桩</h3><p>Task5 是一个典型的运行时打桩的 task，给了我们编译好的login程序，让我们改变其行为，让它能够输出 login_success.</p><blockquote><p>阅读源码，我们可以发现，login将我们输入的字符串做了hash，与已有某不明hash值，进行比较，如果相等则登陆成功。根据本 lab 的内容主要是讲 make 和链接的，让我们碰撞这个hash显然不是本意。那另一种方法就是通过运行时打桩，改变标准库的链接方式，让strcmp 链接到我们自己写的 strcmp 版本上去，从而我们可以控制其返回值让其返回0使得登陆成功。</p></blockquote><p><em>首先要注意 strcmp 并非只有判断密码时的一次唯一调用，在别处还有调用，所以我们要保证 strcmp 函数的基本功能正确</em><br><pre><code class="hljs cpp"><span class="hljs-comment">// mystrcmp.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;dlfcn.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *lhs, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *rhs)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span>(*strcmpp)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *lhs, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *rhs);    strcmpp = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;strcmp&quot;</span>);    <span class="hljs-keyword">char</span> tmp[] = <span class="hljs-string">&quot;3983709877683599140&quot;</span>;    <span class="hljs-keyword">if</span>(strcmpp(tmp, rhs) == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> strcmpp(lhs, rhs);&#125;</code></pre></p><blockquote><p>我们直接写一个自己的 strcmp 版本，用 dlsym 可以获取在运行时 strcmp 函数的指针 <em>（不这样做也可以，可以直接自己重写一遍strcmp程序）</em>，相当于可以直接使用 <strong>真实的标准库中的 strcmp</strong>，然后我们稍微改写一下，让它和我们的hash值比较的时候直接返回0，能够让我们不管输入什么密码都能够 login_success。</p></blockquote><p>接下来我们先将我们写的strcmp编译成动态链接库</p><pre><code class="hljs shell">gcc -shared -fpic -o mystrcmp.so mystrcmp.c -ldl</code></pre><blockquote><p>然后使用 <strong>LD_PRELOAD=”./mystrcmp.so”</strong> 指令，从而在 strcmp 动态链接到标准库之前让其优先匹配我们写的动态链接库中的 strcmp 符号。</p></blockquote><p>这里需要注意由于是要直接运行 ./login, 所以我们需要把LD_PRELOAD的效果全局化，也既在前面加上 export 标记。</p><pre><code class="hljs shell">export LD_PRELOAD=&quot;./mystrcmp.so&quot;</code></pre><p>最后注意不要忘记卸载全局 preload， 不然之后所有程序都 preload 这个strcmp。</p><pre><code class="hljs shell">export LD_PRELOAD=NULL</code></pre>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Training Neural Networks II 06</title>
    <link href="/2020/11/13/CS231n/CS231n-06-Training-Neural-Networks-II/"/>
    <url>/2020/11/13/CS231n/CS231n-06-Training-Neural-Networks-II/</url>
    
    <content type="html"><![CDATA[<h3 id="PreView"><a href="#PreView" class="headerlink" title="PreView"></a>PreView</h3><ul><li>Fancier optimization</li><li>Regularization</li><li>Transfer Learning</li></ul><hr><h3 id="Problem-with-SGD"><a href="#Problem-with-SGD" class="headerlink" title="Problem with SGD"></a>Problem with SGD</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9JOns.png" alt></p><blockquote><p>The zig-zag path reveal the drawbacks of SGD</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9JbcQ.png" alt></p><blockquote><p>Stuck in the local minima.</p></blockquote><ul><li>Saddle points much more common in high dimension.</li></ul><p><strong>Add an Momentum term may solve these problems</strong></p><p><img src="https://s3.ax1x.com/2020/11/13/D9JqXj.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9JXBn.png" alt></p><blockquote><p>Owing to the exsistance of momentum we can training more faster and overcome the problems mentioned before.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9JH1g.png" alt></p><ul><li><strong>Nesterov Momentum</strong></li></ul><script type="math/tex; mode=display">v_{t+1} = \rho{v_t}-\alpha{\nabla{f(x_t+\rho{v_t})}}\\x_{t+1} = x_t + v_{t+1}</script><p><img src="https://s3.ax1x.com/2020/11/13/D9Jj7q.png" alt></p><blockquote><p>some kind error correcting term of present v and the previous v</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9JzNV.png" alt></p><hr><h3 id="AdaGrad"><a href="#AdaGrad" class="headerlink" title="AdaGrad"></a>AdaGrad</h3><pre><code class="hljs python">grad_squared = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    dx = compute_gradient(x)    grad_squared += dx * dx    x -= learning_rate * dx / (np.sqrt(grad_squared) + <span class="hljs-number">1e-7</span>)</code></pre><blockquote><p>The basic idea about AdaGrad algorithm is that the step of dimention with smaller gradients will be divided by small vals and make it move faster, while greater one slower to avoid zig-zag behavior.</p><p>while the step will become smaller and smaller while you get closer to the minima, but in turn with higher risks to stuck in the local minima.</p></blockquote><hr><h3 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9JxA0.png" alt></p><blockquote><p>With a decay rate to make a smooth stop the reducing of steps.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9Y99U.png" alt></p><hr><h3 id="Adam-almost"><a href="#Adam-almost" class="headerlink" title="Adam (almost)"></a>Adam (almost)</h3><pre><code class="hljs python">first_moment = <span class="hljs-number">0</span>second_moment = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    dx = compute_gradient(x)    first_moment = beta1 + first_moment + (<span class="hljs-number">1</span> - beta1) * dx    <span class="hljs-comment"># Momentum</span>    second_moment = beta2 * second_moment + (<span class="hljs-number">1</span> - beta2) * dx * dx    <span class="hljs-comment"># AdaGrad / RMSProp</span>    x -= learning_rate * first_moment / (np.sqrt(second_moment) + <span class="hljs-number">1e-7</span>)</code></pre><blockquote><p>It combine the two methods, but with a little bug of the first step, which gonna be super large.</p></blockquote><h3 id="Adam-full-form"><a href="#Adam-full-form" class="headerlink" title="Adam (full form)"></a>Adam (full form)</h3><pre><code class="hljs python">first_moment = <span class="hljs-number">0</span>second_moment = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_iterations):    dx = compute_gradient(x)    first_moment = beta1 + first_moment + (<span class="hljs-number">1</span> - beta1) * dx    <span class="hljs-comment"># Momentum</span>    second_moment = beta2 * second_moment + (<span class="hljs-number">1</span> - beta2) * dx * dx    <span class="hljs-comment"># AdaGrad / RMSProp</span>    first_unbias = first_moment / (<span class="hljs-number">1</span> - beta1 ** t)    second_unbias = second_moment / (<span class="hljs-number">1</span> - beta2 ** t)    x -= learning_rate * first_unbias / (np.sqrt(second_unbias) + <span class="hljs-number">1e-7</span>)</code></pre><blockquote><p>Bias correction for the fact that first and second moment estimates start at zero</p></blockquote><ul><li>Great starting point</li></ul><ol><li>beta1 = 0.9</li><li>beta2 = 0.999</li><li>learning_rate = 1e-3 or 5e-4</li></ol><hr><h3 id="Decay-the-learning-rate-to-make-it-finer"><a href="#Decay-the-learning-rate-to-make-it-finer" class="headerlink" title="Decay the learning rate to make it finer"></a>Decay the learning rate to make it finer</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9YShT.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9YPc4.png" alt></p><hr><h3 id="little-bit-Fancier-Optimization"><a href="#little-bit-Fancier-Optimization" class="headerlink" title="little bit Fancier Optimization"></a>little bit Fancier Optimization</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9YC3F.png" alt></p><blockquote><p>First derivative optimization</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9YijJ.png" alt></p><blockquote><p>Second derivative optimization, direct to the mini</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9Yku9.png" alt></p><blockquote><p>Don’t need learning rate, but impractical for Hessian has O(N^2) elements and Inverting takes O(N^3)</p></blockquote><h4 id="Quasi-Newton-methods-BGFS"><a href="#Quasi-Newton-methods-BGFS" class="headerlink" title="Quasi - Newton methods (BGFS)"></a>Quasi - Newton methods (BGFS)</h4><p><img src="https://s3.ax1x.com/2020/11/13/D9YABR.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9YEH1.png" alt></p><hr><h3 id="In-Practice"><a href="#In-Practice" class="headerlink" title="In Practice:"></a>In Practice:</h3><ul><li>Using Adam</li><li>If full batch updates can be afforded, try out <strong>L-BFGS</strong></li></ul><hr><h3 id="Reduce-the-gap-between-train-and-unseen-data"><a href="#Reduce-the-gap-between-train-and-unseen-data" class="headerlink" title="Reduce the gap between train and unseen data"></a>Reduce the gap between train and unseen data</h3><h4 id="Model-Ensembles"><a href="#Model-Ensembles" class="headerlink" title="Model Ensembles"></a>Model Ensembles</h4><ol><li>Train multiple independent models</li><li>At test time average their results</li></ol><p>2% improvement maybe</p><p><img src="https://s3.ax1x.com/2020/11/13/D9YeN6.png" alt></p><blockquote><p>Instead of using actual parameter vector, keep a moving average of the para vector and use that at test time</p></blockquote><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    data_batch = dataset.sample_data_batch()    loss = network.forward(data_batch)    dx = network.backward()    x += - learning_rate * dx    x_test = <span class="hljs-number">0.995</span>*x_test + <span class="hljs-number">0.005</span>*x</code></pre><h4 id="Regularization-to-make-single-model-performs-better"><a href="#Regularization-to-make-single-model-performs-better" class="headerlink" title="Regularization to make single model performs better"></a>Regularization to make single model performs better</h4><ul><li>Dropout</li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9Ym4K.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9YK3D.png" alt></p><blockquote><p>Another interpretation is that you can percive each binary mask as a single model, so it just like dropout is training a large ensemble of models with shared paras.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9Yu9O.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9YMge.png" alt></p><h4 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h4><blockquote><p>Which can achieve the same effect as the Dropout, for it includes some noises.</p><h4 id="Data-Augmentation"><a href="#Data-Augmentation" class="headerlink" title="Data Augmentation"></a>Data Augmentation</h4><p>To introduce noise to make it performs better on unseen data.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9YQjH.png" alt></p><h4 id="Stochastic-Depth"><a href="#Stochastic-Depth" class="headerlink" title="Stochastic Depth"></a>Stochastic Depth</h4><blockquote><p>Randomly drop layers during training.<br>Use the full networks during testing.</p></blockquote><hr><h3 id="Transfer-Learning"><a href="#Transfer-Learning" class="headerlink" title="Transfer Learning"></a>Transfer Learning</h3><blockquote><p>There is no need for huge amount of data.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9Y1ud.png" alt></p>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Training Neural Networks I 05</title>
    <link href="/2020/11/13/CS231n/CS231n-05-Training-Neural-Networks-I/"/>
    <url>/2020/11/13/CS231n/CS231n-05-Training-Neural-Networks-I/</url>
    
    <content type="html"><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><ol><li>One time setup</li><li>Training dynamics</li><li>Evaluation</li></ol><h3 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h3><ul><li>Activation Functions</li><li>Data Preprocessing</li><li>Weight initialization</li><li>Batch Normalization</li><li>Babysitting the Learning Process</li><li>Hyperparameter Optimization</li></ul><hr><h3 id="Activation-Functions"><a href="#Activation-Functions" class="headerlink" title="Activation Functions"></a>Activation Functions</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9uofs.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9uIYj.png" alt></p><h4 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h4><script type="math/tex; mode=display">\sigma(x) = 1/(1+e^{-x})</script><ul><li>Squashes numbers to range [0,1]</li><li>Historically popular “firing rate” of a neuron</li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9uhTg.png" alt></p><p><strong>3 Problems</strong></p><ol><li>Saturated the neural may kill the gradient.</li></ol><p><img src="https://s3.ax1x.com/2020/11/13/D9u5kQ.png" alt></p><blockquote><p>x is a very negative and very positive val, its gradient will be killed to zero</p></blockquote><ol><li>Sigmoid outputs are not zero-centered</li></ol><p><img src="https://s3.ax1x.com/2020/11/13/D9u7pn.png" alt></p><blockquote><p>For the sign of x and gradient is always the same, it gonna behaves like is above pic.</p><p>thats why we need zero-mean data, to optimize the w just through the zig zag path.</p></blockquote><ol><li>exp() is a bit compute expensive</li></ol><hr><h4 id="Tanh"><a href="#Tanh" class="headerlink" title="Tanh"></a>Tanh</h4><ul><li>Squashes numbers to range [-1, 1]</li><li>zero centered (nice)</li><li>still kills gradients when saturated</li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9uHlq.png" alt></p><hr><h4 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h4><script type="math/tex; mode=display">f(x) = max(0, x)</script><p><img src="https://s3.ax1x.com/2020/11/13/D9ub60.png" alt></p><ul><li>Does not saturate (in + region)</li><li>Very computationally efficient</li><li>Converges much faster than sigmoid/tanh in practice</li><li>Actually more biologically plausible than sigmoid</li></ul><p><strong>Problems</strong></p><ol><li>Not zero-centered output</li><li>An annoyance:</li><li>when x &lt;= 0 the gradient is slashed to zero (kill half the gradient)</li></ol><p><img src="https://s3.ax1x.com/2020/11/13/D9uX0U.png" alt></p><ul><li>Bad Init</li><li>Learning rate too high</li></ul><blockquote><p>people like to initialize ReLU neurons with slightly positive biases (eg 0.01), to increase the possibility that being activated.</p></blockquote><hr><h4 id="Leaky-ReLu"><a href="#Leaky-ReLu" class="headerlink" title="Leaky ReLu"></a>Leaky ReLu</h4><script type="math/tex; mode=display">f(x) = max(0.01x,x)</script><p><img src="https://s3.ax1x.com/2020/11/13/D9uqXV.png" alt></p><ul><li>Does not saturated</li><li>Computationally efficient</li><li>Converges much faster …</li><li><strong>will not die</strong></li></ul><p>or <strong>Para Rectifier ReLu</strong></p><script type="math/tex; mode=display">f(x) = max(\alpha{x},x)</script><hr><h4 id="Exponential-Linear-Units-ELU"><a href="#Exponential-Linear-Units-ELU" class="headerlink" title="Exponential Linear Units (ELU)"></a>Exponential Linear Units (ELU)</h4><p><img src="https://s3.ax1x.com/2020/11/13/D9uOmT.png" alt></p><ul><li>All benefits of ReLU</li><li>Closer to zero mean outputs</li><li>Negative saturation regime adds some robustness to noise</li></ul><p><em>While it requires exp()</em></p><hr><h4 id="Maxout-“Neuron”"><a href="#Maxout-“Neuron”" class="headerlink" title="Maxout “Neuron”"></a>Maxout “Neuron”</h4><p><img src="https://s3.ax1x.com/2020/11/13/D9uj7F.png" alt></p><hr><h4 id="In-practice"><a href="#In-practice" class="headerlink" title="In practice"></a>In practice</h4><ul><li>Use ReLU. (zbe careful with learning rates)</li><li>Try Leaky <em>ReLU / Maxout / ELU</em></li><li>Don’t use sigmoid</li></ul><hr><h3 id="Data-Preprocessing"><a href="#Data-Preprocessing" class="headerlink" title="Data Preprocessing"></a>Data Preprocessing</h3><h4 id="Step1-Preprocess-the-data"><a href="#Step1-Preprocess-the-data" class="headerlink" title="Step1: Preprocess the data"></a>Step1: Preprocess the data</h4><p><img src="https://s3.ax1x.com/2020/11/13/D9uxk4.png" alt></p><ul><li>In CV we usually don’t normalize the data.</li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9KSh9.png" alt></p><p>Practice above make the data zero-mean, but only the first layer, and that’s why we need the activation func tobe zero-mean.</p><hr><h3 id="Weight-Initialization"><a href="#Weight-Initialization" class="headerlink" title="Weight Initialization"></a>Weight Initialization</h3><h4 id="First-idea-Small-random-numbers"><a href="#First-idea-Small-random-numbers" class="headerlink" title="First idea: Small random numbers"></a>First idea: Small random numbers</h4><pre><code class="hljs python">W = <span class="hljs-number">0.01</span>* np.random.randn(D,H)</code></pre><blockquote><p>Works Okay for small, but have problems in big one.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9KC11.png" alt></p><h4 id="How-about-making-Weight-big"><a href="#How-about-making-Weight-big" class="headerlink" title="How about making Weight big?"></a>How about making Weight big?</h4><p><img src="https://s3.ax1x.com/2020/11/13/D9KP6x.png" alt></p><blockquote><p>it gonna saturated the regime to be either very possitive or very negative input of tanh, and comes out near zero gradients. The weight will not be updated.</p></blockquote><h4 id="Xavier-initialization"><a href="#Xavier-initialization" class="headerlink" title="Xavier initialization"></a>Xavier initialization</h4><p><em>Woo my initialzation? haha</em></p><p><img src="https://s3.ax1x.com/2020/11/13/D9KiX6.png" alt></p><blockquote><p>ensure we are at the active region of tanh</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9KA0O.png" alt></p><blockquote><p>Can be addressed by add an extra /2， to ensure the neural won’t die in ReLU</p></blockquote><hr><h3 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9KknK.png" alt></p><blockquote><p>To regulize the input tobe unit gaussian.</p></blockquote><p><em>I have no idea about it. What is unit gaussian?</em></p><p><img src="https://s3.ax1x.com/2020/11/13/D9KetH.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9KE7D.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9KZAe.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9Kmhd.png" alt></p><hr><h3 id="Babysitting-the-Learning-Process"><a href="#Babysitting-the-Learning-Process" class="headerlink" title="Babysitting the Learning Process"></a>Babysitting the Learning Process</h3><ul><li><ol><li>Preprocess data</li></ol></li><li><ol><li>Choose the architecture:</li></ol></li><li><ol><li>Double check that the loss is reasonable</li></ol></li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9KK1I.png" alt></p><h4 id="The-Learning-Rate"><a href="#The-Learning-Rate" class="headerlink" title="The Learning Rate"></a>The Learning Rate</h4><ul><li>Very small learning rate 1e-6<blockquote><p>litter help</p></blockquote></li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9K3B8.png" alt></p><ul><li>Very great learning rate 1e6<blockquote><p>go extreme</p></blockquote></li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9KQjP.png" alt></p><ul><li>A Rough Range</li></ul><script type="math/tex; mode=display">1\times{10}^{-3} \to 1\times{10}^{-5}</script><hr><h3 id="Hyperparameter-Optimization"><a href="#Hyperparameter-Optimization" class="headerlink" title="Hyperparameter Optimization"></a>Hyperparameter Optimization</h3><ul><li><p>Cross-validation strategy<br><em>coarse -&gt; fine</em></p></li><li><p>Random Sample</p></li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9Ku9A.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9KMct.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9K1nf.png" alt></p>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Convolutional_Neural_Networks 04</title>
    <link href="/2020/11/11/CS231n/CS231n-04-Convolutional-Neural-Networks/"/>
    <url>/2020/11/11/CS231n/CS231n-04-Convolutional-Neural-Networks/</url>
    
    <content type="html"><![CDATA[<h3 id="A-bit-of-CNN-History"><a href="#A-bit-of-CNN-History" class="headerlink" title="A bit of CNN History"></a>A bit of CNN History</h3><p><img src="https://s1.ax1x.com/2020/11/11/BOGJ5n.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/11/BOGGUs.png" alt></p><h4 id="Fully-Connected-Layer"><a href="#Fully-Connected-Layer" class="headerlink" title="Fully Connected Layer"></a>Fully Connected Layer</h4><p><img src="https://s1.ax1x.com/2020/11/11/BOGlDg.png" alt></p><h4 id="Convolution-Layer"><a href="#Convolution-Layer" class="headerlink" title="Convolution Layer"></a>Convolution Layer</h4><p><img src="https://s1.ax1x.com/2020/11/11/BOG1bQ.png" alt></p><blockquote><p>We just let the 5x5x3 filter $w$ to take a dot product between itself and a small 5x5z3 chunck of the image</p></blockquote><script type="math/tex; mode=display">W^Tx+b</script><p><strong>The $W$ and $x$ is streched into 1 dimention vec</strong></p><ul><li>Then the Outcome:</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOG8Ej.png" alt></p><blockquote><p>We can use different layers on the top of it and get more activation maps stack them together to get a new image, just as the following pic depicted.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/11/BOGtCq.png" alt></p><blockquote><p>Then we can recursively do that work, make the front layer’s output be the next layer’s input</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/11/BOGU2V.png" alt></p><p><strong>The Layers may look like..</strong><br><em>Simple -&gt; Complex</em></p><p><img src="https://s1.ax1x.com/2020/11/11/BOGN80.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/11/BOGrVJ.png" alt></p><ul><li>The Convolution of two signals:</li></ul><script type="math/tex; mode=display">f[x,y]*g[x,y] = \sum\limits_{n_1 = -\infin}^{\infin}\sum\limits_{n_2 = -\infin}^{\infin}f[n_1,n_2]·g[x-n_1,y-n_2]</script><ul><li>A little bit preview</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOG0rF.png" alt></p><hr><ul><li>Convolution Box</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOGwKU.png" alt></p><blockquote><p>We can tell that the activation maps are becomming smaller after the filter, so we commonly use zero pad to deal with it.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/11/BOGBb4.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/11/BOGsa9.png" alt></p><blockquote><p>The Matrix shrinks from 32 —&gt; 28 -&gt; 24 (lose info)</p></blockquote><hr><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ol><li>Accepts a volume of size $W_1 <em> H_1 </em> D_1$</li><li>Four Hyperparas<ul><li>Number of filters $K$</li><li>spatial extent $F$</li><li>stride $S$</li><li>zero padding amount $P$</li></ul></li><li>Produces a volume of size $W_2 <em> H_2 </em> D_2$<ul><li>$W_2 = (W_1 - F + 2P)/S + 1$</li><li>$H_2 = (H_1 - F + 2P)/S + 1$</li><li>$D_2 = K$ <em>Depth keeps the same</em></li></ul></li></ol><h4 id="Common-Settings"><a href="#Common-Settings" class="headerlink" title="Common Settings"></a>Common Settings</h4><p>K = (powers of 2)</p><ul><li>F = 3, S = 1, P =1</li><li>F = 5, S = 1, P =2</li><li>F = 1, S = 1, P = 0 </li></ul><hr><h3 id="Conv-details"><a href="#Conv-details" class="headerlink" title="Conv details"></a>Conv details</h3><ul><li>One by One CONV</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOGy5R.png" alt></p><ul><li>EXAMPLE: CONV in pyTorch</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOGRxK.png" alt></p><ul><li>The Brain/Neuron View of CONV</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOG226.png" alt></p><ul><li>Pooling layer</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOGg8x.png" alt></p><blockquote><p>Just spacially down sample the image to make it smaller.<br>Common Practice is Max Pooling</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/11/BOGcP1.png" alt></p><blockquote><p>We may can just use stride to replace pooling?</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Introduction to Convolutional neural network 03</title>
    <link href="/2020/11/10/CS231n/CS231n-03-Introduction-to-Convolutional-neural-network/"/>
    <url>/2020/11/10/CS231n/CS231n-03-Introduction-to-Convolutional-neural-network/</url>
    
    <content type="html"><![CDATA[<h3 id="Computational-graphs"><a href="#Computational-graphs" class="headerlink" title="Computational graphs"></a>Computational graphs</h3><p><img src="https://s1.ax1x.com/2020/11/10/BbDAaD.png" alt></p><h3 id="BackPropagation-A-method-to-compute-the-gradients-of-abitrarily-complex-function"><a href="#BackPropagation-A-method-to-compute-the-gradients-of-abitrarily-complex-function" class="headerlink" title="BackPropagation - A method to compute the gradients of abitrarily complex function"></a>BackPropagation - A method to compute the gradients of abitrarily complex function</h3><ul><li>A recursive application of Chain rule</li></ul><p><img src="https://s1.ax1x.com/2020/11/10/BbDCKx.png" alt></p><blockquote><p>We get the gradient backprop from the front and comupte with the local gradient to prop to the back.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/10/BbDPr6.png" alt></p><blockquote><p>In some cases, some part of the graph can be represented by some func that we already know to simplify the computations. (trade off the math)</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/10/BbDiqK.png" alt></p><ul><li>Patterns in backward flow</li></ul><ol><li><strong>add gate:</strong> gradient distributor (local = 1)</li><li><strong>max gate:</strong> gradient distributor (local = 1 &amp; 0)</li><li><strong>mul gate:</strong> gradient switcher (local = y &amp; x )</li></ol><p><em>Gradients add at branches n-&gt;1</em></p><ul><li>Then We Got the gradients in the form of Jacobian Matrix</li></ul><p><img src="https://s1.ax1x.com/2020/11/10/BbDkVO.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/10/BbDZPH.png" alt></p><p><em>This place include some linear algebra</em></p><h3 id="Modularized-implementation-Forward-Backward-API"><a href="#Modularized-implementation-Forward-Backward-API" class="headerlink" title="Modularized implementation: Forward / Backward API"></a>Modularized implementation: Forward / Backward API</h3><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComputationalGraph</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">inputs</span>):</span>        <span class="hljs-comment"># 1. pass inputs to input gates</span>        <span class="hljs-comment"># 2. forward the computational graph</span>        <span class="hljs-keyword">for</span> gate <span class="hljs-keyword">in</span> self.graph.nodes_topologically_sorted():            gate.forward()        <span class="hljs-keyword">return</span> loss    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backward</span>():</span>        <span class="hljs-keyword">for</span> gate <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(self.graph.nodes_topologically_sorted())            gate.backward() <span class="hljs-comment"># compute the gradients</span>        <span class="hljs-keyword">return</span> inputs_gradients</code></pre><h4 id="EXAMPLE-MulGate"><a href="#EXAMPLE-MulGate" class="headerlink" title="EXAMPLE: MulGate"></a>EXAMPLE: MulGate</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiplyGate</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">x, y</span>):</span>        z = x*y        self.x = x        self.y = y    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backward</span>(<span class="hljs-params">dz</span>):</span>        dx = self.y * z        dy = self.x * z        <span class="hljs-keyword">return</span> [dx, dy]</code></pre><blockquote><p>This practice is common.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/10/BbDeGd.png" alt></p><h3 id="Summary-so-Far"><a href="#Summary-so-Far" class="headerlink" title="Summary so Far"></a>Summary so Far</h3><p><img src="https://s1.ax1x.com/2020/11/10/BbDmRA.png" alt></p><h3 id="Neural-networks"><a href="#Neural-networks" class="headerlink" title="Neural networks"></a>Neural networks</h3><p>(Before) Linear score function: $f = Wx$<br>(Now) 2-layers Neural Network $f = W_2max(0, W_1x)$<br>….or more layers</p><p><img src="https://s1.ax1x.com/2020/11/10/BbDEIe.png" alt></p><blockquote><p>The h is the scores W1 output, and we put one more linear layer W2 on the top of it to weighting the scores given by h </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Loss Functions and Optimization 02</title>
    <link href="/2020/11/08/CS231n/CS231n_02_Loss-Functions-and-Optimization/"/>
    <url>/2020/11/08/CS231n/CS231n_02_Loss-Functions-and-Optimization/</url>
    
    <content type="html"><![CDATA[<h3 id="Preview-the-Goal-in-this-lecture"><a href="#Preview-the-Goal-in-this-lecture" class="headerlink" title="Preview the Goal in this lecture"></a>Preview the Goal in this lecture</h3><ol><li>Define a loss function</li><li>Come up with a way of finding the paras that minimize the (1)<br>(optimization)</li></ol><p><strong>The Remain Problem from last lecture</strong></p><ul><li>How to choose the W para ? </li></ul><p><img src="https://s1.ax1x.com/2020/11/08/BTZxgK.png" alt></p><h3 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h3><blockquote><p>A loss function tells how good our current classifier is.</p></blockquote><script type="math/tex; mode=display">{(x_i,y_i)}_{i=1}^N</script><p>The $X_i$ is image and the $y_i$ is label (int)</p><p>The Total loss is defined as the func follows.</p><script type="math/tex; mode=display">L = \frac{1}{N}\sum\limits_iL_i(f(x_i,W),y_i)</script><p><em>Which is the sum of every single test’s loss</em></p><hr><h4 id="Muticlass-SVM-loss"><a href="#Muticlass-SVM-loss" class="headerlink" title="Muticlass SVM loss"></a><strong>Muticlass SVM loss</strong></h4><p>Given an example $(x_i,y_i)$ where $x_i$ is the image and where $y_i$ is the (int) label, using the shorthand for the score vec $s = f(x_i,W)$</p><p>The SVM loss has the form:</p><p><img src="https://s1.ax1x.com/2020/11/08/BTZ7B4.png" alt></p><blockquote><p>if the incorrect score is smaller than the right score (x margin), we set the loss to 0.<br>in this case the safe margin is set to one<br><strong>Margin choice depends on our need</strong></p></blockquote><ul><li>Then we loop the class</li></ul><p><img src="https://s1.ax1x.com/2020/11/08/BTZqE9.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/08/BTZLNR.png" alt></p><ul><li>What if we use</li></ul><script type="math/tex; mode=display">L = \frac{1}{N}\sum\limits_iL_i(f(x_i,W),y_i)^2</script><blockquote><p>This is not a linear function and totally different, it’s may be useful sometimes depends on the way you care about the errors.</p></blockquote><h4 id="Example-Code"><a href="#Example-Code" class="headerlink" title="Example Code"></a>Example Code</h4><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">L_i_vectorized</span>(<span class="hljs-params">x, y, W</span>):</span>    scores = W.dot(x)    margins = np.maximun(<span class="hljs-number">0</span>, scores - scores[y] + margin)    margins[y] = <span class="hljs-number">0</span>    loss_i = np.<span class="hljs-built_in">sum</span>(margins)    <span class="hljs-keyword">return</span> loss_i    <span class="hljs-comment"># pretty easy</span></code></pre><p><img src="https://s1.ax1x.com/2020/11/08/BTZO41.png" alt></p><blockquote><p>It just change the gap bettween scores</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTZzjO.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/08/BTe9De.png" alt></p><blockquote><p>often use L2 regularization just Euclid norm.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTepuD.png" alt></p><blockquote><p>In this case the L1 and L2 reg is equal, but we can tell that L1 prefers the $w_1$ for it contains more zero, while the L2 prefers the $w_2$ for the weight is evenly spreaded through the test case.</p><p>The Multiclass SVM loss just care about the gap bettween the right labels and the wrongs.</p></blockquote><h4 id="Softmax-Classifier"><a href="#Softmax-Classifier" class="headerlink" title="Softmax Classifier"></a><strong>Softmax Classifier</strong></h4><p><img src="https://s1.ax1x.com/2020/11/08/BTeiEd.png" alt></p><blockquote><p>We just want to make the true probability closer to 1 (closer the better, eq is the best), so the loss func can be chosed by using the -log on the $P$.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTeCHH.png" alt></p><blockquote><p>If we want to get the zero loss, the score may goes to inf! But Computer don’t like that.</p></blockquote><ul><li>Debugging Way<br>outcomes might be $logC$</li></ul><hr><p><img src="https://s1.ax1x.com/2020/11/08/BTek4I.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/08/BTeECt.png" alt></p><hr><h3 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h3><h4 id="Random-Search-The-Naive-but-Simplest-way"><a href="#Random-Search-The-Naive-but-Simplest-way" class="headerlink" title="Random Search - The Naive but Simplest way"></a>Random Search - The Naive but Simplest way</h4><blockquote><p>Really Slow !!!</p></blockquote><h4 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h4><blockquote><p>We just get the Gradient of W and go down to the bottom (maybe local best?)</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTeFUA.png" alt></p><p><strong>Code</strong></p><pre><code class="hljs python"><span class="hljs-comment"># Vanilla Gradient Descent</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    weight_grad = evaluate_gradient(loss_fun, data, weights)    weights += -step_size * weight_grad</code></pre><p><strong>Step size is called elearning rate which is important</strong></p><p><img src="https://s1.ax1x.com/2020/11/08/BTeV8P.png" alt></p><blockquote><p>Since the N might be super large, we sample some sets called minibatch and use it to estimate the true gradient.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTeZgf.png" alt></p><hr><p><img src="https://s1.ax1x.com/2020/11/08/BTenKS.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/08/BTeuDg.png" alt></p><p><strong>Color Feature</strong><br><img src="https://s1.ax1x.com/2020/11/08/BTeQEj.png" alt></p><p><strong>Gradient</strong> <em>Extract the edge info</em><br><img src="https://s1.ax1x.com/2020/11/08/BTelUs.png" alt></p><p><strong>NLP?</strong><br><img src="https://s1.ax1x.com/2020/11/08/BTeG80.png" alt></p><blockquote><p>clustering different image patches from images</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTe15n.png" alt></p><ul><li>Differences</li></ul><ol><li>Extract the Feature at first and feed into the linear classificator</li><li>Convolutional Neutral Network would learn the feature automatically during the training process.</li></ol>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Image Classification 01</title>
    <link href="/2020/11/07/CS231n/CS231n_01_Image_Classification/"/>
    <url>/2020/11/07/CS231n/CS231n_01_Image_Classification/</url>
    
    <content type="html"><![CDATA[<p><strong>Preface:</strong> This is the note of Stanford course CS231n, paving the way for my lab research.</p><h1 id="Image-Classification"><a href="#Image-Classification" class="headerlink" title="Image Classification"></a>Image Classification</h1><p><em>A core task in Computer Vision</em></p><hr><h3 id="Computer’-Work"><a href="#Computer’-Work" class="headerlink" title="Computer’ Work"></a>Computer’ Work</h3><p>Input an image, and assign one of the label amoung the given labels.</p><ul><li><strong>The Problem:</strong> </li></ul><ol><li>Semantic Gap</li><li>Viewpoint variation</li><li>illumination </li><li>Deformation</li><li>Occlusion</li><li>Intraclass variation</li></ol><hr><h3 id="An-image-classifier"><a href="#An-image-classifier" class="headerlink" title="An image classifier"></a>An image classifier</h3><blockquote><p>Coding might be difficult </p></blockquote><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classify_image</span>(<span class="hljs-params">image</span>):</span>    <span class="hljs-comment"># Do Some Magic</span>    <span class="hljs-keyword">return</span> class_label</code></pre><ul><li>Attmpts</li></ul><p><img src="https://s1.ax1x.com/2020/11/07/BIMSmD.png" alt></p><hr><h3 id="Data-Driven-Approach"><a href="#Data-Driven-Approach" class="headerlink" title="Data-Driven Approach"></a>Data-Driven Approach</h3><ol><li>Collect a dataset of images and labels</li><li>Use Machine Learning to train a classifier</li><li>Evaluate the classifier on new images</li></ol><ul><li>First classifier: Nearest Neighbor</li></ul><p><em>Just Memorize all data and labels</em><br><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span>(<span class="hljs-params">images, labels</span>):</span>    <span class="hljs-comment"># Machine Learning!</span>    <span class="hljs-keyword">return</span> model</code></pre></p><p><em>Predict the label of the most similar training image</em><br><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span>(<span class="hljs-params">model, test_images</span>):</span>    <span class="hljs-comment"># Use model to predict labels</span>    <span class="hljs-keyword">return</span> test_labels</code></pre></p><p><strong>Example Dataset:</strong> CIFAR10</p><p><img src="https://s1.ax1x.com/2020/11/07/BIM9TH.png" alt></p><blockquote><p><strong>Issues:</strong> Although pics may seem visually similar, but still give lots of errors.</p><hr></blockquote><ul><li>Compare func used in it<h3 id="K-nearest-Neighbors-Method"><a href="#K-nearest-Neighbors-Method" class="headerlink" title="K nearest Neighbors Method"></a><strong>K nearest Neighbors Method</strong></h3></li></ul><p><strong>L1 distance:</strong> $d<em>1(I_1,I_2) = \sum\limits</em>{p} \mid I_1^p - I_2^p \mid$</p><p><img src="https://s1.ax1x.com/2020/11/07/BIKXSx.png" alt></p><p><em>Minimize the sum given the most similar pics</em></p><h4 id="BackWards"><a href="#BackWards" class="headerlink" title="BackWards"></a><strong>BackWards</strong></h4><p><img src="https://s1.ax1x.com/2020/11/07/BIKjl6.png" alt></p><h4 id="What-it-looks-like"><a href="#What-it-looks-like" class="headerlink" title="What it looks like"></a><strong>What it looks like</strong></h4><p><img src="https://s1.ax1x.com/2020/11/07/BIMp0e.png" alt></p><p><strong>Issues</strong></p><ol><li>Isolated Yellow Point</li><li>Noisy of one single point (green into blue)</li></ol><p><strong>Use K Nearest Neighbors to Optimize it</strong><br><img src="https://s1.ax1x.com/2020/11/07/BIMitA.png" alt></p><hr><p><em>A Better Cmp Func</em><br><strong>L2(Euclidean) distance:</strong> $d<em>1(I_1,I_2) = \sqrt{\sum\limits</em>{p}{(I_1^p - I_2^p)}^2}$</p><p><img src="https://s1.ax1x.com/2020/11/07/BIMFfI.png" alt></p><blockquote><p>The L1 Distance depends on the coordinate system, whenever there is a rotate, it would change the L1 Distance, while that won’t happen in the L2 Distance case (simply because it’s a circle)</p></blockquote><hr><h4 id="Hyperparameters"><a href="#Hyperparameters" class="headerlink" title="Hyperparameters"></a><strong>Hyperparameters</strong></h4><ul><li>What’s the best value of <strong>k</strong></li><li>What’s the best <strong>distance</strong> to use? (L1,L2 or anything else)</li></ul><p><em>These things are preset rather than learn automatically from learning process</em></p><p>This is <strong>Very problem-dependent</strong>, just try!, but How?</p><p><img src="https://s1.ax1x.com/2020/11/07/BIME1P.png" alt></p><p><strong>Training &amp; Validation process should not mixed with the test data</strong></p><ul><li>Cross Validation</li></ul><p><img src="https://s1.ax1x.com/2020/11/07/BIMApt.png" alt></p><ul><li>Validation process</li></ul><p><img src="https://s1.ax1x.com/2020/11/07/BIMV6f.png" alt></p><blockquote><p>using the validation data to choose the best hyperparameters.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/07/BIMu7Q.png" alt></p><blockquote><p>Cause we sum the offset, though the differences bettween pics and pics are various, they still got the same L2 distance, which is not so good.</p></blockquote><hr><h3 id="Linear-Classification"><a href="#Linear-Classification" class="headerlink" title="Linear Classification"></a><strong>Linear Classification</strong></h3><ul><li><strong>Parametric Model</strong><br><img src="https://s1.ax1x.com/2020/11/07/BIMZX8.png" alt></li></ul><script type="math/tex; mode=display">f(x,W) = Wx + b</script><blockquote><p>We need f(x,W) to be 10x1 and the x is actually 3072x1, so the W we input may be 10x3072, sometimes we add a bias to balance.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/07/BIMn0g.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/07/BIMMkj.png" alt></p><blockquote><p>It use a single line to separate the object based on its RGB info</p></blockquote><p>But how can we tell the quality of W ?<br>(View the next lecture)</p><ul><li><strong>Problems</strong><br><img src="https://s1.ax1x.com/2020/11/07/BIMQts.png" alt></li></ul><blockquote><p>Since it’s linear the Problems is obivious.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS-Lab2 二进制炸弹</title>
    <link href="/2020/11/06/ICS/ICS_Lab2/"/>
    <url>/2020/11/06/ICS/ICS_Lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="ICS-Lab2-Bomb"><a href="#ICS-Lab2-Bomb" class="headerlink" title="ICS-Lab2-Bomb"></a>ICS-Lab2-Bomb</h1><blockquote><p>这个是CS:APP的第二个lab，主要着重于汇编代码的阅读</p></blockquote><hr><h2 id="完成截图"><a href="#完成截图" class="headerlink" title="完成截图"></a>完成截图</h2><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_244e1f55d2823d58f65eabab9478d7ce.png"></p><hr><h2 id="Phase-1-入门"><a href="#Phase-1-入门" class="headerlink" title="Phase 1 - 入门"></a>Phase 1 - 入门</h2><h3 id="一、分析"><a href="#一、分析" class="headerlink" title="一、分析"></a>一、分析</h3><blockquote><p>练手入门题，用esi寄存器储存答案地址 (一个立即数)<br><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">402400</span>,%esi</code></pre><br>之后调用了一个 string_not_equal 函数比较输入和答案是否一致，一致就通过了。<br><pre><code class="hljs angelscript">callq  <span class="hljs-number">401338</span> &lt;<span class="hljs-built_in">string</span>s_not_equal&gt;</code></pre></p></blockquote><h3 id="二、gdb调试"><a href="#二、gdb调试" class="headerlink" title="二、gdb调试"></a>二、gdb调试</h3><blockquote><p>看一下内存地址里面存了什么，获得flag</p></blockquote><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_4801c7e177c56f6e7299c273d0120988.png"></p><ul><li><strong>答案</strong>: Border relations with Canada have never been better.</li></ul><hr><h2 id="Phase-2-循环"><a href="#Phase-2-循环" class="headerlink" title="Phase 2 - 循环"></a>Phase 2 - 循环</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>本题是一个do while Loop, 难度不大, 耐心读就行了</p></blockquote><p><strong>关键位置</strong></p><ul><li>信息1 ： 看到 read_six_number 知道输入6个数，再往下看</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">cmpl</span>   $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,(%rsp) # 比较栈顶地址所存变量大小是否为<span class="hljs-number">1</span><span class="hljs-attribute">je</span>     <span class="hljs-number">400</span>f<span class="hljs-number">30</span> &lt;phase_<span class="hljs-number">2</span>+<span class="hljs-number">0</span>x<span class="hljs-number">34</span>&gt; # 如果为<span class="hljs-number">1</span> 跳转至地址 <span class="hljs-number">400</span>f<span class="hljs-number">30</span><span class="hljs-attribute">callq</span>  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt; # 如果不为<span class="hljs-number">1</span>，直接炸了<span class="hljs-attribute">jmp</span>    <span class="hljs-number">400</span>f<span class="hljs-number">30</span> &lt;phase_<span class="hljs-number">2</span>+<span class="hljs-number">0</span>x<span class="hljs-number">34</span>&gt; # 跳转至地址 <span class="hljs-number">400</span>f<span class="hljs-number">30</span></code></pre><ul><li>信息2 : 第一个数为1</li></ul><p>下面进入Loop Body</p><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_27148224f8cf2be48266eaa52f50b2f8.png"></p><ul><li>信息3 :<br>可以看到这个循环把前一个数乘了2，跟后一个数比较, 如果相等就能够继续，不然就炸了。</li></ul><blockquote><p>综上也就是说这是一个首项为1，公比为2的等比数列，共6项。</p></blockquote><p>所以答案就是 1 2 4 8 16 32</p><hr><h2 id="Phase-3-分支"><a href="#Phase-3-分支" class="headerlink" title="Phase 3 - 分支"></a>Phase 3 - 分支</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><blockquote><p>第三题关键点在于用gdb查看一下jumptable</p></blockquote><p> 我们先看一下输入，在输入了两个变量后，esi里放了内存中的一个可疑的东西，我们用gdb看一眼。<br><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">4025</span>cf,%esi</code></pre></p><pre><code class="hljs shell">(gdb) p(char *) 0x4025cf&quot;%d %d&quot;</code></pre><p> 发现原来是输入两个整型，再往下看</p><pre><code class="hljs apache"><span class="hljs-attribute">cmpl</span>   $<span class="hljs-number">0</span>x<span class="hljs-number">7</span>,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp) # 将 M(rsp + <span class="hljs-number">8</span>) 看作<span class="hljs-number">32</span>位无符号数跟<span class="hljs-number">7</span>比较<span class="hljs-attribute">ja</span>     <span class="hljs-number">400</span>fad &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">6</span>a&gt; # 如果大于就跳转至 <span class="hljs-number">0</span>x<span class="hljs-number">400</span>fad (炸弹炸了)</code></pre><p> 发现如果输入的第一个数大于7就爆炸了，看来switch最多只有7个case</p><pre><code class="hljs angelscript">jmpq   *<span class="hljs-number">0x402470</span>(,%rax,<span class="hljs-number">8</span>) # 跳转至 (eax * <span class="hljs-number">8</span> + <span class="hljs-number">0x402470</span>)处所存的地址 （jumptable）</code></pre><blockquote><p>最关键的是这一句，构造了一个 switch 的 jumptable，我们知道地址是 0x402470，按照 case * 8 + 0x402470 跳转到该地址里面的地址，所以我们用gdb看一下。</p></blockquote><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_ae5e359c30ff5ccb9292a7472c39eb19.png"></p><ul><li><p>我通关选了case 1（它比较特殊，处理它其他内存地址跳转都是按case从小到大顺序的，只有case 1 在最后一个，当然其他也都能过。）</p></li><li><p>case 1 跳转到了 0x400fb9 地址</p></li></ul><pre><code class="hljs angelscript">mov    $<span class="hljs-number">0x137</span>,%eax # eax = <span class="hljs-number">0x137</span> (<span class="hljs-number">311</span>) (不用跳转了，下面就是 <span class="hljs-number">0x400fbe</span>)</code></pre><p>其将eax置为了0x137，要小心是16进制，所以对应十进制311</p><pre><code class="hljs apache"><span class="hljs-attribute">cmp</span>    <span class="hljs-number">0</span>xc(%rsp),%eax # 比较 M(rsp + <span class="hljs-number">12</span>) 和 eax<span class="hljs-attribute">je</span>     <span class="hljs-number">400</span>fc<span class="hljs-number">9</span> &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">86</span>&gt; # 如果相等就跳转至 <span class="hljs-number">0</span>x<span class="hljs-number">400</span>fc<span class="hljs-number">9</span> (过关了！)</code></pre><p>最后是一个比较，如果eax和第二个输入值相同就过了。</p><ul><li>本题答案（不唯一)</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">case</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">ans</td><td style="text-align:center">207</td><td style="text-align:center">311</td><td style="text-align:center">707</td><td style="text-align:center">256</td><td style="text-align:center">389</td><td style="text-align:center">206</td><td style="text-align:center">682</td><td style="text-align:center">327</td></tr></tbody></table></div><hr><h2 id="Phase-4-递归"><a href="#Phase-4-递归" class="headerlink" title="Phase 4 - 递归"></a>Phase 4 - 递归</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ul><li>这题是个递归，不过不用很深，很快就能看出答案。</li></ul><p>先正常读两个数，放在rdx，rcx中，检查输入。</p><pre><code class="hljs angelscript">cmpl   $<span class="hljs-number">0xe</span>,<span class="hljs-number">0x8</span>(%rsp) # 比较 M(rsp + <span class="hljs-number">8</span>) (既 rdx) 与 <span class="hljs-number">0xe</span>jbe    <span class="hljs-number">40103</span>a &lt;phase_4+<span class="hljs-number">0x2e</span>&gt; # 如果 rdx &lt;= <span class="hljs-number">0xe</span> (<span class="hljs-number">14</span>) 跳转至 <span class="hljs-number">0x40103a</span>, 不然就炸了 (作为无符号数)</code></pre><blockquote><p>这两行汇编告诉我们，rdx一定要小于 0xe (14) 且大于等于0, 不然炸了, 大幅度缩小了范围。</p><p>接下来就进入了函数递归调用，先做点预处理，把edx里面存一个立即数14，然后edi为第一个输入值，esi = 0 进入fun4</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>xe,%edx # edx = <span class="hljs-number">0</span>xe (<span class="hljs-number">14</span>)<span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%esi # esi = <span class="hljs-number">0</span><span class="hljs-attribute">mov</span>    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp),%edi # edi = (第一个输入值)<span class="hljs-attribute">callq</span>  <span class="hljs-number">400</span>fce &lt;func<span class="hljs-number">4</span>&gt; # 调用func<span class="hljs-number">4</span></code></pre><blockquote><p>先不着急看fun4，先看看最后要怎么过关<br><pre><code class="hljs apache"><span class="hljs-attribute">test</span>   %eax,%eax # eax &amp; eax<span class="hljs-attribute">jne</span>    <span class="hljs-number">401058</span> &lt;phase_<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">4</span>c&gt; <span class="hljs-comment"># 如果ZF == 0 就跳转（既eax != 0)，跳转至 0x401058 炸了</span><span class="hljs-attribute">cmpl</span>   $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,<span class="hljs-number">0</span>xc(%rsp) # 比较 M(rsp + <span class="hljs-number">12</span>) 和 <span class="hljs-number">0</span><span class="hljs-attribute">je</span>     <span class="hljs-number">40105</span>d &lt;phase_<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">51</span>&gt; # 如果相等就跳转到 <span class="hljs-number">0</span>x<span class="hljs-number">40105</span>d, 不然就炸了</code></pre></p><ul><li>test 实际上就是一个与操作，所以我们知道需要 eax == 0 且 M(rsp + 12) == 0，到这我们发现，第二个条件只要我们一开始输入的第二个参数为0，就能够保证，那么下面我们就要看进入fun4之后如何让返回值 eax == 0</li></ul><p>再回来看fun4，其分为两部分，一个是递归的主体，一个是判断是否继续递归。一开始先对eax 和 ecx 进行一些操作。</p><ul><li>我们发现 eax 和 ecx 的值在第一层递归都被置为14，(esi 为 0)按其操作得到 eax 除2, ecx 逻辑右移 31 位为0, 接着其实就是比较 edi 和 rax, <strong>相当于就是比较第一个参数和常数 7</strong></li></ul></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">jle</span>    <span class="hljs-number">400</span>ff<span class="hljs-number">2</span> &lt;func<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">24</span>&gt; # 若ecx &lt;= 就跳转至 <span class="hljs-number">0</span>x<span class="hljs-number">400</span>ff<span class="hljs-number">2</span></code></pre><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax # eax = <span class="hljs-number">0</span>;<span class="hljs-attribute">cmp</span>    %edi,%ecx # 比较 ecx 和 edi <span class="hljs-attribute">jge</span>    <span class="hljs-number">401007</span> &lt;func<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">39</span>&gt; <span class="hljs-comment"># 若 edi &gt;= ecx 跳转至 0x401007 返回</span></code></pre><ul><li>接着是一个跳转, 如果满足我们就跳转至 0x400ff2, 我们发现这里已经满足了我们需要的 eax == 0，而想要结束就得使 edi &gt;= ecx (7), 所以我们发现，对于上下两个跳转条件，只要 edi == ecx == 7 就能一直成立，从而直接达成条件，不用进入递归。</li></ul><p>进而我们得到了本题答案：7 0</p><hr><h2 id="Phase-5-指针"><a href="#Phase-5-指针" class="headerlink" title="Phase 5 - 指针"></a>Phase 5 - 指针</h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><ul><li>这题我觉得是最好玩的一题，先直接分析如何通关。</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">40245</span>e,%esi # esi = <span class="hljs-number">0</span>x<span class="hljs-number">40245</span>e <span class="hljs-comment"># 待比较的 string (flyers) 从 0x40245e 移动至 esi</span></code></pre><ul><li>我们在接近返回时看到了一个非常可疑的内存地址，直接给它打出来。</li></ul><pre><code class="hljs lsl">(gdb) p(char*) <span class="hljs-number">0x40245e</span>$<span class="hljs-number">4</span> = <span class="hljs-number">0x40245e</span> <span class="hljs-string">&quot;flyers&quot;</span></code></pre><blockquote><p>发现是一个可疑字符串 flyers，阅读上下文汇编代码可知，最后是比较字符串是否和指定字符串 “flyers” 一致。</p></blockquote><ul><li>我们再往上看看要怎么输入</li></ul><pre><code class="hljs angelscript">callq  <span class="hljs-number">40131</span>b &lt;<span class="hljs-built_in">string</span>_length&gt; # 比较字符长度是否为<span class="hljs-number">6</span>cmp    $<span class="hljs-number">0x6</span>,%eax # 比较 eax 和 <span class="hljs-number">6</span></code></pre><p>发现输入一定要是六个字符 <em>(于是试了试 flyers 果然不对)</em></p><ul><li>往下看，发现了一个 Loop 循环了6次</li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_016df1440f7044a54fb4ced529595b58.png"></p><blockquote><p>经过仔细阅读后，发现这个居然是遍历六个输入字符，将其 ascii 码低4位取出来作为偏移量 (offset),在一个基地址 （0x4024b0）后面取字符出来组成 flyers.</p></blockquote><ul><li>立刻开启 gdb 查看基地址附近的内存</li></ul><p><strong>发现分别对应的偏移量是 9, 15, 14, 5, 6, 7</strong></p><blockquote><p>直接查 ascii 码，发现对应 ionefg 、IONEFG 或者有一些不是字母的字符也行，只要低四位是正确的就可以。 </p></blockquote><p><strong>本题答案:</strong>  ionefg (答案不唯一)</p><hr><h2 id="Phase-6-Node结构体"><a href="#Phase-6-Node结构体" class="headerlink" title="Phase 6 - Node结构体"></a>Phase 6 - Node结构体</h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>这题还是比较麻烦的，代码比较长也比较复杂，要耐心读。</p><ul><li>这题的代码可以大致分为输入检测与处理和一个对结构体的顺序检测.<blockquote><p>最开始上来先输入六个数之后有个双循环，外部保证输入的六个数要大于等于1，且小于等于6，内部保证互异。所以总体看来就是输入的六个数就是123456, 现在问题是输入的顺序。</p></blockquote></li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_7194e52688ff3d696a3b889e2b17d63f.png"></p><p>这段代码遍历了所有输入并用7减去了输入的每个数，所以最后做出答案要记得反一下。</p><ul><li>接下来代码比较复杂，外面大循环循环了六次，内部有两个平行的小循环。作用是构造结构体，并在栈帧中将其存放位置按照输入的数的大小计算得出</li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_9ea5cd30293a18357af1da93c35e0f59.png"></p><blockquote><p>分析代码，我们先发现一种特殊情况就是当前计算的数为1时（输入为6）edx直接就是给定的地址 0x6032d0, 其余的都按照其大小，在第一个小循环中循环相应次数，给 rdx 在原地址上相应偏移16位。</p><p>接着下来将其存入栈帧中 rsp + 32 到 rsp + 80 的位置</p></blockquote><ul><li>使用 gdb 查看 node</li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_f2ecdd05728cbefbba59b068a29fdfdc.png"></p><p>最后我们看如何通关</p><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_a18a67d1b4dbfa16a7fd8800e3ee304b.png"></p><blockquote><p>发现通关条件是要求定序，前面node大于后面的节点，根据gdb node节点的值和要求我们得到了 3 4 5 6 1 2 的结果，最后不要忘记这是被7减过之后的结果，原来的输入要还原。所以答案就是 4 3 2 1 6 5</p></blockquote><p><strong>本题答案:</strong> 4 3 2 1 6 5</p><hr><h2 id="Secret-Phase-递归"><a href="#Secret-Phase-递归" class="headerlink" title="Secret Phase- 递归"></a>Secret Phase- 递归</h2><h3 id="一、进入方法"><a href="#一、进入方法" class="headerlink" title="一、进入方法"></a>一、进入方法</h3><ul><li>输入上面六种答案之后，发现 secret phase 并没有出现，于是开始着手寻找入口。</li></ul><blockquote><p>根据最后结果出现的字符顺藤摸瓜找到了 phase_defuse 函数，一看发现其中有一个可疑的 <string_not_equal> 函数以及几个可疑的内存地址,统统用 gdb 打印。</string_not_equal></p></blockquote><pre><code class="hljs perl">(gdb) p(char*) <span class="hljs-number">0x402619</span>$2 = <span class="hljs-number">0x402619</span> <span class="hljs-string">&quot;%d %d %s&quot;</span></code></pre><pre><code class="hljs lsl">(gdb) p(char*) <span class="hljs-number">0x402622</span>$<span class="hljs-number">3</span> = <span class="hljs-number">0x402622</span> <span class="hljs-string">&quot;DrEvil&quot;</span></code></pre><blockquote><p>发现之前调用过的__isoc99_sscanf@plt 还有隐藏用法，在输入两个数后再输入一个字符串 “DrEvil” 就能成功开启secret phase.</p></blockquote><ul><li>所以我们在最后一次调用__isoc99_sscanf@plt的 phase 4 输入 7 0 DrEvil, 果然在 phase 6 之后进入了 secret phase。</li></ul><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><ul><li>虽然说是隐藏关，但是复杂度和难度比 phase 6 低了不少，和 phase 4 一样是一个递归，但不同的是这次真的需要递归几次，但也不深。只要确定好路线还是比较容易的。</li></ul><pre><code class="hljs angelscript">callq  <span class="hljs-number">40149</span>e &lt;read_line&gt; # 读一行...callq  <span class="hljs-number">400</span>bd0 &lt;<span class="hljs-symbol">strtol@</span>plt&gt; # 调用 <span class="hljs-symbol">strtol@</span>plt</code></pre><blockquote><p>secret phase上来读了一整行然后调用了一个 strtol，经过阅读strtol的源码，发现它是以10为base将字符串转为一个整型，实际上就是剔除了最后答案中除了数字以外的字符。(所以写上答案数字然后乱输字母也能过 bushi)</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">lea</span>    -<span class="hljs-number">0</span>x<span class="hljs-number">1</span>(%rax),%eax <span class="hljs-comment"># eax = (rax) - 1</span><span class="hljs-attribute">cmp</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">3</span>e<span class="hljs-number">8</span>,%eax <span class="hljs-comment"># eax == 0x3e8 ? (即判断返回值与0x3e9)</span></code></pre><ul><li>这段代码告诉我们输入的数要小于 1000</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">6030</span>f<span class="hljs-number">0</span>,%edi # edi = <span class="hljs-number">0</span>x<span class="hljs-number">6030</span>f<span class="hljs-number">0</span> (<span class="hljs-number">36</span>)<span class="hljs-attribute">callq</span>  <span class="hljs-number">401204</span> &lt;fun<span class="hljs-number">7</span>&gt; # 调用fun<span class="hljs-number">7</span></code></pre><ul><li>将edi置为 0x6030f0 (里面存的是36) 接着开始调用fun7</li></ul><blockquote><p>我们先不着急看fun7, 老样子先看过关要求。</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">cmp</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">2</span>,%eax # 比较一下 eax 返回是否为<span class="hljs-number">2</span></code></pre><p>发现非常简单，只要eax返回值为2就行</p><ul><li>再来看fun7</li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_64ed470376ec6b72dc43690bf9b4ea0e.png"></p><blockquote><p>一看这个递归是逃不过了，但我们要让eax == 2, 路线其实非常明确，第一次先走 way3 将 eax 弄成1，再走 way1 让eax<em>2， 最后一层我们让eax == 0 最后返回我们得到的 eax 就等于2</em>（eax = 0 -&gt; 1 -&gt; 2）*</p><p>关键是一个 edx 和 esi 的比较，edx == rdi, 然后每次改变rdi使其中储存地址中所储存的变量逐步接近 esi 完成递归操作。</p></blockquote><p>根据所存地址(注意/d打出的是10进制)，可以很容易找出递归路径</p><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_dfddd1801cd10c701dd2753164434977.png" style="width:65%"></p><ul><li>输入22可以正好满足需求<blockquote><p><strong>22 &lt;= 36 因而 rdi = (rdi + 8) (存8)，22 &gt; 8 因而 rdi = = (rdi + 16) (存22), 22==22 所以 eax 返回 0 ，返回 1， 返回2，最终过关</strong></p></blockquote></li></ul><p><strong>本题答案:</strong> 22 (可以带非数字字符)</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Assembly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS-Lab1 位运算</title>
    <link href="/2020/11/05/ICS/ICS_Lab1/"/>
    <url>/2020/11/05/ICS/ICS_Lab1/</url>
    
    <content type="html"><![CDATA[<h1 id="ICS-Lab1-位运算"><a href="#ICS-Lab1-位运算" class="headerlink" title="ICS_Lab1-位运算"></a>ICS_Lab1-位运算</h1><blockquote><p>这个是CS:APP的第一个lab，也是我ICS课上的第一个lab，主要注重于使用受限制的位运算来完成操作</p></blockquote><hr><h2 id="Bits-c"><a href="#Bits-c" class="headerlink" title="Bits.c"></a><strong>Bits.c</strong></h2><h3 id="1-bitAnd—与"><a href="#1-bitAnd—与" class="headerlink" title="1. bitAnd—与"></a><strong>1. bitAnd—与</strong></h3><p><strong>题目：</strong></p><pre><code>只用~和|实现&amp;</code></pre><p><strong>样例：</strong></p><pre><code>bitAnd(6, 5) = 4</code></pre><p><strong>可使用操作：</strong> ~ |</p><p><strong>最大操作数限制：</strong> 8</p><p><strong>使用操作数：</strong> 4</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitAnd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;  <span class="hljs-keyword">return</span> ~(~x | ~y); <span class="hljs-comment">//De Morgan&#x27;s laws</span>&#125;</code></pre><blockquote><p>应用摩根律 ~(x | y) = ~x &amp; ~y, 可得 x &amp; y = ~(~x | ~y)</p></blockquote><hr><h3 id="2-getByte—获取字节"><a href="#2-getByte—获取字节" class="headerlink" title="2. getByte—获取字节"></a><strong>2. getByte—获取字节</strong></h3><p><strong>题目：</strong></p><pre><code>从x中提取字节n, n编号从0至3</code></pre><p><strong>样例：</strong></p><pre><code>getByte(0x12345678,1) = 0x56</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 6</p><p><strong>使用操作数：</strong> 3</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getByte</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">return</span> (x &gt;&gt; (n &lt;&lt; <span class="hljs-number">3</span>)) &amp; <span class="hljs-number">0xff</span>;&#125;</code></pre></p><p><strong>分析：</strong></p><p><em>由于 1Byte = 8bits = 2^3bits， 所以 n Bytes = 2^3 </em> n bits*</p><blockquote><p>因而将n左移3位，即 n <em> 2^3, 再将x右移 n </em> 2^3 即可将所求字节放在低8位，将其与上0xff，即可取出字节。</p></blockquote><hr><h3 id="3-logicalShift—逻辑右移"><a href="#3-logicalShift—逻辑右移" class="headerlink" title="3. logicalShift—逻辑右移"></a><strong>3. logicalShift—逻辑右移</strong></h3><p><strong>题目：</strong></p><pre><code>将x逻辑右移n位</code></pre><p><strong>样例：</strong></p><pre><code>logicalShift(0x87654321,4) = 0x08765432</code></pre><p><strong>可使用操作：</strong>  ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 20</p><p><strong>使用操作数：</strong> 10</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">logicalShift</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-comment">//flag equals to: if n == 0 return 0; else return 1;</span>  <span class="hljs-keyword">int</span> flag = !!n;  <span class="hljs-keyword">int</span> mask = ~(flag &lt;&lt; (<span class="hljs-number">32</span> + (~n + <span class="hljs-number">1</span>)));  <span class="hljs-keyword">return</span> (x &gt;&gt; n) &amp; mask;&#125;</code></pre></p><p><strong>分析：</strong></p><ul><li><p>算数右移</p><blockquote><p>算数右移即在右移后用原符号位数将高位补齐，保持右移后二进制数的符号保持不变。</p></blockquote></li><li><p>逻辑右移</p><blockquote><p>逻辑右移即在右移后用 0 将高位补齐，是“逻辑上”的右移。</p></blockquote></li></ul><blockquote><p>在正常右移运算中使用的是算数右移，因而要解决的问题即对于负数如何将最高位补上0，而非符号位1。<br>我采取掩码的方式，先将x正常右移n位与上其高位的掩码，使其右移产生的高位变为0</p></blockquote><ul><li>掩码构造<blockquote><p>掩码不能草率的构造为 ~(-1 &lt;&lt; (32 - n)), 这种构造方式当n为0时会因-1被左移32位而导致异常，构造出来的mask仍为0</p></blockquote></li></ul><blockquote><p>由于不能使用if，为判断n是否为0，我才用了一个flag = !n + ~0, 其有很好的性质。当n为0时，flag也为0，而当n不为零时，flag统一为-1，这样使用flag代替原先的-1, 从而避免上述情况。</p><p>这样我们可以使用 mask = ~(flag &lt;&lt; (32 + (~n + 1)))，来构造掩码，当n为0时，flag为0，从而mask = -1，避免上述错误。</p></blockquote><hr><h3 id="4-bitCount—比特计数"><a href="#4-bitCount—比特计数" class="headerlink" title="4. bitCount—比特计数"></a><strong>4. bitCount—比特计数</strong></h3><p><strong>题目：</strong></p><pre><code>返回二进制数中1的个数</code></pre><p><strong>样例：</strong></p><pre><code>bitCount(5) = 2, bitCount(7) = 3</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 40</p><p><strong>使用操作数：</strong> 36</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">int</span> tmp, l1, l2, l4, l8, l16; <span class="hljs-comment">//tmp is used to save ops</span>  tmp = (<span class="hljs-number">0x55</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x55</span>;  l1 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp; <span class="hljs-comment">//0x55555555</span>  tmp = (<span class="hljs-number">0x33</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x33</span>;  l2 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp; <span class="hljs-comment">//0x33333333</span>  tmp = (<span class="hljs-number">0x0f</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x0f</span>;  l4 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp; <span class="hljs-comment">//0x0f0f0f0f</span>  l8 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">16</span>) + <span class="hljs-number">0xff</span>; <span class="hljs-comment">//0x00ff00ff</span>  l16 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xff</span>; <span class="hljs-comment">//0x0000ffff</span>  x = (x &amp; l1) + ((x &gt;&gt; <span class="hljs-number">1</span>) &amp; l1);  x = (x &amp; l2) + ((x &gt;&gt; <span class="hljs-number">2</span>) &amp; l2);  x = (x &amp; l4) + ((x &gt;&gt; <span class="hljs-number">4</span>) &amp; l4);  x = (x &amp; l8) + ((x &gt;&gt; <span class="hljs-number">8</span>) &amp; l8);  x = (x &amp; l16) + ((x &gt;&gt; <span class="hljs-number">16</span>) &amp; l16);  <span class="hljs-keyword">return</span> x;&#125;</code></pre></p><p><strong>分析：</strong></p><ul><li>分治思想<blockquote><p>本题使用了一个简单的分治思想，对于一个二进制数，要对其中为1的位做计数， 对于1位二进制数来说，1的个数无非就是其本身所表示的1或0。利用这个特性，我们可以先将一个二进制数每一位独立分开为相间隔的两部分, 其每位表示的就是自身的二进制个数，再将两串二进制数对其相加，所得到的每两位分隔的二进制数就是表达这个位置的位为1的个数。</p></blockquote></li></ul><blockquote><p>进一步相加为4位，8位其所代表的含义不变，最后合并至32位二进制数，其所表示的就是原二进制数中所含1的个数。</p></blockquote><pre><code class="hljs cpp"><span class="hljs-comment">//以八位二进制数 10101110 为例//</span>按 <span class="hljs-number">1</span>|<span class="hljs-number">0</span>|<span class="hljs-number">1</span>|<span class="hljs-number">0</span>|<span class="hljs-number">1</span>|<span class="hljs-number">1</span>|<span class="hljs-number">1</span>|<span class="hljs-number">0</span> 分割， 为两串<span class="hljs-number">1</span>|<span class="hljs-number">1</span>|<span class="hljs-number">1</span>|<span class="hljs-number">1</span>和<span class="hljs-number">0</span>|<span class="hljs-number">0</span>|<span class="hljs-number">1</span>|<span class="hljs-number">0</span>，再将其合并，成为 <span class="hljs-number">01</span> | <span class="hljs-number">01</span> | <span class="hljs-number">10</span> | <span class="hljs-number">01</span>, 再将两串 <span class="hljs-number">01</span> | <span class="hljs-number">10</span> 和<span class="hljs-number">01</span> | <span class="hljs-number">01</span>合并得 <span class="hljs-number">0010</span> | <span class="hljs-number">0011</span>（这个很容易看出表示左四位有<span class="hljs-number">2</span>个<span class="hljs-number">1</span>，右四位有<span class="hljs-number">3</span>个<span class="hljs-number">1</span>），再次合并得 <span class="hljs-number">00000101</span>, 得到总共有<span class="hljs-number">5</span>个<span class="hljs-number">1</span>。<span class="hljs-comment">//对于32位二进制数亦按此继续操作即可//</span></code></pre><blockquote><p>于是为完成分割取位的操作，我们需要采用掩码</p></blockquote><ul><li>0x55555555 \ 0x33333333 \ 0x0f0f0f0f \ 0x0000ffff</li></ul><blockquote><p>利用位运算分别构造，使用tmp可以节约ops, 之后按照分治思想进行操作即可。</p></blockquote><hr><h3 id="5-bang—逻辑非"><a href="#5-bang—逻辑非" class="headerlink" title="5. bang—逻辑非"></a><strong>5. bang—逻辑非</strong></h3><p><strong>题目：</strong></p><pre><code>计算 !x 而不使用逻辑非!</code></pre><p><strong>样例：</strong></p><pre><code>bang(3) = 0, bang(0) = 1</code></pre><p><strong>可使用操作：</strong> ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 12</p><p><strong>使用操作数：</strong> 6</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bang</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">return</span> ((x &gt;&gt; <span class="hljs-number">31</span>) | ((~x + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">31</span>)) + <span class="hljs-number">1</span>;&#125;</code></pre></p><p><strong>分析：</strong></p><ul><li>逻辑非<blockquote><p>对于逻辑非运算，应该都很熟悉，!x 当且仅当x为0时其为1，其余时候都为0，可以用来区分零和非零数。</p></blockquote></li></ul><blockquote><p>该问题的关键就是在于如何区分零和非零数，我们知道零的二补码仍然是零，而对于其余非零数，其符号位会有相应改变，利用这一性质，我们可以对零和非零数做出区分。</p><p>使用 <code>((x &gt;&gt; 31) | ((~x + 1) &gt;&gt; 31))</code>，将二进制数x的符号位与其补码左移31位相与，如若是非零数，其中符号位至少有一个为1，所以经过31位的算数右移后，其中一项必为-1，一项为0，相与之后得到-1,。而对于0来说，结果始终为0。</p><p>最后只要将结果+1，就能得到逻辑非的效果。</p></blockquote><hr><h3 id="6-tmin—最小数"><a href="#6-tmin—最小数" class="headerlink" title="6. tmin—最小数"></a><strong>6. tmin—最小数</strong></h3><p><strong>题目：</strong></p><pre><code>返回二补码中最小的数</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 4</p><p><strong>使用操作数：</strong> 1</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tmin</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>此题非常简单，我们知道计算机中负数是用其补码表示的，int所能表示的最小数为0x80000000(-2^31), 即符号位为1，其余皆为0，所以只要将1左移31位即可。</p></blockquote><hr><h3 id="7-fitsBits—填充比特"><a href="#7-fitsBits—填充比特" class="headerlink" title="7. fitsBits—填充比特"></a><strong>7. fitsBits—填充比特</strong></h3><p><strong>题目：</strong></p><pre><code>返回1如果x可以表示为n位二补码，反之返回0 (1 &lt;= n &lt;= 32)</code></pre><p><strong>样例：</strong></p><pre><code>fitsBits(5,3) = 0, fitsBits(-4,3) = 1</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 15</p><p><strong>使用操作数：</strong> 7</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fitsBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">int</span> k = x &gt;&gt; (n + ~<span class="hljs-number">0</span>); <span class="hljs-comment">// if can k = 0 or -1</span>  <span class="hljs-keyword">return</span> !k | !(k + <span class="hljs-number">1</span>);&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>我们知道如若一个数能够被n位二进制数表示，则其第n位即最高位是符号位，那么将其右移n-1位后，根据算术右移，其得到的结果不是0，就是1。否则表示，其还有高于n位的位数， 即不能用n位表示。</p><p>所以用 k = x &gt;&gt; (n + ~0) 表示将其右移n-1位，再用 !k | !(k + 1) 判断k是否为0或-1</p></blockquote><hr><h3 id="8-divpwr2—除以2的n次方"><a href="#8-divpwr2—除以2的n次方" class="headerlink" title="8. divpwr2—除以2的n次方"></a><strong>8. divpwr2—除以2的n次方</strong></h3><p><strong>题目：</strong></p><pre><code>计算 x/(2^n), (0 &lt;= n &lt;= 30)</code></pre><p><strong>样例：</strong></p><pre><code>divpwr2(15,1) = 7, divpwr2(-33,4) = -2</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 15</p><p><strong>使用操作数：</strong> 7</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divpwr2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> sign = x &gt;&gt; <span class="hljs-number">31</span>;    <span class="hljs-keyword">int</span> bias = (<span class="hljs-number">1</span> &lt;&lt; n) + ~<span class="hljs-number">0</span>;    x = x + (bias &amp; sign);    <span class="hljs-keyword">return</span> x &gt;&gt; n;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>本题的难点在于Round toward zero, 我们知道除以2的n次方即为将x右移n位。对于正数，尾数截断，因而自然向0舍入。而对于负数则不是如此，经试验在gcc上对于负数，其是向偶数舍入的，因而我们要对负数进行操作。</p><p>同时由于其向偶数舍入，我们不能简单地对负数进行+1操作，例如原本正确的 -7/4 = -1.25 = -1，但是经过+1操作后变为-6/4 = -1.5 Round toward even则变为了2。所以我们不应简单加一，而是加一个偏差值，其为2^n - 1，对于-7/4来说，就是3，加上bias之后得到(-7 + 3)/4即为-1。</p><p>所以我们构造bias = (1 &lt;&lt; n) + ~0 (由于不能用减号，-1用+~0表示)，然后我们要记得将sign取出，在x进行加操作时先检查一下x是否是负数，再进行操作。最后只要方向的将x右移n位即可。</p></blockquote><hr><h3 id="9-negate—取负"><a href="#9-negate—取负" class="headerlink" title="9. negate—取负"></a><strong>9. negate—取负</strong></h3><p><strong>题目：</strong></p><pre><code>返回-x</code></pre><p><strong>样例：</strong></p><pre><code>negate(1) = -1.</code></pre><p><strong>可使用操作：</strong>  ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 5</p><p><strong>使用操作数：</strong> 2</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">negate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">return</span> ~x + <span class="hljs-number">1</span>;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>很简单，对于有符号二进制数取负就是取其补码，而补码等于其取反加一，返回取反加一即可。</p></blockquote><hr><h3 id="10-isPositive—是正数"><a href="#10-isPositive—是正数" class="headerlink" title="10. isPositive—是正数"></a><strong>10. isPositive—是正数</strong></h3><p><strong>题目：</strong></p><pre><code>返回1如果x大于0，反之返回0</code></pre><p><strong>样例：</strong></p><pre><code>isPositive(-1) = 0.</code></pre><p><strong>可使用操作：</strong>  ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 8</p><p><strong>使用操作数：</strong> 5</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">return</span> !(x &gt;&gt; <span class="hljs-number">31</span>) &amp; !!x;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>这题关键在于把0剔除了，区分正负数就是区分其符号位，将x右移31位，负数得-1，正数为0，用一个逻辑非使正数为1，负数为0，然后再和!!x与一下就能剔除0</p></blockquote><ul><li>!!x 当 x == 0 时返回 0，不为 0 时返回 1</li></ul><hr><h3 id="11-isLessOrEqual—小于等于"><a href="#11-isLessOrEqual—小于等于" class="headerlink" title="11. isLessOrEqual—小于等于"></a><strong>11. isLessOrEqual—小于等于</strong></h3><p><strong>题目：</strong></p><pre><code>如果x小于等于y返回1，反之返回0</code></pre><p><strong>样例：</strong></p><pre><code>isLessOrEqual(4,5) = 1.</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 24</p><p><strong>使用操作数：</strong> 14</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;  <span class="hljs-keyword">int</span> res = y + (~x + <span class="hljs-number">1</span>); <span class="hljs-comment">// y - x</span>  <span class="hljs-keyword">int</span> xSign = x &gt;&gt; <span class="hljs-number">31</span>;  <span class="hljs-keyword">int</span> ySign = y &gt;&gt; <span class="hljs-number">31</span>;  <span class="hljs-keyword">int</span> dif = ~xSign + ySign;  <span class="hljs-keyword">return</span> (~(dif + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">31</span>) &amp; !(res &gt;&gt; <span class="hljs-number">31</span>)) | !dif;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>我在这里采取了作差的方法 res = y + (~x + 1)，即计算一下y-x，判断其是否非负，同时也要考虑溢出问题，即 x 为负数，y为正数，y-x后溢出为负。</p><p>我将x,y右移31位代表其符号，若负则为-1，若正为0。我同时构造了一个 dif 以表示x,y符号之间的关系。</p><p><strong>dif = ~xSign + ySign</strong></p><ol><li>当 x &lt; 0 &amp;&amp; y &lt; 0 时，dif = -1 </li><li>当 x &lt; 0 &amp;&amp; y &gt; 0 时，dif = 0 </li><li>当 x &gt; 0 &amp;&amp; y &lt; 0 时，dif = -2 </li><li>当 x &gt; 0 &amp;&amp; y &lt; 0 时，dif = -1</li></ol><p>将 x,y 符号之间的关系表达出来，把 dif 加一我们可以观察到当 x,y 同号时，dif为0，所以将其取反和 !(res &gt;&gt; 31) 相与，就可以表示同号不溢出的情况，而当 x &lt; 0, y &gt; 0 的情况发生时，我们注意到 dif 就是 0 ，所以我们直接或上 !dif 即可表达这种情况。</p></blockquote><hr><h3 id="12-ilog2—以2为底的对数"><a href="#12-ilog2—以2为底的对数" class="headerlink" title="12. ilog2—以2为底的对数"></a><strong>12. ilog2—以2为底的对数</strong></h3><p><strong>题目：</strong></p><pre><code>返回x取以2为底的对数并向下取整，输入的 x &gt; 0</code></pre><p><strong>样例：</strong></p><pre><code>ilog2(16) = 4</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 90</p><p><strong>使用操作数：</strong> 48</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ilog2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">int</span> tmp, l1, l2, l4, l8, l16;  x |= x &gt;&gt; <span class="hljs-number">1</span>;  x |= x &gt;&gt; <span class="hljs-number">2</span>;  x |= x &gt;&gt; <span class="hljs-number">4</span>;  x |= x &gt;&gt; <span class="hljs-number">8</span>;  x |= x &gt;&gt; <span class="hljs-number">16</span>;    tmp = (<span class="hljs-number">0x55</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x55</span>;  l1 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;  tmp = (<span class="hljs-number">0x33</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x33</span>;  l2 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;  tmp = (<span class="hljs-number">0x0f</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x0f</span>;  l4 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;  l8 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">16</span>) + <span class="hljs-number">0xff</span>;  l16 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xff</span>;  x = (x &amp; l1) + ((x &gt;&gt; <span class="hljs-number">1</span>) &amp; l1);  x = (x &amp; l2) + ((x &gt;&gt; <span class="hljs-number">2</span>) &amp; l2);  x = (x &amp; l4) + ((x &gt;&gt; <span class="hljs-number">4</span>) &amp; l4);  x = (x &amp; l8) + ((x &gt;&gt; <span class="hljs-number">8</span>) &amp; l8);  x = (x &amp; l16) + ((x &gt;&gt; <span class="hljs-number">16</span>) &amp; l16);  <span class="hljs-keyword">return</span> x + ~<span class="hljs-number">0</span>;</code></pre><p><strong>分析：</strong></p><blockquote><p>我们知道二进制数每位有其位权，所以对 x 取以2为底的对数就是指其为1的最高位的位权。为了获得最高位的位置，其实我们可以将其最高位往下全部变为1，再类似bitsCount数其中1的个数就行了。</p><p>我把 x 移位相与，保证最高位往下所有数字为1，再使用bitsCount就得到答案。</p><p>最后不要忘记减一</p></blockquote><hr><h3 id="13-float-neg—浮点数的负数"><a href="#13-float-neg—浮点数的负数" class="headerlink" title="13. float_neg—浮点数的负数"></a><strong>13. float_neg—浮点数的负数</strong></h3><p><strong>题目：</strong></p><pre><code>返回-f，当NaN时，返回参数f</code></pre><p><strong>可使用操作：</strong> 所有的整型操作，包括 ||, &amp;&amp;. 以及 if, while</p><p><strong>最大操作数限制：</strong> 10</p><p><strong>使用操作数：</strong> 5</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_neg</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;  <span class="hljs-keyword">unsigned</span> <span class="hljs-built_in">exp</span> = uf &amp; <span class="hljs-number">0x7f800000</span>;  <span class="hljs-keyword">unsigned</span> frac = uf &amp; <span class="hljs-number">0x007fffff</span>;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> == <span class="hljs-number">0x7f800000</span> &amp;&amp; frac)    <span class="hljs-keyword">return</span> uf;  <span class="hljs-keyword">return</span> uf ^= <span class="hljs-number">0x80000000</span>;&#125;</code></pre></p><p><strong>分析：</strong></p><ul><li>IEEE-float<blockquote><p>我们知道IEEE单精度浮点数，最高位为符号位，其后8位为阶码exp，后23位为尾数frac。其牺牲了精度来扩大了表达范围。</p></blockquote></li></ul><blockquote><p>而当 exp 全 1 时，如若frac非全零，则表示NaN。若全零，则表示无穷大/小。</p><p>这里我们只要将原数和符号位0x80000000异或一下，即可取负。不要忘记排除NaN的情况。</p></blockquote><hr><h3 id="14-float-i2f—int转float"><a href="#14-float-i2f—int转float" class="headerlink" title="14. float_i2f—int转float"></a><strong>14. float_i2f—int转float</strong></h3><p><strong>题目：</strong></p><pre><code>把int类型的数转换为float表示(比特形式)</code></pre><p><strong>可使用操作：</strong> 所有的整型操作，包括 ||, &amp;&amp;. 以及 if, while</p><p><strong>最大操作数限制：</strong> 30</p><p><strong>使用操作数：</strong> 30</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_i2f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">unsigned</span> frac, mask1, mask2, mask3, mask4, d;  <span class="hljs-keyword">int</span> high = <span class="hljs-number">0x80000000</span>;  <span class="hljs-keyword">unsigned</span> sign = x &amp; <span class="hljs-number">0x80000000</span>;  <span class="hljs-keyword">unsigned</span> <span class="hljs-built_in">exp</span> = <span class="hljs-number">127</span>;  <span class="hljs-keyword">int</span> count = <span class="hljs-number">32</span>, i;  <span class="hljs-keyword">if</span>(sign)    x = ~x + <span class="hljs-number">1</span>;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!x)    <span class="hljs-keyword">return</span> x;    frac = x;  <span class="hljs-keyword">for</span>(;high; high &gt;&gt;= <span class="hljs-number">1</span>)  &#123;    --count;    <span class="hljs-keyword">if</span>(high &amp; x)      <span class="hljs-keyword">break</span>;  &#125;  i = count - <span class="hljs-number">23</span>;  mask1 = ~(<span class="hljs-number">1</span> &lt;&lt; count); <span class="hljs-comment">// the highest 1</span>  mask2 = <span class="hljs-number">1</span> &lt;&lt; i; <span class="hljs-comment">//the lowest of remain frac;</span>  mask3 = mask2 &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// the highest of deserted bits </span>  mask4 = mask2 - <span class="hljs-number">1</span>; <span class="hljs-comment">// the deserted bits</span>  <span class="hljs-built_in">exp</span> += count;  frac &amp;= mask1;    <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)  &#123;    d = frac &amp; mask4; <span class="hljs-comment">// deserted bits</span>    <span class="hljs-keyword">if</span>(d &gt; mask3 | (d == mask3 &amp;&amp; frac &amp; mask2))    &#123;      frac += mask2;      <span class="hljs-keyword">if</span>(frac &gt; <span class="hljs-number">0x3fffffff</span>)      &#123;        frac = <span class="hljs-number">0</span>;        <span class="hljs-built_in">exp</span>++;      &#125;    &#125;    frac &gt;&gt;= i;  &#125;  <span class="hljs-keyword">else</span>    frac &lt;&lt;= -i;  <span class="hljs-keyword">return</span> sign | <span class="hljs-built_in">exp</span> &lt;&lt; <span class="hljs-number">23</span> | frac;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>我认为这题比较难，我做了很久很久….它难在浮点数向偶数舍入以及其操作数的限制。</p><p>我们知道由于浮点数表示范围比整型大，我们可以将整型转换为浮点数，但是相应的会有一些精度的丢失，因为尾数frac只有23位，而int有31位可用。</p><p>所以其关键在于int的位数，一开始先把该取出来的都用掩码取出来，把负数和零处理一下。之后我利用了一个循环先找出int的最高位在哪，利用count计数。</p><p>后面我采取了四个掩码，分别代表最高位的1，留下的尾数中的最低位，要舍去的位数的最高位，以及舍弃的位数的掩码。利用这四个掩码我们可以达到存frac时，将其向<strong>偶数舍入</strong>。</p><p>具体操作是，先取出丢弃的尾数，将其存放在d中，看其有没有超过0.5 (即 d 是否大于 mask3) 如果大于，直接frac++就行。而如果等于的话，还要看frac是否是奇数 (即frac &amp; mask2是否为1) 如果是，则要向偶数舍入,frac++。</p><p>加完frac之后还要注意<strong>溢出问题</strong>，如果溢出了，要将frac置0，然后把阶码 exp++，再按照之前输出来的尾数移动，将尾数对齐即可 （位数最高默认为1不存，因而把最高位隐去）。</p><p>最后把符号位，阶码位和尾数位拼接，得到最后的结果。</p></blockquote><hr><h3 id="15-float-twice—float-2"><a href="#15-float-twice—float-2" class="headerlink" title="15. float_twice—float * 2"></a>15. float_twice—float * 2</h3><p><strong>题目：</strong></p><pre><code>返回float * 2, 当参数是NaN时，返回参数</code></pre><p><strong>可使用操作：</strong> 所有的整型操作，包括 ||, &amp;&amp;. 以及 if, while</p><p><strong>最大操作数限制：</strong> 30</p><p><strong>使用操作数：</strong> 20</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_twice</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;  <span class="hljs-keyword">unsigned</span> sign = uf &amp; <span class="hljs-number">0x80000000</span>;  <span class="hljs-keyword">unsigned</span> <span class="hljs-built_in">exp</span> = uf &amp; <span class="hljs-number">0x7f800000</span>;  <span class="hljs-keyword">unsigned</span> frac = uf &amp; <span class="hljs-number">0x007fffff</span>;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> == <span class="hljs-number">0x7f800000</span>) <span class="hljs-comment">//NaN &amp; inf</span>    <span class="hljs-keyword">return</span> uf;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">exp</span> &amp;&amp; !frac) <span class="hljs-comment">// 0</span>    <span class="hljs-keyword">return</span> uf;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">exp</span> &amp;&amp; frac &lt;= <span class="hljs-number">0x3fffff</span>)  <span class="hljs-comment">// low</span>    frac *= <span class="hljs-number">2</span>;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">exp</span> &amp;&amp; frac &gt; <span class="hljs-number">0x3fffff</span>) <span class="hljs-comment">// high</span>  &#123;    <span class="hljs-built_in">exp</span> += <span class="hljs-number">0x00800000</span>;    frac = (frac * <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x7fffff</span>;  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-comment">// normal</span>    <span class="hljs-built_in">exp</span> += <span class="hljs-number">0x00800000</span>;  <span class="hljs-keyword">return</span> sign + <span class="hljs-built_in">exp</span> + frac;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>主要要分析的地方，在于当阶码exp为0时，是否在乘2之后进位。所以要考虑尾数是否大于0x3fffff，如果小于等于之，则直接尾数乘2就行，不会溢出，否则则exp要进位，同时尾数乘2之后要与上0x7fffff保证不溢出。</p><p>其他正常情况直接exp++就行，注意一下特殊情况;</p></blockquote><p><em>本题中测试集中有一个inf，也要直接返回参数uf</em></p><hr><h2 id="Bits-honor-c"><a href="#Bits-honor-c" class="headerlink" title="Bits_honor.c"></a><strong>Bits_honor.c</strong></h2><h3 id="1-bitReverse—比特翻转"><a href="#1-bitReverse—比特翻转" class="headerlink" title="1. bitReverse—比特翻转"></a><strong>1. bitReverse—比特翻转</strong></h3><p><strong>题目：</strong></p><pre><code>把32比特int的比特位翻转</code></pre><p><strong>样例：</strong></p><pre><code>bitReverse(0x80000004) = 0x20000001bitReverse(0x7FFFFFFF) = 0xFFFFFFFE</code></pre><p><strong>最大操作数限制：</strong> 40</p><p><strong>使用操作数：</strong> 40</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitReverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> tmp,l1, l2, l4, l8, l16;   tmp = (<span class="hljs-number">0x55</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x55</span>;   l1 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;   tmp = (<span class="hljs-number">0x33</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x33</span>;   l2 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;   tmp = (<span class="hljs-number">0x0f</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x0f</span>;   l4 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;   l8 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">16</span>) + <span class="hljs-number">0xff</span>;   l16 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xff</span>;   x = ((x &gt;&gt; <span class="hljs-number">16</span>) &amp; l16) | (x &lt;&lt; <span class="hljs-number">16</span>);   x = ((x &gt;&gt; <span class="hljs-number">8</span>) &amp; l8) | ((x &amp; l8) &lt;&lt; <span class="hljs-number">8</span>);   x = ((x &gt;&gt; <span class="hljs-number">4</span>) &amp; l4) | ((x &amp; l4) &lt;&lt; <span class="hljs-number">4</span>);   x = ((x &gt;&gt; <span class="hljs-number">2</span>) &amp; l2) | ((x &amp; l2) &lt;&lt; <span class="hljs-number">2</span>);   x = ((x &gt;&gt; <span class="hljs-number">1</span>) &amp; l1) | ((x &amp; l1) &lt;&lt; <span class="hljs-number">1</span>);   <span class="hljs-keyword">return</span> x;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>这题和 bitsCount 有异曲同工之妙，也是一个分治法，将32位二进制数一分为二，交换，再将内部各自再一分为二，交换，直至最底层2位二进制数互换位置，最后完成了将所有位数翻转的工作。</p><p>但值得注意的是，给出的是有符号的int，所以在右移交换位置时，会发生因为负数算术右移导致高位全是1的情况，致使在与的过程中高位全部变为1。这边只要将其移动后在和掩码相与就能解决这一问题。而对于低位，先与掩码相与再移动，可以省去取反得到高位掩码的操作数。再用tmp省一下操作数。</p><p>最后操作数正好卡在40</p></blockquote><hr><h3 id="2-mod3—取模3"><a href="#2-mod3—取模3" class="headerlink" title="2. mod3—取模3"></a><strong>2. mod3—取模3</strong></h3><p><strong>题目：</strong></p><pre><code>计算 x 取模 3，而不用%</code></pre><p><strong>样例：</strong></p><pre><code>mod3(100) = 1mod3(-100) = -1</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 90</p><p><strong>使用操作数：</strong> 24</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mod3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> mask = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xff</span>;   x = (x &gt;&gt; <span class="hljs-number">16</span>) + (x &amp; mask); <span class="hljs-comment">// sum base 4^8 digits (a &lt;= 0x1FFFE)</span>   x = (x &gt;&gt; <span class="hljs-number">8</span>) + (x &amp; <span class="hljs-number">0xff</span>); <span class="hljs-comment">// sum base 4^4 digits (a &lt;= 0x2FD)</span>   x = (x &gt;&gt; <span class="hljs-number">4</span>) + (x &amp; <span class="hljs-number">0xf</span>); <span class="hljs-comment">// sum base 4^2 digits (a &lt;= 0x3C)</span>   x = (x &gt;&gt; <span class="hljs-number">2</span>) + (x &amp; <span class="hljs-number">0x3</span>); <span class="hljs-comment">// sum base 4^1 digits (a &lt;= 0x1D)</span>   x = (x &gt;&gt; <span class="hljs-number">2</span>) + (x &amp; <span class="hljs-number">0x3</span>); <span class="hljs-comment">// sum base 4^1 digits (a &lt;= 0x9)</span>   x = (x &gt;&gt; <span class="hljs-number">2</span>) + (x &amp; <span class="hljs-number">0x3</span>); <span class="hljs-comment">// sum base 4^1 digits (a &lt;= 0x4)</span>   x = (((x + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">2</span>) + x) &amp; <span class="hljs-number">0x3</span>;   <span class="hljs-keyword">return</span> x;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>这题难度算是比较大的，我参考了一些资料最后才写出这个代码。其实这题也与bitsCount有着一定的联系。</p><p>对于解这题有一个根本的公式即 </p></blockquote><pre><code>a % m = ((b % m)(a/b) + (a % b)) % m其中b是进制数</code></pre><blockquote><p>我们知道，如果想要知道一个十进制的数能否被三整除，只要看它所有数位之和是否能被三整除就行了。其实这就是上述公式的特殊情况，由于10 mod 3 == 1 所以其就退化为</p></blockquote><pre><code>a mod m = (a/b + a % b) % m递归下来就是所有数位之和</code></pre><blockquote><p>而对于二进制的情况，我们可以将进制位b选为4，这样正好是两位二进制数，同时4 % 3 == 1，这样一来，对于二进制数中我们只需要统计所有两两数位(四进制)的和能否被三整除就行了。</p><p>而考虑到我们每做一次 a/b + a % b 统计数位和都减小了数的规模，这样只要做有限次就能够将数控制在&lt;=3的范围内。</p><p>对于a % 4，这是一个经典的trivial情况，我们只需要做 a &amp; 3，就能够轻松得到a % 4的值。而对于a/4，只需要做a &gt;&gt; 2即可。</p><p>对于二进制数我们不仅可以按两位两位的四进制数位和来数，也可以直接数其倍数(4^i)，从最大4^8开始统计，一步步减小x的值，最后将x做到&lt;= 3的范围</p><p>最后要判断x是否为3，如果为3的话则要置为0，我利用3数位全为1的特点，将其+1进位后，右移2位。如果为3，则得到的是1。将其再加上x，如若x是1或2，则还是不变，但如果是3，它又会进位到4，那么我们只要再与上0x3，则会得到0，即为想要的结果。</p></blockquote><hr><h3 id="3-float-f2i—float转int"><a href="#3-float-f2i—float转int" class="headerlink" title="3. float_f2i—float转int"></a><strong>3. float_f2i—float转int</strong></h3><p><strong>题目：</strong></p><pre><code>输入一个按二进制位储存的float（以unsigned表示），将其转为int输出。(NaN,inf，溢出直接返回参数)</code></pre><p><strong>可使用操作：</strong> 所有的整型操作，包括 ||, &amp;&amp;. 以及 if, while</p><p><strong>最大操作数限制：</strong> 30</p><p><strong>使用操作数：</strong> 17</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">float_f2i</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> sign, <span class="hljs-built_in">exp</span>, frac, res;   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> tmp;   <span class="hljs-keyword">if</span>(!uf)      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   sign = uf &amp; <span class="hljs-number">0x80000000</span>;   <span class="hljs-built_in">exp</span> = uf &amp; <span class="hljs-number">0x7f800000</span>;   frac = (uf &amp; <span class="hljs-number">0x007fffff</span>) | <span class="hljs-number">0x00800000</span>;   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> == <span class="hljs-number">0x7f800000</span>) <span class="hljs-comment">//NaN and inf</span>      <span class="hljs-keyword">return</span> <span class="hljs-number">0x80000000</span>u;   <span class="hljs-built_in">exp</span> &gt;&gt;= <span class="hljs-number">23</span>;   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> &lt; <span class="hljs-number">127</span>)      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">158</span>)      <span class="hljs-keyword">return</span> <span class="hljs-number">0x80000000</span>u;   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">150</span>)      tmp = frac &lt;&lt; (<span class="hljs-built_in">exp</span> - <span class="hljs-number">150</span>);   <span class="hljs-keyword">else</span>      tmp = frac &gt;&gt; (<span class="hljs-number">150</span> - <span class="hljs-built_in">exp</span>);         <span class="hljs-keyword">if</span>(sign)      res = ~tmp + <span class="hljs-number">1</span>;   <span class="hljs-keyword">else</span>      res = tmp;      <span class="hljs-keyword">return</span> res | sign;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>这题特殊情况比较多，把NaN和inf处理一下，然后注意一下溢出情况，即取出来的exp - bias &gt; 31，肯定超过2^31整型储存的最大值，直接返回0x80000000u，然后对于exp小于127的，其指数是负数，直接返回int值为0。对于在exp - bias 在 0 到 31 之间的，由于frac只有23位，所以要将注意一下讨论23的情况。</p><p>最后把取出来的符号位对一下，如果负数取反加一，正数直接等，最后再或上符号位，返回答案。</p></blockquote><hr><h2 id="结果截图"><a href="#结果截图" class="headerlink" title="结果截图"></a><strong>结果截图</strong></h2><h3 id="bits-c"><a href="#bits-c" class="headerlink" title="bits.c"></a><strong>bits.c</strong></h3><p><img src="/2020/11/05/ICS/ICS_Lab1/ICS_Lab1/bits_btest.JPG" alt="bits_btest"></p><p><img src="/2020/11/05/ICS/ICS_Lab1/ICS_Lab1/bits_dlc.png" alt="bits_dlc"></p><h3 id="bits-honor-c"><a href="#bits-honor-c" class="headerlink" title="bits_honor.c"></a><strong>bits_honor.c</strong></h3><p><img src="/2020/11/05/ICS/ICS_Lab1/ICS_Lab1/bits_honor_btest.JPG" alt="bits_honor_btest"></p><p><img src="/2020/11/05/ICS/ICS_Lab1/ICS_Lab1/bits_honor_dlc.png" alt="bits_honor_dlc"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><p><a href="https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E5%8F%B3%E7%A7%BB/3711081?fr=aladdin">https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E5%8F%B3%E7%A7%BB/3711081?fr=aladdin</a><br><a href="https://blog.csdn.net/jiahonghao2002/article/details/108223366">https://blog.csdn.net/jiahonghao2002/article/details/108223366</a><br><a href="https://leetcode-cn.com/problems/reverse-bits/solution/dian-dao-er-jin-zhi-wei-by-leetcode/">https://leetcode-cn.com/problems/reverse-bits/solution/dian-dao-er-jin-zhi-wei-by-leetcode/</a><br><a href="http://homepage.cs.uiowa.edu/~jones/bcd/mod.shtml#exmod3">http://homepage.cs.uiowa.edu/~jones/bcd/mod.shtml#exmod3</a><br><a href="https://www.zhihu.com/question/38206659/answer/763034261">https://www.zhihu.com/question/38206659/answer/763034261</a><br><a href="https://blog.csdn.net/xindaxinda123/article/details/95617758">https://blog.csdn.net/xindaxinda123/article/details/95617758</a><br><a href="https://www.runoob.com/w3cnote/32-float-storage.html">https://www.runoob.com/w3cnote/32-float-storage.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bits</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/11/05/hello-world/"/>
    <url>/2020/11/05/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="第一篇博客用以测试"><a href="#第一篇博客用以测试" class="headerlink" title="第一篇博客用以测试"></a>第一篇博客用以测试</h2><h3 id="一、-下面是一段C-代码"><a href="#一、-下面是一段C-代码" class="headerlink" title="一、 下面是一段C++代码"></a>一、 下面是一段C++代码</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Hello World!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre><h3 id="二、-下面是一段表格"><a href="#二、-下面是一段表格" class="headerlink" title="二、 下面是一段表格"></a>二、 下面是一段表格</h3><div class="table-container"><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td></tr></tbody></table></div><h3 id="三、-下面是一段-Latex"><a href="#三、-下面是一段-Latex" class="headerlink" title="三、 下面是一段 Latex"></a>三、 下面是一段 Latex</h3><script type="math/tex; mode=display">E= mc^2</script><h3 id="四、下面是一张图片"><a href="#四、下面是一张图片" class="headerlink" title="四、下面是一张图片"></a>四、下面是一张图片</h3><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRP-ciAYVH8UlH3ZaZC3NkN3ow9CrG36O5crg&amp;usqp=CAU" alt></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
