<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CS231n Convolutional_Neural_Networks 04</title>
    <link href="/CsBlog/2020/11/11/CS231n-04-Convolutional-Neural-Networks/"/>
    <url>/CsBlog/2020/11/11/CS231n-04-Convolutional-Neural-Networks/</url>
    
    <content type="html"><![CDATA[<h3 id="A-bit-of-CNN-History"><a href="#A-bit-of-CNN-History" class="headerlink" title="A bit of CNN History"></a>A bit of CNN History</h3><p><img src="https://s1.ax1x.com/2020/11/11/BOGJ5n.png"></p><p><img src="https://s1.ax1x.com/2020/11/11/BOGGUs.png"></p><h4 id="Fully-Connected-Layer"><a href="#Fully-Connected-Layer" class="headerlink" title="Fully Connected Layer"></a>Fully Connected Layer</h4><p><img src="https://s1.ax1x.com/2020/11/11/BOGlDg.png"></p><h4 id="Convolution-Layer"><a href="#Convolution-Layer" class="headerlink" title="Convolution Layer"></a>Convolution Layer</h4><p><img src="https://s1.ax1x.com/2020/11/11/BOG1bQ.png"></p><blockquote><p>We just let the 5x5x3 filter $w$ to take a dot product between itself and a small 5x5z3 chunck of the image</p></blockquote><p>$$W^Tx+b$$<br><strong>The $W$ and $x$ is streched into 1 dimention vec</strong></p><ul><li>Then the Outcome:</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOG8Ej.png"></p><blockquote><p>We can use different layers on the top of it and get more activation maps stack them together to get a new image, just as the following pic depicted.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/11/BOGtCq.png"></p><blockquote><p>Then we can recursively do that work, make the front layer’s output be the next layer’s input</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/11/BOGU2V.png"></p><p><strong>The Layers may look like..</strong><br><em>Simple -&gt; Complex</em></p><p><img src="https://s1.ax1x.com/2020/11/11/BOGN80.png"></p><p><img src="https://s1.ax1x.com/2020/11/11/BOGrVJ.png"></p><ul><li>The Convolution of two signals:</li></ul><p>$$f[x,y]*g[x,y] = \sum\limits_{n_1 = -\infin}^{\infin}\sum\limits_{n_2 = -\infin}^{\infin}f[n_1,n_2]·g[x-n_1,y-n_2]$$</p><ul><li>A little bit preview</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOG0rF.png"></p><hr><ul><li>Convolution Box</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOGwKU.png"></p><blockquote><p>We can tell that the activation maps are becomming smaller after the filter, so we commonly use zero pad to deal with it.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/11/BOGBb4.png"></p><p><img src="https://s1.ax1x.com/2020/11/11/BOGsa9.png"></p><blockquote><p>The Matrix shrinks from 32 —&gt; 28 -&gt; 24 (lose info)</p></blockquote><hr><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ol><li>Accepts a volume of size $W_1 * H_1 * D_1$</li><li>Four Hyperparas<ul><li>Number of filters $K$</li><li>spatial extent $F$</li><li>stride $S$</li><li>zero padding amount $P$</li></ul></li><li>Produces a volume of size $W_2 * H_2 * D_2$<ul><li>$W_2 = (W_1 - F + 2P)/S + 1$</li><li>$H_2 = (H_1 - F + 2P)/S + 1$</li><li>$D_2 = K$ <em>Depth keeps the same</em></li></ul></li></ol><h4 id="Common-Settings"><a href="#Common-Settings" class="headerlink" title="Common Settings"></a>Common Settings</h4><p>K = (powers of 2)</p><ul><li>F = 3, S = 1, P =1</li><li>F = 5, S = 1, P =2</li><li>F = 1, S = 1, P = 0 </li></ul><hr><h3 id="Conv-details"><a href="#Conv-details" class="headerlink" title="Conv details"></a>Conv details</h3><ul><li>One by One CONV</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOGy5R.png"></p><ul><li>EXAMPLE: CONV in pyTorch</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOGRxK.png"></p><ul><li>The Brain/Neuron View of CONV</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOG226.png"></p><ul><li>Pooling layer</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOGg8x.png"></p><blockquote><p>Just spacially down sample the image to make it smaller.<br>Common Practice is Max Pooling</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/11/BOGcP1.png"></p><blockquote><p>We may can just use stride to replace pooling?</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Introduction to Convolutional neural network 03</title>
    <link href="/CsBlog/2020/11/10/CS231n-03-Introduction-to-Convolutional-neural-network/"/>
    <url>/CsBlog/2020/11/10/CS231n-03-Introduction-to-Convolutional-neural-network/</url>
    
    <content type="html"><![CDATA[<h3 id="Computational-graphs"><a href="#Computational-graphs" class="headerlink" title="Computational graphs"></a>Computational graphs</h3><p><img src="https://s1.ax1x.com/2020/11/10/BbDAaD.png"></p><h3 id="BackPropagation-A-method-to-compute-the-gradients-of-abitrarily-complex-function"><a href="#BackPropagation-A-method-to-compute-the-gradients-of-abitrarily-complex-function" class="headerlink" title="BackPropagation - A method to compute the gradients of abitrarily complex function"></a>BackPropagation - A method to compute the gradients of abitrarily complex function</h3><ul><li>A recursive application of Chain rule</li></ul><p><img src="https://s1.ax1x.com/2020/11/10/BbDCKx.png"></p><blockquote><p>We get the gradient backprop from the front and comupte with the local gradient to prop to the back.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/10/BbDPr6.png"></p><blockquote><p>In some cases, some part of the graph can be represented by some func that we already know to simplify the computations. (trade off the math)</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/10/BbDiqK.png"></p><ul><li>Patterns in backward flow</li></ul><ol><li><strong>add gate:</strong> gradient distributor (local = 1)</li><li><strong>max gate:</strong> gradient distributor (local = 1 &amp; 0)</li><li><strong>mul gate:</strong> gradient switcher (local = y &amp; x )</li></ol><p><em>Gradients add at branches n-&gt;1</em></p><ul><li>Then We Got the gradients in the form of Jacobian Matrix</li></ul><p><img src="https://s1.ax1x.com/2020/11/10/BbDkVO.png"></p><p><img src="https://s1.ax1x.com/2020/11/10/BbDZPH.png"></p><p><em>This place include some linear algebra</em></p><h3 id="Modularized-implementation-Forward-Backward-API"><a href="#Modularized-implementation-Forward-Backward-API" class="headerlink" title="Modularized implementation: Forward / Backward API"></a>Modularized implementation: Forward / Backward API</h3><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComputationalGraph</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">inputs</span>):</span>        <span class="hljs-comment"># 1. pass inputs to input gates</span>        <span class="hljs-comment"># 2. forward the computational graph</span>        <span class="hljs-keyword">for</span> gate <span class="hljs-keyword">in</span> self.graph.nodes_topologically_sorted():            gate.forward()        <span class="hljs-keyword">return</span> loss    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backward</span>():</span>        <span class="hljs-keyword">for</span> gate <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(self.graph.nodes_topologically_sorted())            gate.backward() <span class="hljs-comment"># compute the gradients</span>        <span class="hljs-keyword">return</span> inputs_gradients</code></pre><h4 id="EXAMPLE-MulGate"><a href="#EXAMPLE-MulGate" class="headerlink" title="EXAMPLE: MulGate"></a>EXAMPLE: MulGate</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiplyGate</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">x, y</span>):</span>        z = x*y        self.x = x        self.y = y    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backward</span>(<span class="hljs-params">dz</span>):</span>        dx = self.y * z        dy = self.x * z        <span class="hljs-keyword">return</span> [dx, dy]</code></pre><blockquote><p>This practice is common.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/10/BbDeGd.png"></p><h3 id="Summary-so-Far"><a href="#Summary-so-Far" class="headerlink" title="Summary so Far"></a>Summary so Far</h3><p><img src="https://s1.ax1x.com/2020/11/10/BbDmRA.png"></p><h3 id="Neural-networks"><a href="#Neural-networks" class="headerlink" title="Neural networks"></a>Neural networks</h3><p>(Before) Linear score function: $f = Wx$<br>(Now) 2-layers Neural Network $f = W_2max(0, W_1x)$<br>….or more layers</p><p><img src="https://s1.ax1x.com/2020/11/10/BbDEIe.png"></p><blockquote><p>The h is the scores W1 output, and we put one more linear layer W2 on the top of it to weighting the scores given by h </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS231n</tag>
      
      <tag>Stanford</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Loss Functions and Optimization 02</title>
    <link href="/CsBlog/2020/11/08/CS231n_02_Loss-Functions-and-Optimization/"/>
    <url>/CsBlog/2020/11/08/CS231n_02_Loss-Functions-and-Optimization/</url>
    
    <content type="html"><![CDATA[<h3 id="Preview-the-Goal-in-this-lecture"><a href="#Preview-the-Goal-in-this-lecture" class="headerlink" title="Preview the Goal in this lecture"></a>Preview the Goal in this lecture</h3><ol><li>Define a loss function</li><li>Come up with a way of finding the paras that minimize the (1)<br>(optimization)</li></ol><p><strong>The Remain Problem from last lecture</strong></p><ul><li>How to choose the W para ? </li></ul><p><img src="https://s1.ax1x.com/2020/11/08/BTZxgK.png"></p><h3 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h3><blockquote><p>A loss function tells how good our current classifier is.</p></blockquote><p>$${(x_i,y_i)}_{i=1}^N$$</p><p>The $X_i$ is image and the $y_i$ is label (int)</p><p>The Total loss is defined as the func follows.</p><p>$$L = \frac{1}{N}\sum\limits_iL_i(f(x_i,W),y_i)$$<br><em>Which is the sum of every single test’s loss</em></p><hr><h4 id="Muticlass-SVM-loss"><a href="#Muticlass-SVM-loss" class="headerlink" title="Muticlass SVM loss"></a><strong>Muticlass SVM loss</strong></h4><p>Given an example $(x_i,y_i)$ where $x_i$ is the image and where $y_i$ is the (int) label, using the shorthand for the score vec $s = f(x_i,W)$</p><p>The SVM loss has the form:</p><p><img src="https://s1.ax1x.com/2020/11/08/BTZ7B4.png"></p><blockquote><p>if the incorrect score is smaller than the right score (x margin), we set the loss to 0.<br>in this case the safe margin is set to one<br><strong>Margin choice depends on our need</strong></p></blockquote><ul><li>Then we loop the class</li></ul><p><img src="https://s1.ax1x.com/2020/11/08/BTZqE9.png"></p><p><img src="https://s1.ax1x.com/2020/11/08/BTZLNR.png"></p><ul><li>What if we use</li></ul><p>$$L = \frac{1}{N}\sum\limits_iL_i(f(x_i,W),y_i)^2$$</p><blockquote><p>This is not a linear function and totally different, it’s may be useful sometimes depends on the way you care about the errors.</p></blockquote><h4 id="Example-Code"><a href="#Example-Code" class="headerlink" title="Example Code"></a>Example Code</h4><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">L_i_vectorized</span>(<span class="hljs-params">x, y, W</span>):</span>    scores = W.dot(x)    margins = np.maximun(<span class="hljs-number">0</span>, scores - scores[y] + margin)    margins[y] = <span class="hljs-number">0</span>    loss_i = np.<span class="hljs-built_in">sum</span>(margins)    <span class="hljs-keyword">return</span> loss_i    <span class="hljs-comment"># pretty easy</span></code></pre><p><img src="https://s1.ax1x.com/2020/11/08/BTZO41.png"></p><blockquote><p>It just change the gap bettween scores</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTZzjO.png"></p><p><img src="https://s1.ax1x.com/2020/11/08/BTe9De.png"></p><blockquote><p>often use L2 regularization just Euclid norm.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTepuD.png"></p><blockquote><p>In this case the L1 and L2 reg is equal, but we can tell that L1 prefers the $w_1$ for it contains more zero, while the L2 prefers the $w_2$ for the weight is evenly spreaded through the test case.</p></blockquote><blockquote><p>The Multiclass SVM loss just care about the gap bettween the right labels and the wrongs.</p></blockquote><h4 id="Softmax-Classifier"><a href="#Softmax-Classifier" class="headerlink" title="Softmax Classifier"></a><strong>Softmax Classifier</strong></h4><p><img src="https://s1.ax1x.com/2020/11/08/BTeiEd.png"></p><blockquote><p>We just want to make the true probability closer to 1 (closer the better, eq is the best), so the loss func can be chosed by using the -log on the $P$.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTeCHH.png"></p><blockquote><p>If we want to get the zero loss, the score may goes to inf! But Computer don’t like that.</p></blockquote><ul><li>Debugging Way<br>outcomes might be $logC$</li></ul><hr><p><img src="https://s1.ax1x.com/2020/11/08/BTek4I.png"></p><p><img src="https://s1.ax1x.com/2020/11/08/BTeECt.png"></p><hr><h3 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h3><h4 id="Random-Search-The-Naive-but-Simplest-way"><a href="#Random-Search-The-Naive-but-Simplest-way" class="headerlink" title="Random Search - The Naive but Simplest way"></a>Random Search - The Naive but Simplest way</h4><blockquote><p>Really Slow !!!</p></blockquote><h4 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h4><blockquote><p>We just get the Gradient of W and go down to the bottom (maybe local best?)</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTeFUA.png"></p><p><strong>Code</strong></p><pre><code class="hljs python"><span class="hljs-comment"># Vanilla Gradient Descent</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    weight_grad = evaluate_gradient(loss_fun, data, weights)    weights += -step_size * weight_grad</code></pre><p><strong>Step size is called elearning rate which is important</strong></p><p><img src="https://s1.ax1x.com/2020/11/08/BTeV8P.png"></p><blockquote><p>Since the N might be super large, we sample some sets called minibatch and use it to estimate the true gradient.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTeZgf.png"></p><hr><p><img src="https://s1.ax1x.com/2020/11/08/BTenKS.png"></p><p><img src="https://s1.ax1x.com/2020/11/08/BTeuDg.png"></p><p><strong>Color Feature</strong><br><img src="https://s1.ax1x.com/2020/11/08/BTeQEj.png"></p><p><strong>Gradient</strong> <em>Extract the edge info</em><br><img src="https://s1.ax1x.com/2020/11/08/BTelUs.png"></p><p><strong>NLP?</strong><br><img src="https://s1.ax1x.com/2020/11/08/BTeG80.png"></p><blockquote><p>clustering different image patches from images</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTe15n.png"></p><ul><li>Differences</li></ul><ol><li>Extract the Feature at first and feed into the linear classificator</li><li>Convolutional Neutral Network would learn the feature automatically during the training process.</li></ol>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Image Classification 01</title>
    <link href="/CsBlog/2020/11/07/CS231n_01_Image_Classification/"/>
    <url>/CsBlog/2020/11/07/CS231n_01_Image_Classification/</url>
    
    <content type="html"><![CDATA[<p><strong>Preface:</strong> This is the note of Stanford course CS231n, paving the way for my lab research.</p><h1 id="Image-Classification"><a href="#Image-Classification" class="headerlink" title="Image Classification"></a>Image Classification</h1><p><em>A core task in Computer Vision</em></p><hr><h3 id="Computer’-Work"><a href="#Computer’-Work" class="headerlink" title="Computer’ Work"></a>Computer’ Work</h3><p>Input an image, and assign one of the label amoung the given labels.</p><ul><li><strong>The Problem:</strong> </li></ul><ol><li>Semantic Gap</li><li>Viewpoint variation</li><li>illumination </li><li>Deformation</li><li>Occlusion</li><li>Intraclass variation</li></ol><hr><h3 id="An-image-classifier"><a href="#An-image-classifier" class="headerlink" title="An image classifier"></a>An image classifier</h3><blockquote><p>Coding might be difficult </p></blockquote><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classify_image</span>(<span class="hljs-params">image</span>):</span>    <span class="hljs-comment"># Do Some Magic</span>    <span class="hljs-keyword">return</span> class_label</code></pre><ul><li>Attmpts</li></ul><p><img src="https://s1.ax1x.com/2020/11/07/BIMSmD.png"></p><hr><h3 id="Data-Driven-Approach"><a href="#Data-Driven-Approach" class="headerlink" title="Data-Driven Approach"></a>Data-Driven Approach</h3><ol><li>Collect a dataset of images and labels</li><li>Use Machine Learning to train a classifier</li><li>Evaluate the classifier on new images</li></ol><ul><li>First classifier: Nearest Neighbor</li></ul><p><em>Just Memorize all data and labels</em></p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span>(<span class="hljs-params">images, labels</span>):</span>    <span class="hljs-comment"># Machine Learning!</span>    <span class="hljs-keyword">return</span> model</code></pre><p><em>Predict the label of the most similar training image</em></p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span>(<span class="hljs-params">model, test_images</span>):</span>    <span class="hljs-comment"># Use model to predict labels</span>    <span class="hljs-keyword">return</span> test_labels</code></pre><p><strong>Example Dataset:</strong> CIFAR10</p><p><img src="https://s1.ax1x.com/2020/11/07/BIM9TH.png"></p><blockquote><p><strong>Issues:</strong> Although pics may seem visually similar, but still give lots of errors.</p></blockquote><hr><ul><li>Compare func used in it<h3 id="K-nearest-Neighbors-Method"><a href="#K-nearest-Neighbors-Method" class="headerlink" title="K nearest Neighbors Method"></a><strong>K nearest Neighbors Method</strong></h3></li></ul><p><strong>L1 distance:</strong> $d_1(I_1,I_2) = \sum\limits_{p} \mid I_1^p - I_2^p \mid$</p><p><img src="https://s1.ax1x.com/2020/11/07/BIKXSx.png"></p><p><em>Minimize the sum given the most similar pics</em></p><h4 id="BackWards"><a href="#BackWards" class="headerlink" title="BackWards"></a><strong>BackWards</strong></h4><p><img src="https://s1.ax1x.com/2020/11/07/BIKjl6.png"></p><h4 id="What-it-looks-like"><a href="#What-it-looks-like" class="headerlink" title="What it looks like"></a><strong>What it looks like</strong></h4><p><img src="https://s1.ax1x.com/2020/11/07/BIMp0e.png"></p><p><strong>Issues</strong></p><ol><li>Isolated Yellow Point</li><li>Noisy of one single point (green into blue)</li></ol><p><strong>Use K Nearest Neighbors to Optimize it</strong><br><img src="https://s1.ax1x.com/2020/11/07/BIMitA.png"></p><hr><p><em>A Better Cmp Func</em><br><strong>L2(Euclidean) distance:</strong> $d_1(I_1,I_2) = \sqrt{\sum\limits_{p}{(I_1^p - I_2^p)}^2}$</p><p><img src="https://s1.ax1x.com/2020/11/07/BIMFfI.png"></p><blockquote><p>The L1 Distance depends on the coordinate system, whenever there is a rotate, it would change the L1 Distance, while that won’t happen in the L2 Distance case (simply because it’s a circle)</p></blockquote><hr><h4 id="Hyperparameters"><a href="#Hyperparameters" class="headerlink" title="Hyperparameters"></a><strong>Hyperparameters</strong></h4><ul><li>What’s the best value of <strong>k</strong></li><li>What’s the best <strong>distance</strong> to use? (L1,L2 or anything else)</li></ul><p><em>These things are preset rather than learn automatically from learning process</em></p><p>This is <strong>Very problem-dependent</strong>, just try!, but How?</p><p><img src="https://s1.ax1x.com/2020/11/07/BIME1P.png"></p><p><strong>Training &amp; Validation process should not mixed with the test data</strong></p><ul><li>Cross Validation</li></ul><p><img src="https://s1.ax1x.com/2020/11/07/BIMApt.png"></p><ul><li>Validation process</li></ul><p><img src="https://s1.ax1x.com/2020/11/07/BIMV6f.png"></p><blockquote><p>using the validation data to choose the best hyperparameters.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/07/BIMu7Q.png"></p><blockquote><p>Cause we sum the offset, though the differences bettween pics and pics are various, they still got the same L2 distance, which is not so good.</p></blockquote><hr><h3 id="Linear-Classification"><a href="#Linear-Classification" class="headerlink" title="Linear Classification"></a><strong>Linear Classification</strong></h3><ul><li><strong>Parametric Model</strong><br><img src="https://s1.ax1x.com/2020/11/07/BIMZX8.png"></li></ul><p>$$f(x,W) = Wx + b$$</p><blockquote><p>We need f(x,W) to be 10x1 and the x is actually 3072x1, so the W we input may be 10x3072, sometimes we add a bias to balance.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/07/BIMn0g.png"></p><p><img src="https://s1.ax1x.com/2020/11/07/BIMMkj.png"></p><blockquote><p>It use a single line to separate the object based on its RGB info</p></blockquote><p>But how can we tell the quality of W ?<br>(View the next lecture)</p><ul><li><strong>Problems</strong><br><img src="https://s1.ax1x.com/2020/11/07/BIMQts.png"></li></ul><blockquote><p>Since it’s linear the Problems is obivious.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS-Lab2 二进制炸弹</title>
    <link href="/CsBlog/2020/11/06/ICS_Lab2/"/>
    <url>/CsBlog/2020/11/06/ICS_Lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="ICS-Lab2-Bomb"><a href="#ICS-Lab2-Bomb" class="headerlink" title="ICS-Lab2-Bomb"></a>ICS-Lab2-Bomb</h1><blockquote><p>这个是CS:APP的第二个lab，主要着重于汇编代码的阅读</p></blockquote><hr><h2 id="完成截图"><a href="#完成截图" class="headerlink" title="完成截图"></a>完成截图</h2><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_244e1f55d2823d58f65eabab9478d7ce.png"></p><hr><h2 id="Phase-1-入门"><a href="#Phase-1-入门" class="headerlink" title="Phase 1 - 入门"></a>Phase 1 - 入门</h2><h3 id="一、分析"><a href="#一、分析" class="headerlink" title="一、分析"></a>一、分析</h3><blockquote><p>练手入门题，用esi寄存器储存答案地址 (一个立即数)</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">402400</span>,%esi</code></pre><blockquote><p>之后调用了一个 string_not_equal 函数比较输入和答案是否一致，一致就通过了。</p></blockquote><pre><code class="hljs angelscript">callq  <span class="hljs-number">401338</span> &lt;<span class="hljs-built_in">string</span>s_not_equal&gt;</code></pre><h3 id="二、gdb调试"><a href="#二、gdb调试" class="headerlink" title="二、gdb调试"></a>二、gdb调试</h3><blockquote><p>看一下内存地址里面存了什么，获得flag</p></blockquote><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_4801c7e177c56f6e7299c273d0120988.png"></p><ul><li><strong>答案</strong>: Border relations with Canada have never been better.</li></ul><hr><h2 id="Phase-2-循环"><a href="#Phase-2-循环" class="headerlink" title="Phase 2 - 循环"></a>Phase 2 - 循环</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>本题是一个do while Loop, 难度不大, 耐心读就行了</p></blockquote><p><strong>关键位置</strong></p><ul><li>信息1 ： 看到 read_six_number 知道输入6个数，再往下看</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">cmpl</span>   $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,(%rsp) # 比较栈顶地址所存变量大小是否为<span class="hljs-number">1</span><span class="hljs-attribute">je</span>     <span class="hljs-number">400</span>f<span class="hljs-number">30</span> &lt;phase_<span class="hljs-number">2</span>+<span class="hljs-number">0</span>x<span class="hljs-number">34</span>&gt; # 如果为<span class="hljs-number">1</span> 跳转至地址 <span class="hljs-number">400</span>f<span class="hljs-number">30</span><span class="hljs-attribute">callq</span>  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt; # 如果不为<span class="hljs-number">1</span>，直接炸了<span class="hljs-attribute">jmp</span>    <span class="hljs-number">400</span>f<span class="hljs-number">30</span> &lt;phase_<span class="hljs-number">2</span>+<span class="hljs-number">0</span>x<span class="hljs-number">34</span>&gt; # 跳转至地址 <span class="hljs-number">400</span>f<span class="hljs-number">30</span></code></pre><ul><li>信息2 : 第一个数为1</li></ul><p>下面进入Loop Body</p><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_27148224f8cf2be48266eaa52f50b2f8.png"></p><ul><li>信息3 :<br>可以看到这个循环把前一个数乘了2，跟后一个数比较, 如果相等就能够继续，不然就炸了。</li></ul><blockquote><p>综上也就是说这是一个首项为1，公比为2的等比数列，共6项。</p></blockquote><p>所以答案就是 1 2 4 8 16 32</p><hr><h2 id="Phase-3-分支"><a href="#Phase-3-分支" class="headerlink" title="Phase 3 - 分支"></a>Phase 3 - 分支</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><blockquote><p>第三题关键点在于用gdb查看一下jumptable</p></blockquote><p> 我们先看一下输入，在输入了两个变量后，esi里放了内存中的一个可疑的东西，我们用gdb看一眼。</p><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">4025</span>cf,%esi</code></pre><pre><code class="hljs shell">(gdb) p(char *) 0x4025cf&quot;%d %d&quot;</code></pre><p> 发现原来是输入两个整型，再往下看</p><pre><code class="hljs apache"><span class="hljs-attribute">cmpl</span>   $<span class="hljs-number">0</span>x<span class="hljs-number">7</span>,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp) # 将 M(rsp + <span class="hljs-number">8</span>) 看作<span class="hljs-number">32</span>位无符号数跟<span class="hljs-number">7</span>比较<span class="hljs-attribute">ja</span>     <span class="hljs-number">400</span>fad &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">6</span>a&gt; # 如果大于就跳转至 <span class="hljs-number">0</span>x<span class="hljs-number">400</span>fad (炸弹炸了)</code></pre><p> 发现如果输入的第一个数大于7就爆炸了，看来switch最多只有7个case</p><pre><code class="hljs angelscript">jmpq   *<span class="hljs-number">0x402470</span>(,%rax,<span class="hljs-number">8</span>) # 跳转至 (eax * <span class="hljs-number">8</span> + <span class="hljs-number">0x402470</span>)处所存的地址 （jumptable）</code></pre><blockquote><p>最关键的是这一句，构造了一个 switch 的 jumptable，我们知道地址是 0x402470，按照 case * 8 + 0x402470 跳转到该地址里面的地址，所以我们用gdb看一下。</p></blockquote><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_ae5e359c30ff5ccb9292a7472c39eb19.png"></p><ul><li><p>我通关选了case 1（它比较特殊，处理它其他内存地址跳转都是按case从小到大顺序的，只有case 1 在最后一个，当然其他也都能过。）</p></li><li><p>case 1 跳转到了 0x400fb9 地址</p></li></ul><pre><code class="hljs angelscript">mov    $<span class="hljs-number">0x137</span>,%eax # eax = <span class="hljs-number">0x137</span> (<span class="hljs-number">311</span>) (不用跳转了，下面就是 <span class="hljs-number">0x400fbe</span>)</code></pre><p>其将eax置为了0x137，要小心是16进制，所以对应十进制311</p><pre><code class="hljs apache"><span class="hljs-attribute">cmp</span>    <span class="hljs-number">0</span>xc(%rsp),%eax # 比较 M(rsp + <span class="hljs-number">12</span>) 和 eax<span class="hljs-attribute">je</span>     <span class="hljs-number">400</span>fc<span class="hljs-number">9</span> &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">86</span>&gt; # 如果相等就跳转至 <span class="hljs-number">0</span>x<span class="hljs-number">400</span>fc<span class="hljs-number">9</span> (过关了！)</code></pre><p>最后是一个比较，如果eax和第二个输入值相同就过了。</p><ul><li>本题答案（不唯一)</li></ul><table><thead><tr><th align="center">case</th><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th></tr></thead><tbody><tr><td align="center">ans</td><td align="center">207</td><td align="center">311</td><td align="center">707</td><td align="center">256</td><td align="center">389</td><td align="center">206</td><td align="center">682</td><td align="center">327</td></tr></tbody></table><hr><h2 id="Phase-4-递归"><a href="#Phase-4-递归" class="headerlink" title="Phase 4 - 递归"></a>Phase 4 - 递归</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ul><li>这题是个递归，不过不用很深，很快就能看出答案。</li></ul><p>先正常读两个数，放在rdx，rcx中，检查输入。</p><pre><code class="hljs angelscript">cmpl   $<span class="hljs-number">0xe</span>,<span class="hljs-number">0x8</span>(%rsp) # 比较 M(rsp + <span class="hljs-number">8</span>) (既 rdx) 与 <span class="hljs-number">0xe</span>jbe    <span class="hljs-number">40103</span>a &lt;phase_4+<span class="hljs-number">0x2e</span>&gt; # 如果 rdx &lt;= <span class="hljs-number">0xe</span> (<span class="hljs-number">14</span>) 跳转至 <span class="hljs-number">0x40103a</span>, 不然就炸了 (作为无符号数)</code></pre><blockquote><p>这两行汇编告诉我们，rdx一定要小于 0xe (14) 且大于等于0, 不然炸了, 大幅度缩小了范围。</p></blockquote><blockquote><p>接下来就进入了函数递归调用，先做点预处理，把edx里面存一个立即数14，然后edi为第一个输入值，esi = 0 进入fun4</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>xe,%edx # edx = <span class="hljs-number">0</span>xe (<span class="hljs-number">14</span>)<span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%esi # esi = <span class="hljs-number">0</span><span class="hljs-attribute">mov</span>    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp),%edi # edi = (第一个输入值)<span class="hljs-attribute">callq</span>  <span class="hljs-number">400</span>fce &lt;func<span class="hljs-number">4</span>&gt; # 调用func<span class="hljs-number">4</span></code></pre><blockquote><p>先不着急看fun4，先看看最后要怎么过关</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">test</span>   %eax,%eax # eax &amp; eax<span class="hljs-attribute">jne</span>    <span class="hljs-number">401058</span> &lt;phase_<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">4</span>c&gt; <span class="hljs-comment"># 如果ZF == 0 就跳转（既eax != 0)，跳转至 0x401058 炸了</span><span class="hljs-attribute">cmpl</span>   $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,<span class="hljs-number">0</span>xc(%rsp) # 比较 M(rsp + <span class="hljs-number">12</span>) 和 <span class="hljs-number">0</span><span class="hljs-attribute">je</span>     <span class="hljs-number">40105</span>d &lt;phase_<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">51</span>&gt; # 如果相等就跳转到 <span class="hljs-number">0</span>x<span class="hljs-number">40105</span>d, 不然就炸了</code></pre><ul><li>test 实际上就是一个与操作，所以我们知道需要 eax == 0 且 M(rsp + 12) == 0，到这我们发现，第二个条件只要我们一开始输入的第二个参数为0，就能够保证，那么下面我们就要看进入fun4之后如何让返回值 eax == 0</li></ul><blockquote><p>再回来看fun4，其分为两部分，一个是递归的主体，一个是判断是否继续递归。一开始先对eax 和 ecx 进行一些操作。</p></blockquote><ul><li>我们发现 eax 和 ecx 的值在第一层递归都被置为14，(esi 为 0)按其操作得到 eax 除2, ecx 逻辑右移 31 位为0, 接着其实就是比较 edi 和 rax, <strong>相当于就是比较第一个参数和常数 7</strong></li></ul><pre><code class="hljs apache"><span class="hljs-attribute">jle</span>    <span class="hljs-number">400</span>ff<span class="hljs-number">2</span> &lt;func<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">24</span>&gt; # 若ecx &lt;= 就跳转至 <span class="hljs-number">0</span>x<span class="hljs-number">400</span>ff<span class="hljs-number">2</span></code></pre><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax # eax = <span class="hljs-number">0</span>;<span class="hljs-attribute">cmp</span>    %edi,%ecx # 比较 ecx 和 edi <span class="hljs-attribute">jge</span>    <span class="hljs-number">401007</span> &lt;func<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">39</span>&gt; <span class="hljs-comment"># 若 edi &gt;= ecx 跳转至 0x401007 返回</span></code></pre><ul><li>接着是一个跳转, 如果满足我们就跳转至 0x400ff2, 我们发现这里已经满足了我们需要的 eax == 0，而想要结束就得使 edi &gt;= ecx (7), 所以我们发现，对于上下两个跳转条件，只要 edi == ecx == 7 就能一直成立，从而直接达成条件，不用进入递归。</li></ul><p>进而我们得到了本题答案：7 0</p><hr><h2 id="Phase-5-指针"><a href="#Phase-5-指针" class="headerlink" title="Phase 5 - 指针"></a>Phase 5 - 指针</h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><ul><li>这题我觉得是最好玩的一题，先直接分析如何通关。</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">40245</span>e,%esi # esi = <span class="hljs-number">0</span>x<span class="hljs-number">40245</span>e <span class="hljs-comment"># 待比较的 string (flyers) 从 0x40245e 移动至 esi</span></code></pre><ul><li>我们在接近返回时看到了一个非常可疑的内存地址，直接给它打出来。</li></ul><pre><code class="hljs lsl">(gdb) p(char*) <span class="hljs-number">0x40245e</span>$<span class="hljs-number">4</span> = <span class="hljs-number">0x40245e</span> <span class="hljs-string">&quot;flyers&quot;</span></code></pre><blockquote><p>发现是一个可疑字符串 flyers，阅读上下文汇编代码可知，最后是比较字符串是否和指定字符串 “flyers” 一致。</p></blockquote><ul><li>我们再往上看看要怎么输入</li></ul><pre><code class="hljs angelscript">callq  <span class="hljs-number">40131</span>b &lt;<span class="hljs-built_in">string</span>_length&gt; # 比较字符长度是否为<span class="hljs-number">6</span>cmp    $<span class="hljs-number">0x6</span>,%eax # 比较 eax 和 <span class="hljs-number">6</span></code></pre><p>发现输入一定要是六个字符 <em>(于是试了试 flyers 果然不对)</em></p><ul><li>往下看，发现了一个 Loop 循环了6次</li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_016df1440f7044a54fb4ced529595b58.png"></p><blockquote><p>经过仔细阅读后，发现这个居然是遍历六个输入字符，将其 ascii 码低4位取出来作为偏移量 (offset),在一个基地址 （0x4024b0）后面取字符出来组成 flyers.</p></blockquote><ul><li>立刻开启 gdb 查看基地址附近的内存</li></ul><p><strong>发现分别对应的偏移量是 9, 15, 14, 5, 6, 7</strong></p><blockquote><p>直接查 ascii 码，发现对应 ionefg 、IONEFG 或者有一些不是字母的字符也行，只要低四位是正确的就可以。 </p></blockquote><p><strong>本题答案:</strong>  ionefg (答案不唯一)</p><hr><h2 id="Phase-6-Node结构体"><a href="#Phase-6-Node结构体" class="headerlink" title="Phase 6 - Node结构体"></a>Phase 6 - Node结构体</h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>这题还是比较麻烦的，代码比较长也比较复杂，要耐心读。</p><ul><li>这题的代码可以大致分为输入检测与处理和一个对结构体的顺序检测.<blockquote><p>最开始上来先输入六个数之后有个双循环，外部保证输入的六个数要大于等于1，且小于等于6，内部保证互异。所以总体看来就是输入的六个数就是123456, 现在问题是输入的顺序。</p></blockquote></li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_7194e52688ff3d696a3b889e2b17d63f.png"></p><p>这段代码遍历了所有输入并用7减去了输入的每个数，所以最后做出答案要记得反一下。</p><ul><li>接下来代码比较复杂，外面大循环循环了六次，内部有两个平行的小循环。作用是构造结构体，并在栈帧中将其存放位置按照输入的数的大小计算得出</li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_9ea5cd30293a18357af1da93c35e0f59.png"></p><blockquote><p>分析代码，我们先发现一种特殊情况就是当前计算的数为1时（输入为6）edx直接就是给定的地址 0x6032d0, 其余的都按照其大小，在第一个小循环中循环相应次数，给 rdx 在原地址上相应偏移16位。</p></blockquote><blockquote><p>接着下来将其存入栈帧中 rsp + 32 到 rsp + 80 的位置</p></blockquote><ul><li>使用 gdb 查看 node</li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_f2ecdd05728cbefbba59b068a29fdfdc.png"></p><p>最后我们看如何通关</p><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_a18a67d1b4dbfa16a7fd8800e3ee304b.png"></p><blockquote><p>发现通关条件是要求定序，前面node大于后面的节点，根据gdb node节点的值和要求我们得到了 3 4 5 6 1 2 的结果，最后不要忘记这是被7减过之后的结果，原来的输入要还原。所以答案就是 4 3 2 1 6 5</p></blockquote><p><strong>本题答案:</strong> 4 3 2 1 6 5</p><hr><h2 id="Secret-Phase-递归"><a href="#Secret-Phase-递归" class="headerlink" title="Secret Phase- 递归"></a>Secret Phase- 递归</h2><h3 id="一、进入方法"><a href="#一、进入方法" class="headerlink" title="一、进入方法"></a>一、进入方法</h3><ul><li>输入上面六种答案之后，发现 secret phase 并没有出现，于是开始着手寻找入口。</li></ul><blockquote><p>根据最后结果出现的字符顺藤摸瓜找到了 phase_defuse 函数，一看发现其中有一个可疑的 <string_not_equal> 函数以及几个可疑的内存地址,统统用 gdb 打印。</string_not_equal></p></blockquote><pre><code class="hljs perl">(gdb) p(char*) <span class="hljs-number">0x402619</span>$2 = <span class="hljs-number">0x402619</span> <span class="hljs-string">&quot;%d %d %s&quot;</span></code></pre><pre><code class="hljs lsl">(gdb) p(char*) <span class="hljs-number">0x402622</span>$<span class="hljs-number">3</span> = <span class="hljs-number">0x402622</span> <span class="hljs-string">&quot;DrEvil&quot;</span></code></pre><blockquote><p>发现之前调用过的__isoc99_sscanf@plt 还有隐藏用法，在输入两个数后再输入一个字符串 “DrEvil” 就能成功开启secret phase.</p></blockquote><ul><li>所以我们在最后一次调用__isoc99_sscanf@plt的 phase 4 输入 7 0 DrEvil, 果然在 phase 6 之后进入了 secret phase。</li></ul><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><ul><li>虽然说是隐藏关，但是复杂度和难度比 phase 6 低了不少，和 phase 4 一样是一个递归，但不同的是这次真的需要递归几次，但也不深。只要确定好路线还是比较容易的。</li></ul><pre><code class="hljs angelscript">callq  <span class="hljs-number">40149</span>e &lt;read_line&gt; # 读一行...callq  <span class="hljs-number">400</span>bd0 &lt;<span class="hljs-symbol">strtol@</span>plt&gt; # 调用 <span class="hljs-symbol">strtol@</span>plt</code></pre><blockquote><p>secret phase上来读了一整行然后调用了一个 strtol，经过阅读strtol的源码，发现它是以10为base将字符串转为一个整型，实际上就是剔除了最后答案中除了数字以外的字符。(所以写上答案数字然后乱输字母也能过 bushi)</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">lea</span>    -<span class="hljs-number">0</span>x<span class="hljs-number">1</span>(%rax),%eax <span class="hljs-comment"># eax = (rax) - 1</span><span class="hljs-attribute">cmp</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">3</span>e<span class="hljs-number">8</span>,%eax <span class="hljs-comment"># eax == 0x3e8 ? (即判断返回值与0x3e9)</span></code></pre><ul><li>这段代码告诉我们输入的数要小于 1000</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">6030</span>f<span class="hljs-number">0</span>,%edi # edi = <span class="hljs-number">0</span>x<span class="hljs-number">6030</span>f<span class="hljs-number">0</span> (<span class="hljs-number">36</span>)<span class="hljs-attribute">callq</span>  <span class="hljs-number">401204</span> &lt;fun<span class="hljs-number">7</span>&gt; # 调用fun<span class="hljs-number">7</span></code></pre><ul><li>将edi置为 0x6030f0 (里面存的是36) 接着开始调用fun7</li></ul><blockquote><p>我们先不着急看fun7, 老样子先看过关要求。</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">cmp</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">2</span>,%eax # 比较一下 eax 返回是否为<span class="hljs-number">2</span></code></pre><p>发现非常简单，只要eax返回值为2就行</p><ul><li>再来看fun7</li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_64ed470376ec6b72dc43690bf9b4ea0e.png"></p><blockquote><p>一看这个递归是逃不过了，但我们要让eax == 2, 路线其实非常明确，第一次先走 way3 将 eax 弄成1，再走 way1 让eax*2， 最后一层我们让eax == 0 最后返回我们得到的 eax 就等于2<br><em>（eax = 0 -&gt; 1 -&gt; 2）</em></p></blockquote><blockquote><p>关键是一个 edx 和 esi 的比较，edx == rdi, 然后每次改变rdi使其中储存地址中所储存的变量逐步接近 esi 完成递归操作。</p></blockquote><p>根据所存地址(注意/d打出的是10进制)，可以很容易找出递归路径</p><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_dfddd1801cd10c701dd2753164434977.png" style="width:65%"></p><ul><li>输入22可以正好满足需求<blockquote><p><strong>22 &lt;= 36 因而 rdi = (rdi + 8) (存8)，22 &gt; 8 因而 rdi = = (rdi + 16) (存22), 22==22 所以 eax 返回 0 ，返回 1， 返回2，最终过关</strong></p></blockquote></li></ul><p><strong>本题答案:</strong> 22 (可以带非数字字符)</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Assembly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS-Lab1 位运算</title>
    <link href="/CsBlog/2020/11/05/ICS_Lab1/"/>
    <url>/CsBlog/2020/11/05/ICS_Lab1/</url>
    
    <content type="html"><![CDATA[<h1 id="ICS-Lab1-位运算"><a href="#ICS-Lab1-位运算" class="headerlink" title="ICS_Lab1-位运算"></a>ICS_Lab1-位运算</h1><blockquote><p>这个是CS:APP的第一个lab，也是我ICS课上的第一个lab，主要注重于使用受限制的位运算来完成操作</p></blockquote><hr><h2 id="Bits-c"><a href="#Bits-c" class="headerlink" title="Bits.c"></a><strong>Bits.c</strong></h2><h3 id="1-bitAnd–与"><a href="#1-bitAnd–与" class="headerlink" title="1. bitAnd–与"></a><strong>1. bitAnd–与</strong></h3><p><strong>题目：</strong></p><pre><code>只用~和|实现&amp;</code></pre><p><strong>样例：</strong></p><pre><code>bitAnd(6, 5) = 4</code></pre><p><strong>可使用操作：</strong> ~ |</p><p><strong>最大操作数限制：</strong> 8</p><p><strong>使用操作数：</strong> 4</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitAnd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;  <span class="hljs-keyword">return</span> ~(~x | ~y); <span class="hljs-comment">//De Morgan&#x27;s laws</span>&#125;</code></pre><blockquote><p>应用摩根律 <del>(x | y) = ~x &amp; ~y, 可得 x &amp; y = ~(</del>x | ~y)</p></blockquote><hr><h3 id="2-getByte–获取字节"><a href="#2-getByte–获取字节" class="headerlink" title="2. getByte–获取字节"></a><strong>2. getByte–获取字节</strong></h3><p><strong>题目：</strong></p><pre><code>从x中提取字节n, n编号从0至3</code></pre><p><strong>样例：</strong></p><pre><code>getByte(0x12345678,1) = 0x56</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 6</p><p><strong>使用操作数：</strong> 3</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getByte</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">return</span> (x &gt;&gt; (n &lt;&lt; <span class="hljs-number">3</span>)) &amp; <span class="hljs-number">0xff</span>;&#125;</code></pre><p><strong>分析：</strong></p><p>*由于 1Byte = 8bits = 2^3bits， 所以 n Bytes = 2^3 * n bits*</p><blockquote><p>因而将n左移3位，即 n * 2^3, 再将x右移 n * 2^3 即可将所求字节放在低8位，将其与上0xff，即可取出字节。</p></blockquote><hr><h3 id="3-logicalShift–逻辑右移"><a href="#3-logicalShift–逻辑右移" class="headerlink" title="3. logicalShift–逻辑右移"></a><strong>3. logicalShift–逻辑右移</strong></h3><p><strong>题目：</strong></p><pre><code>将x逻辑右移n位</code></pre><p><strong>样例：</strong></p><pre><code>logicalShift(0x87654321,4) = 0x08765432</code></pre><p><strong>可使用操作：</strong>  ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 20</p><p><strong>使用操作数：</strong> 10</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">logicalShift</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-comment">//flag equals to: if n == 0 return 0; else return 1;</span>  <span class="hljs-keyword">int</span> flag = !!n;  <span class="hljs-keyword">int</span> mask = ~(flag &lt;&lt; (<span class="hljs-number">32</span> + (~n + <span class="hljs-number">1</span>)));  <span class="hljs-keyword">return</span> (x &gt;&gt; n) &amp; mask;&#125;</code></pre><p><strong>分析：</strong></p><ul><li><p>算数右移</p><blockquote><p>算数右移即在右移后用原符号位数将高位补齐，保持右移后二进制数的符号保持不变。</p></blockquote></li><li><p>逻辑右移</p><blockquote><p>逻辑右移即在右移后用 0 将高位补齐，是“逻辑上”的右移。</p></blockquote></li></ul><blockquote><p>在正常右移运算中使用的是算数右移，因而要解决的问题即对于负数如何将最高位补上0，而非符号位1。<br>我采取掩码的方式，先将x正常右移n位与上其高位的掩码，使其右移产生的高位变为0</p></blockquote><ul><li>掩码构造<blockquote><p>掩码不能草率的构造为 ~(-1 &lt;&lt; (32 - n)), 这种构造方式当n为0时会因-1被左移32位而导致异常，构造出来的mask仍为0</p></blockquote></li></ul><blockquote><p>由于不能使用if，为判断n是否为0，我才用了一个flag = !n + ~0, 其有很好的性质。当n为0时，flag也为0，而当n不为零时，flag统一为-1，这样使用flag代替原先的-1, 从而避免上述情况。</p></blockquote><blockquote><p>这样我们可以使用 mask = <del>(flag &lt;&lt; (32 + (</del>n + 1)))，来构造掩码，当n为0时，flag为0，从而mask = -1，避免上述错误。</p></blockquote><hr><h3 id="4-bitCount–比特计数"><a href="#4-bitCount–比特计数" class="headerlink" title="4. bitCount–比特计数"></a><strong>4. bitCount–比特计数</strong></h3><p><strong>题目：</strong></p><pre><code>返回二进制数中1的个数</code></pre><p><strong>样例：</strong></p><pre><code>bitCount(5) = 2, bitCount(7) = 3</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 40</p><p><strong>使用操作数：</strong> 36</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">int</span> tmp, l1, l2, l4, l8, l16; <span class="hljs-comment">//tmp is used to save ops</span>  tmp = (<span class="hljs-number">0x55</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x55</span>;  l1 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp; <span class="hljs-comment">//0x55555555</span>  tmp = (<span class="hljs-number">0x33</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x33</span>;  l2 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp; <span class="hljs-comment">//0x33333333</span>  tmp = (<span class="hljs-number">0x0f</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x0f</span>;  l4 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp; <span class="hljs-comment">//0x0f0f0f0f</span>  l8 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">16</span>) + <span class="hljs-number">0xff</span>; <span class="hljs-comment">//0x00ff00ff</span>  l16 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xff</span>; <span class="hljs-comment">//0x0000ffff</span>  x = (x &amp; l1) + ((x &gt;&gt; <span class="hljs-number">1</span>) &amp; l1);  x = (x &amp; l2) + ((x &gt;&gt; <span class="hljs-number">2</span>) &amp; l2);  x = (x &amp; l4) + ((x &gt;&gt; <span class="hljs-number">4</span>) &amp; l4);  x = (x &amp; l8) + ((x &gt;&gt; <span class="hljs-number">8</span>) &amp; l8);  x = (x &amp; l16) + ((x &gt;&gt; <span class="hljs-number">16</span>) &amp; l16);  <span class="hljs-keyword">return</span> x;&#125;</code></pre><p><strong>分析：</strong></p><ul><li>分治思想<blockquote><p>本题使用了一个简单的分治思想，对于一个二进制数，要对其中为1的位做计数， 对于1位二进制数来说，1的个数无非就是其本身所表示的1或0。利用这个特性，我们可以先将一个二进制数每一位独立分开为相间隔的两部分, 其每位表示的就是自身的二进制个数，再将两串二进制数对其相加，所得到的每两位分隔的二进制数就是表达这个位置的位为1的个数。</p></blockquote></li></ul><blockquote><p>进一步相加为4位，8位其所代表的含义不变，最后合并至32位二进制数，其所表示的就是原二进制数中所含1的个数。</p></blockquote><pre><code class="hljs cpp"><span class="hljs-comment">//以八位二进制数 10101110 为例//</span>按 <span class="hljs-number">1</span>|<span class="hljs-number">0</span>|<span class="hljs-number">1</span>|<span class="hljs-number">0</span>|<span class="hljs-number">1</span>|<span class="hljs-number">1</span>|<span class="hljs-number">1</span>|<span class="hljs-number">0</span> 分割， 为两串<span class="hljs-number">1</span>|<span class="hljs-number">1</span>|<span class="hljs-number">1</span>|<span class="hljs-number">1</span>和<span class="hljs-number">0</span>|<span class="hljs-number">0</span>|<span class="hljs-number">1</span>|<span class="hljs-number">0</span>，再将其合并，成为 <span class="hljs-number">01</span> | <span class="hljs-number">01</span> | <span class="hljs-number">10</span> | <span class="hljs-number">01</span>, 再将两串 <span class="hljs-number">01</span> | <span class="hljs-number">10</span> 和<span class="hljs-number">01</span> | <span class="hljs-number">01</span>合并得 <span class="hljs-number">0010</span> | <span class="hljs-number">0011</span>（这个很容易看出表示左四位有<span class="hljs-number">2</span>个<span class="hljs-number">1</span>，右四位有<span class="hljs-number">3</span>个<span class="hljs-number">1</span>），再次合并得 <span class="hljs-number">00000101</span>, 得到总共有<span class="hljs-number">5</span>个<span class="hljs-number">1</span>。<span class="hljs-comment">//对于32位二进制数亦按此继续操作即可//</span></code></pre><blockquote><p>于是为完成分割取位的操作，我们需要采用掩码</p></blockquote><ul><li>0x55555555 \ 0x33333333 \ 0x0f0f0f0f \ 0x0000ffff</li></ul><blockquote><p>利用位运算分别构造，使用tmp可以节约ops, 之后按照分治思想进行操作即可。</p></blockquote><hr><h3 id="5-bang–逻辑非"><a href="#5-bang–逻辑非" class="headerlink" title="5. bang–逻辑非"></a><strong>5. bang–逻辑非</strong></h3><p><strong>题目：</strong></p><pre><code>计算 !x 而不使用逻辑非!</code></pre><p><strong>样例：</strong></p><pre><code>bang(3) = 0, bang(0) = 1</code></pre><p><strong>可使用操作：</strong> ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 12</p><p><strong>使用操作数：</strong> 6</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bang</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">return</span> ((x &gt;&gt; <span class="hljs-number">31</span>) | ((~x + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">31</span>)) + <span class="hljs-number">1</span>;&#125;</code></pre><p><strong>分析：</strong></p><ul><li>逻辑非<blockquote><p>对于逻辑非运算，应该都很熟悉，!x 当且仅当x为0时其为1，其余时候都为0，可以用来区分零和非零数。</p></blockquote></li></ul><blockquote><p>该问题的关键就是在于如何区分零和非零数，我们知道零的二补码仍然是零，而对于其余非零数，其符号位会有相应改变，利用这一性质，我们可以对零和非零数做出区分。</p></blockquote><blockquote><p>使用 <code>((x &gt;&gt; 31) | ((~x + 1) &gt;&gt; 31))</code>，将二进制数x的符号位与其补码左移31位相与，如若是非零数，其中符号位至少有一个为1，所以经过31位的算数右移后，其中一项必为-1，一项为0，相与之后得到-1,。而对于0来说，结果始终为0。</p></blockquote><blockquote><p>最后只要将结果+1，就能得到逻辑非的效果。</p></blockquote><hr><h3 id="6-tmin–最小数"><a href="#6-tmin–最小数" class="headerlink" title="6. tmin–最小数"></a><strong>6. tmin–最小数</strong></h3><p><strong>题目：</strong></p><pre><code>返回二补码中最小的数</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 4</p><p><strong>使用操作数：</strong> 1</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tmin</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>此题非常简单，我们知道计算机中负数是用其补码表示的，int所能表示的最小数为0x80000000(-2^31), 即符号位为1，其余皆为0，所以只要将1左移31位即可。</p></blockquote><hr><h3 id="7-fitsBits–填充比特"><a href="#7-fitsBits–填充比特" class="headerlink" title="7. fitsBits–填充比特"></a><strong>7. fitsBits–填充比特</strong></h3><p><strong>题目：</strong></p><pre><code>返回1如果x可以表示为n位二补码，反之返回0 (1 &lt;= n &lt;= 32)</code></pre><p><strong>样例：</strong></p><pre><code>fitsBits(5,3) = 0, fitsBits(-4,3) = 1</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 15</p><p><strong>使用操作数：</strong> 7</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fitsBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">int</span> k = x &gt;&gt; (n + ~<span class="hljs-number">0</span>); <span class="hljs-comment">// if can k = 0 or -1</span>  <span class="hljs-keyword">return</span> !k | !(k + <span class="hljs-number">1</span>);&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>我们知道如若一个数能够被n位二进制数表示，则其第n位即最高位是符号位，那么将其右移n-1位后，根据算术右移，其得到的结果不是0，就是1。否则表示，其还有高于n位的位数， 即不能用n位表示。</p></blockquote><blockquote><p>所以用 k = x &gt;&gt; (n + ~0) 表示将其右移n-1位，再用 !k | !(k + 1) 判断k是否为0或-1</p></blockquote><hr><h3 id="8-divpwr2–除以2的n次方"><a href="#8-divpwr2–除以2的n次方" class="headerlink" title="8. divpwr2–除以2的n次方"></a><strong>8. divpwr2–除以2的n次方</strong></h3><p><strong>题目：</strong></p><pre><code>计算 x/(2^n), (0 &lt;= n &lt;= 30)</code></pre><p><strong>样例：</strong></p><pre><code>divpwr2(15,1) = 7, divpwr2(-33,4) = -2</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 15</p><p><strong>使用操作数：</strong> 7</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divpwr2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> sign = x &gt;&gt; <span class="hljs-number">31</span>;    <span class="hljs-keyword">int</span> bias = (<span class="hljs-number">1</span> &lt;&lt; n) + ~<span class="hljs-number">0</span>;    x = x + (bias &amp; sign);    <span class="hljs-keyword">return</span> x &gt;&gt; n;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>本题的难点在于Round toward zero, 我们知道除以2的n次方即为将x右移n位。对于正数，尾数截断，因而自然向0舍入。而对于负数则不是如此，经试验在gcc上对于负数，其是向偶数舍入的，因而我们要对负数进行操作。</p></blockquote><blockquote><p>同时由于其向偶数舍入，我们不能简单地对负数进行+1操作，例如原本正确的 -7/4 = -1.25 = -1，但是经过+1操作后变为-6/4 = -1.5 Round toward even则变为了2。所以我们不应简单加一，而是加一个偏差值，其为2^n - 1，对于-7/4来说，就是3，加上bias之后得到(-7 + 3)/4即为-1。</p></blockquote><blockquote><p>所以我们构造bias = (1 &lt;&lt; n) + <del>0 (由于不能用减号，-1用+</del>0表示)，然后我们要记得将sign取出，在x进行加操作时先检查一下x是否是负数，再进行操作。最后只要方向的将x右移n位即可。</p></blockquote><hr><h3 id="9-negate–取负"><a href="#9-negate–取负" class="headerlink" title="9. negate–取负"></a><strong>9. negate–取负</strong></h3><p><strong>题目：</strong></p><pre><code>返回-x</code></pre><p><strong>样例：</strong></p><pre><code>negate(1) = -1.</code></pre><p><strong>可使用操作：</strong>  ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 5</p><p><strong>使用操作数：</strong> 2</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">negate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">return</span> ~x + <span class="hljs-number">1</span>;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>很简单，对于有符号二进制数取负就是取其补码，而补码等于其取反加一，返回取反加一即可。</p></blockquote><hr><h3 id="10-isPositive–是正数"><a href="#10-isPositive–是正数" class="headerlink" title="10. isPositive–是正数"></a><strong>10. isPositive–是正数</strong></h3><p><strong>题目：</strong></p><pre><code>返回1如果x大于0，反之返回0</code></pre><p><strong>样例：</strong></p><pre><code>isPositive(-1) = 0.</code></pre><p><strong>可使用操作：</strong>  ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 8</p><p><strong>使用操作数：</strong> 5</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">return</span> !(x &gt;&gt; <span class="hljs-number">31</span>) &amp; !!x;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>这题关键在于把0剔除了，区分正负数就是区分其符号位，将x右移31位，负数得-1，正数为0，用一个逻辑非使正数为1，负数为0，然后再和!!x与一下就能剔除0</p></blockquote><ul><li>!!x 当 x == 0 时返回 0，不为 0 时返回 1</li></ul><hr><h3 id="11-isLessOrEqual–小于等于"><a href="#11-isLessOrEqual–小于等于" class="headerlink" title="11. isLessOrEqual–小于等于"></a><strong>11. isLessOrEqual–小于等于</strong></h3><p><strong>题目：</strong></p><pre><code>如果x小于等于y返回1，反之返回0</code></pre><p><strong>样例：</strong></p><pre><code>isLessOrEqual(4,5) = 1.</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 24</p><p><strong>使用操作数：</strong> 14</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;  <span class="hljs-keyword">int</span> res = y + (~x + <span class="hljs-number">1</span>); <span class="hljs-comment">// y - x</span>  <span class="hljs-keyword">int</span> xSign = x &gt;&gt; <span class="hljs-number">31</span>;  <span class="hljs-keyword">int</span> ySign = y &gt;&gt; <span class="hljs-number">31</span>;  <span class="hljs-keyword">int</span> dif = ~xSign + ySign;  <span class="hljs-keyword">return</span> (~(dif + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">31</span>) &amp; !(res &gt;&gt; <span class="hljs-number">31</span>)) | !dif;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>我在这里采取了作差的方法 res = y + (~x + 1)，即计算一下y-x，判断其是否非负，同时也要考虑溢出问题，即 x 为负数，y为正数，y-x后溢出为负。</p></blockquote><blockquote><p>我将x,y右移31位代表其符号，若负则为-1，若正为0。我同时构造了一个 dif 以表示x,y符号之间的关系。</p></blockquote><blockquote><p><strong>dif = ~xSign + ySign</strong></p></blockquote><ol><li> 当 x &lt; 0 &amp;&amp; y &lt; 0 时，dif = -1 </li><li> 当 x &lt; 0 &amp;&amp; y &gt; 0 时，dif = 0 </li><li> 当 x &gt; 0 &amp;&amp; y &lt; 0 时，dif = -2 </li><li> 当 x &gt; 0 &amp;&amp; y &lt; 0 时，dif = -1</li></ol><blockquote><p>将 x,y 符号之间的关系表达出来，把 dif 加一我们可以观察到当 x,y 同号时，dif为0，所以将其取反和 !(res &gt;&gt; 31) 相与，就可以表示同号不溢出的情况，而当 x &lt; 0, y &gt; 0 的情况发生时，我们注意到 dif 就是 0 ，所以我们直接或上 !dif 即可表达这种情况。</p></blockquote><hr><h3 id="12-ilog2–以2为底的对数"><a href="#12-ilog2–以2为底的对数" class="headerlink" title="12. ilog2–以2为底的对数"></a><strong>12. ilog2–以2为底的对数</strong></h3><p><strong>题目：</strong></p><pre><code>返回x取以2为底的对数并向下取整，输入的 x &gt; 0</code></pre><p><strong>样例：</strong></p><pre><code>ilog2(16) = 4</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 90</p><p><strong>使用操作数：</strong> 48</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ilog2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">int</span> tmp, l1, l2, l4, l8, l16;  x |= x &gt;&gt; <span class="hljs-number">1</span>;  x |= x &gt;&gt; <span class="hljs-number">2</span>;  x |= x &gt;&gt; <span class="hljs-number">4</span>;  x |= x &gt;&gt; <span class="hljs-number">8</span>;  x |= x &gt;&gt; <span class="hljs-number">16</span>;    tmp = (<span class="hljs-number">0x55</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x55</span>;  l1 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;  tmp = (<span class="hljs-number">0x33</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x33</span>;  l2 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;  tmp = (<span class="hljs-number">0x0f</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x0f</span>;  l4 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;  l8 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">16</span>) + <span class="hljs-number">0xff</span>;  l16 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xff</span>;  x = (x &amp; l1) + ((x &gt;&gt; <span class="hljs-number">1</span>) &amp; l1);  x = (x &amp; l2) + ((x &gt;&gt; <span class="hljs-number">2</span>) &amp; l2);  x = (x &amp; l4) + ((x &gt;&gt; <span class="hljs-number">4</span>) &amp; l4);  x = (x &amp; l8) + ((x &gt;&gt; <span class="hljs-number">8</span>) &amp; l8);  x = (x &amp; l16) + ((x &gt;&gt; <span class="hljs-number">16</span>) &amp; l16);  <span class="hljs-keyword">return</span> x + ~<span class="hljs-number">0</span>;</code></pre><p><strong>分析：</strong></p><blockquote><p>我们知道二进制数每位有其位权，所以对 x 取以2为底的对数就是指其为1的最高位的位权。为了获得最高位的位置，其实我们可以将其最高位往下全部变为1，再类似bitsCount数其中1的个数就行了。</p></blockquote><blockquote><p>我把 x 移位相与，保证最高位往下所有数字为1，再使用bitsCount就得到答案。</p></blockquote><blockquote><p>最后不要忘记减一</p></blockquote><hr><h3 id="13-float-neg–浮点数的负数"><a href="#13-float-neg–浮点数的负数" class="headerlink" title="13. float_neg–浮点数的负数"></a><strong>13. float_neg–浮点数的负数</strong></h3><p><strong>题目：</strong></p><pre><code>返回-f，当NaN时，返回参数f</code></pre><p><strong>可使用操作：</strong> 所有的整型操作，包括 ||, &amp;&amp;. 以及 if, while</p><p><strong>最大操作数限制：</strong> 10</p><p><strong>使用操作数：</strong> 5</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_neg</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;  <span class="hljs-keyword">unsigned</span> <span class="hljs-built_in">exp</span> = uf &amp; <span class="hljs-number">0x7f800000</span>;  <span class="hljs-keyword">unsigned</span> frac = uf &amp; <span class="hljs-number">0x007fffff</span>;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> == <span class="hljs-number">0x7f800000</span> &amp;&amp; frac)    <span class="hljs-keyword">return</span> uf;  <span class="hljs-keyword">return</span> uf ^= <span class="hljs-number">0x80000000</span>;&#125;</code></pre><p><strong>分析：</strong></p><ul><li>IEEE-float<blockquote><p>我们知道IEEE单精度浮点数，最高位为符号位，其后8位为阶码exp，后23位为尾数frac。其牺牲了精度来扩大了表达范围。</p></blockquote></li></ul><blockquote><p>而当 exp 全 1 时，如若frac非全零，则表示NaN。若全零，则表示无穷大/小。</p></blockquote><blockquote><p>这里我们只要将原数和符号位0x80000000异或一下，即可取负。不要忘记排除NaN的情况。</p></blockquote><hr><h3 id="14-float-i2f–int转float"><a href="#14-float-i2f–int转float" class="headerlink" title="14. float_i2f–int转float"></a><strong>14. float_i2f–int转float</strong></h3><p><strong>题目：</strong></p><pre><code>把int类型的数转换为float表示(比特形式)</code></pre><p><strong>可使用操作：</strong> 所有的整型操作，包括 ||, &amp;&amp;. 以及 if, while</p><p><strong>最大操作数限制：</strong> 30</p><p><strong>使用操作数：</strong> 30</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_i2f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">unsigned</span> frac, mask1, mask2, mask3, mask4, d;  <span class="hljs-keyword">int</span> high = <span class="hljs-number">0x80000000</span>;  <span class="hljs-keyword">unsigned</span> sign = x &amp; <span class="hljs-number">0x80000000</span>;  <span class="hljs-keyword">unsigned</span> <span class="hljs-built_in">exp</span> = <span class="hljs-number">127</span>;  <span class="hljs-keyword">int</span> count = <span class="hljs-number">32</span>, i;  <span class="hljs-keyword">if</span>(sign)    x = ~x + <span class="hljs-number">1</span>;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!x)    <span class="hljs-keyword">return</span> x;    frac = x;  <span class="hljs-keyword">for</span>(;high; high &gt;&gt;= <span class="hljs-number">1</span>)  &#123;    --count;    <span class="hljs-keyword">if</span>(high &amp; x)      <span class="hljs-keyword">break</span>;  &#125;  i = count - <span class="hljs-number">23</span>;  mask1 = ~(<span class="hljs-number">1</span> &lt;&lt; count); <span class="hljs-comment">// the highest 1</span>  mask2 = <span class="hljs-number">1</span> &lt;&lt; i; <span class="hljs-comment">//the lowest of remain frac;</span>  mask3 = mask2 &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// the highest of deserted bits </span>  mask4 = mask2 - <span class="hljs-number">1</span>; <span class="hljs-comment">// the deserted bits</span>  <span class="hljs-built_in">exp</span> += count;  frac &amp;= mask1;    <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)  &#123;    d = frac &amp; mask4; <span class="hljs-comment">// deserted bits</span>    <span class="hljs-keyword">if</span>(d &gt; mask3 | (d == mask3 &amp;&amp; frac &amp; mask2))    &#123;      frac += mask2;      <span class="hljs-keyword">if</span>(frac &gt; <span class="hljs-number">0x3fffffff</span>)      &#123;        frac = <span class="hljs-number">0</span>;        <span class="hljs-built_in">exp</span>++;      &#125;    &#125;    frac &gt;&gt;= i;  &#125;  <span class="hljs-keyword">else</span>    frac &lt;&lt;= -i;  <span class="hljs-keyword">return</span> sign | <span class="hljs-built_in">exp</span> &lt;&lt; <span class="hljs-number">23</span> | frac;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>我认为这题比较难，我做了很久很久….它难在浮点数向偶数舍入以及其操作数的限制。</p></blockquote><blockquote><p>我们知道由于浮点数表示范围比整型大，我们可以将整型转换为浮点数，但是相应的会有一些精度的丢失，因为尾数frac只有23位，而int有31位可用。</p></blockquote><blockquote><p>所以其关键在于int的位数，一开始先把该取出来的都用掩码取出来，把负数和零处理一下。之后我利用了一个循环先找出int的最高位在哪，利用count计数。</p></blockquote><blockquote><p>后面我采取了四个掩码，分别代表最高位的1，留下的尾数中的最低位，要舍去的位数的最高位，以及舍弃的位数的掩码。利用这四个掩码我们可以达到存frac时，将其向<strong>偶数舍入</strong>。</p></blockquote><blockquote><p>具体操作是，先取出丢弃的尾数，将其存放在d中，看其有没有超过0.5 (即 d 是否大于 mask3) 如果大于，直接frac++就行。而如果等于的话，还要看frac是否是奇数 (即frac &amp; mask2是否为1) 如果是，则要向偶数舍入,frac++。</p></blockquote><blockquote><p>加完frac之后还要注意<strong>溢出问题</strong>，如果溢出了，要将frac置0，然后把阶码 exp++，再按照之前输出来的尾数移动，将尾数对齐即可 （位数最高默认为1不存，因而把最高位隐去）。</p></blockquote><blockquote><p>最后把符号位，阶码位和尾数位拼接，得到最后的结果。</p></blockquote><hr><h3 id="15-float-twice–float-2"><a href="#15-float-twice–float-2" class="headerlink" title="15. float_twice–float * 2"></a>15. float_twice–float * 2</h3><p><strong>题目：</strong></p><pre><code>返回float * 2, 当参数是NaN时，返回参数</code></pre><p><strong>可使用操作：</strong> 所有的整型操作，包括 ||, &amp;&amp;. 以及 if, while</p><p><strong>最大操作数限制：</strong> 30</p><p><strong>使用操作数：</strong> 20</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_twice</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;  <span class="hljs-keyword">unsigned</span> sign = uf &amp; <span class="hljs-number">0x80000000</span>;  <span class="hljs-keyword">unsigned</span> <span class="hljs-built_in">exp</span> = uf &amp; <span class="hljs-number">0x7f800000</span>;  <span class="hljs-keyword">unsigned</span> frac = uf &amp; <span class="hljs-number">0x007fffff</span>;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> == <span class="hljs-number">0x7f800000</span>) <span class="hljs-comment">//NaN &amp; inf</span>    <span class="hljs-keyword">return</span> uf;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">exp</span> &amp;&amp; !frac) <span class="hljs-comment">// 0</span>    <span class="hljs-keyword">return</span> uf;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">exp</span> &amp;&amp; frac &lt;= <span class="hljs-number">0x3fffff</span>)  <span class="hljs-comment">// low</span>    frac *= <span class="hljs-number">2</span>;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">exp</span> &amp;&amp; frac &gt; <span class="hljs-number">0x3fffff</span>) <span class="hljs-comment">// high</span>  &#123;    <span class="hljs-built_in">exp</span> += <span class="hljs-number">0x00800000</span>;    frac = (frac * <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x7fffff</span>;  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-comment">// normal</span>    <span class="hljs-built_in">exp</span> += <span class="hljs-number">0x00800000</span>;  <span class="hljs-keyword">return</span> sign + <span class="hljs-built_in">exp</span> + frac;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>主要要分析的地方，在于当阶码exp为0时，是否在乘2之后进位。所以要考虑尾数是否大于0x3fffff，如果小于等于之，则直接尾数乘2就行，不会溢出，否则则exp要进位，同时尾数乘2之后要与上0x7fffff保证不溢出。</p></blockquote><blockquote><p>其他正常情况直接exp++就行，注意一下特殊情况;</p></blockquote><p><em>本题中测试集中有一个inf，也要直接返回参数uf</em></p><hr><h2 id="Bits-honor-c"><a href="#Bits-honor-c" class="headerlink" title="Bits_honor.c"></a><strong>Bits_honor.c</strong></h2><h3 id="1-bitReverse–比特翻转"><a href="#1-bitReverse–比特翻转" class="headerlink" title="1. bitReverse–比特翻转"></a><strong>1. bitReverse–比特翻转</strong></h3><p><strong>题目：</strong></p><pre><code>把32比特int的比特位翻转</code></pre><p><strong>样例：</strong></p><pre><code>bitReverse(0x80000004) = 0x20000001bitReverse(0x7FFFFFFF) = 0xFFFFFFFE</code></pre><p><strong>最大操作数限制：</strong> 40</p><p><strong>使用操作数：</strong> 40</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitReverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> tmp,l1, l2, l4, l8, l16;   tmp = (<span class="hljs-number">0x55</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x55</span>;   l1 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;   tmp = (<span class="hljs-number">0x33</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x33</span>;   l2 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;   tmp = (<span class="hljs-number">0x0f</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x0f</span>;   l4 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;   l8 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">16</span>) + <span class="hljs-number">0xff</span>;   l16 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xff</span>;   x = ((x &gt;&gt; <span class="hljs-number">16</span>) &amp; l16) | (x &lt;&lt; <span class="hljs-number">16</span>);   x = ((x &gt;&gt; <span class="hljs-number">8</span>) &amp; l8) | ((x &amp; l8) &lt;&lt; <span class="hljs-number">8</span>);   x = ((x &gt;&gt; <span class="hljs-number">4</span>) &amp; l4) | ((x &amp; l4) &lt;&lt; <span class="hljs-number">4</span>);   x = ((x &gt;&gt; <span class="hljs-number">2</span>) &amp; l2) | ((x &amp; l2) &lt;&lt; <span class="hljs-number">2</span>);   x = ((x &gt;&gt; <span class="hljs-number">1</span>) &amp; l1) | ((x &amp; l1) &lt;&lt; <span class="hljs-number">1</span>);   <span class="hljs-keyword">return</span> x;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>这题和 bitsCount 有异曲同工之妙，也是一个分治法，将32位二进制数一分为二，交换，再将内部各自再一分为二，交换，直至最底层2位二进制数互换位置，最后完成了将所有位数翻转的工作。</p></blockquote><blockquote><p>但值得注意的是，给出的是有符号的int，所以在右移交换位置时，会发生因为负数算术右移导致高位全是1的情况，致使在与的过程中高位全部变为1。这边只要将其移动后在和掩码相与就能解决这一问题。而对于低位，先与掩码相与再移动，可以省去取反得到高位掩码的操作数。再用tmp省一下操作数。</p></blockquote><blockquote><p>最后操作数正好卡在40</p></blockquote><hr><h3 id="2-mod3–取模3"><a href="#2-mod3–取模3" class="headerlink" title="2. mod3–取模3"></a><strong>2. mod3–取模3</strong></h3><p><strong>题目：</strong></p><pre><code>计算 x 取模 3，而不用%</code></pre><p><strong>样例：</strong></p><pre><code>mod3(100) = 1mod3(-100) = -1</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 90</p><p><strong>使用操作数：</strong> 24</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mod3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> mask = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xff</span>;   x = (x &gt;&gt; <span class="hljs-number">16</span>) + (x &amp; mask); <span class="hljs-comment">// sum base 4^8 digits (a &lt;= 0x1FFFE)</span>   x = (x &gt;&gt; <span class="hljs-number">8</span>) + (x &amp; <span class="hljs-number">0xff</span>); <span class="hljs-comment">// sum base 4^4 digits (a &lt;= 0x2FD)</span>   x = (x &gt;&gt; <span class="hljs-number">4</span>) + (x &amp; <span class="hljs-number">0xf</span>); <span class="hljs-comment">// sum base 4^2 digits (a &lt;= 0x3C)</span>   x = (x &gt;&gt; <span class="hljs-number">2</span>) + (x &amp; <span class="hljs-number">0x3</span>); <span class="hljs-comment">// sum base 4^1 digits (a &lt;= 0x1D)</span>   x = (x &gt;&gt; <span class="hljs-number">2</span>) + (x &amp; <span class="hljs-number">0x3</span>); <span class="hljs-comment">// sum base 4^1 digits (a &lt;= 0x9)</span>   x = (x &gt;&gt; <span class="hljs-number">2</span>) + (x &amp; <span class="hljs-number">0x3</span>); <span class="hljs-comment">// sum base 4^1 digits (a &lt;= 0x4)</span>   x = (((x + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">2</span>) + x) &amp; <span class="hljs-number">0x3</span>;   <span class="hljs-keyword">return</span> x;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>这题难度算是比较大的，我参考了一些资料最后才写出这个代码。其实这题也与bitsCount有着一定的联系。</p></blockquote><blockquote><p>对于解这题有一个根本的公式即 </p></blockquote><pre><code>a % m = ((b % m)(a/b) + (a % b)) % m其中b是进制数</code></pre><blockquote><p>我们知道，如果想要知道一个十进制的数能否被三整除，只要看它所有数位之和是否能被三整除就行了。其实这就是上述公式的特殊情况，由于10 mod 3 == 1 所以其就退化为</p></blockquote><pre><code>a mod m = (a/b + a % b) % m递归下来就是所有数位之和</code></pre><blockquote><p>而对于二进制的情况，我们可以将进制位b选为4，这样正好是两位二进制数，同时4 % 3 == 1，这样一来，对于二进制数中我们只需要统计所有两两数位(四进制)的和能否被三整除就行了。</p></blockquote><blockquote><p>而考虑到我们每做一次 a/b + a % b 统计数位和都减小了数的规模，这样只要做有限次就能够将数控制在&lt;=3的范围内。</p></blockquote><blockquote><p>对于a % 4，这是一个经典的trivial情况，我们只需要做 a &amp; 3，就能够轻松得到a % 4的值。而对于a/4，只需要做a &gt;&gt; 2即可。</p></blockquote><blockquote><p>对于二进制数我们不仅可以按两位两位的四进制数位和来数，也可以直接数其倍数(4^i)，从最大4^8开始统计，一步步减小x的值，最后将x做到&lt;= 3的范围</p></blockquote><blockquote><p>最后要判断x是否为3，如果为3的话则要置为0，我利用3数位全为1的特点，将其+1进位后，右移2位。如果为3，则得到的是1。将其再加上x，如若x是1或2，则还是不变，但如果是3，它又会进位到4，那么我们只要再与上0x3，则会得到0，即为想要的结果。</p></blockquote><hr><h3 id="3-float-f2i–float转int"><a href="#3-float-f2i–float转int" class="headerlink" title="3. float_f2i–float转int"></a><strong>3. float_f2i–float转int</strong></h3><p><strong>题目：</strong></p><pre><code>输入一个按二进制位储存的float（以unsigned表示），将其转为int输出。(NaN,inf，溢出直接返回参数)</code></pre><p><strong>可使用操作：</strong> 所有的整型操作，包括 ||, &amp;&amp;. 以及 if, while</p><p><strong>最大操作数限制：</strong> 30</p><p><strong>使用操作数：</strong> 17</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">float_f2i</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> sign, <span class="hljs-built_in">exp</span>, frac, res;   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> tmp;   <span class="hljs-keyword">if</span>(!uf)      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   sign = uf &amp; <span class="hljs-number">0x80000000</span>;   <span class="hljs-built_in">exp</span> = uf &amp; <span class="hljs-number">0x7f800000</span>;   frac = (uf &amp; <span class="hljs-number">0x007fffff</span>) | <span class="hljs-number">0x00800000</span>;   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> == <span class="hljs-number">0x7f800000</span>) <span class="hljs-comment">//NaN and inf</span>      <span class="hljs-keyword">return</span> <span class="hljs-number">0x80000000</span>u;   <span class="hljs-built_in">exp</span> &gt;&gt;= <span class="hljs-number">23</span>;   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> &lt; <span class="hljs-number">127</span>)      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">158</span>)      <span class="hljs-keyword">return</span> <span class="hljs-number">0x80000000</span>u;   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">150</span>)      tmp = frac &lt;&lt; (<span class="hljs-built_in">exp</span> - <span class="hljs-number">150</span>);   <span class="hljs-keyword">else</span>      tmp = frac &gt;&gt; (<span class="hljs-number">150</span> - <span class="hljs-built_in">exp</span>);         <span class="hljs-keyword">if</span>(sign)      res = ~tmp + <span class="hljs-number">1</span>;   <span class="hljs-keyword">else</span>      res = tmp;      <span class="hljs-keyword">return</span> res | sign;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>这题特殊情况比较多，把NaN和inf处理一下，然后注意一下溢出情况，即取出来的exp - bias &gt; 31，肯定超过2^31整型储存的最大值，直接返回0x80000000u，然后对于exp小于127的，其指数是负数，直接返回int值为0。对于在exp - bias 在 0 到 31 之间的，由于frac只有23位，所以要将注意一下讨论23的情况。</p></blockquote><blockquote><p>最后把取出来的符号位对一下，如果负数取反加一，正数直接等，最后再或上符号位，返回答案。</p></blockquote><hr><h2 id="结果截图"><a href="#结果截图" class="headerlink" title="结果截图"></a><strong>结果截图</strong></h2><h3 id="bits-c"><a href="#bits-c" class="headerlink" title="bits.c"></a><strong>bits.c</strong></h3><p><img src="/CsBlog/CsBlog/2020/11/05/ICS_Lab1/ICS_Lab1/bits_btest.JPG" alt="bits_btest"></p><p><img src="/CsBlog/CsBlog/2020/11/05/ICS_Lab1/ICS_Lab1/bits_dlc.png" alt="bits_dlc"></p><h3 id="bits-honor-c"><a href="#bits-honor-c" class="headerlink" title="bits_honor.c"></a><strong>bits_honor.c</strong></h3><p><img src="/CsBlog/CsBlog/2020/11/05/ICS_Lab1/ICS_Lab1/bits_honor_btest.JPG" alt="bits_honor_btest"></p><p><img src="/CsBlog/CsBlog/2020/11/05/ICS_Lab1/ICS_Lab1/bits_honor_dlc.png" alt="bits_honor_dlc"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><p><a href="https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E5%8F%B3%E7%A7%BB/3711081?fr=aladdin">https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E5%8F%B3%E7%A7%BB/3711081?fr=aladdin</a><br><a href="https://blog.csdn.net/jiahonghao2002/article/details/108223366">https://blog.csdn.net/jiahonghao2002/article/details/108223366</a><br><a href="https://leetcode-cn.com/problems/reverse-bits/solution/dian-dao-er-jin-zhi-wei-by-leetcode/">https://leetcode-cn.com/problems/reverse-bits/solution/dian-dao-er-jin-zhi-wei-by-leetcode/</a><br><a href="http://homepage.cs.uiowa.edu/~jones/bcd/mod.shtml#exmod3">http://homepage.cs.uiowa.edu/~jones/bcd/mod.shtml#exmod3</a><br><a href="https://www.zhihu.com/question/38206659/answer/763034261">https://www.zhihu.com/question/38206659/answer/763034261</a><br><a href="https://blog.csdn.net/xindaxinda123/article/details/95617758">https://blog.csdn.net/xindaxinda123/article/details/95617758</a><br><a href="https://www.runoob.com/w3cnote/32-float-storage.html">https://www.runoob.com/w3cnote/32-float-storage.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bits</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/CsBlog/2020/11/05/hello-world/"/>
    <url>/CsBlog/2020/11/05/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="第一篇博客用以测试"><a href="#第一篇博客用以测试" class="headerlink" title="第一篇博客用以测试"></a>第一篇博客用以测试</h2><h3 id="一、-下面是一段C-代码"><a href="#一、-下面是一段C-代码" class="headerlink" title="一、 下面是一段C++代码"></a>一、 下面是一段C++代码</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Hello World!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre><h3 id="二、-下面是一段表格"><a href="#二、-下面是一段表格" class="headerlink" title="二、 下面是一段表格"></a>二、 下面是一段表格</h3><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">x</td></tr></tbody></table><h3 id="三、-下面是一段-Latex"><a href="#三、-下面是一段-Latex" class="headerlink" title="三、 下面是一段 Latex"></a>三、 下面是一段 Latex</h3><p>$$E= mc^2$$</p><h3 id="四、下面是一张图片"><a href="#四、下面是一张图片" class="headerlink" title="四、下面是一张图片"></a>四、下面是一张图片</h3><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRP-ciAYVH8UlH3ZaZC3NkN3ow9CrG36O5crg&usqp=CAU"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
