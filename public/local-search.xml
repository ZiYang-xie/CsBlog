<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ELF头简介</title>
    <link href="/2021/03/22/Readelf/"/>
    <url>/2021/03/22/Readelf/</url>
    
    <content type="html"><![CDATA[<p><em>项目地址： <a href="https://github.com/ZiYang-xie/Readelf">https://github.com/ZiYang-xie/Readelf</a></em> （My Readelf Implement）</p><hr><p>​    在linux中我们常用readelf指令来读取ELF (Executable and Linkable Format) 文件中的信息，本文首先介绍ELF头的基本信息，在下篇文章中将会介绍一下个人实现的一个简单的读取ELF头的程序，等效于readelf -h <file></file></p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Elf-layout--en.svg/260px-Elf-layout--en.svg.png" alt="ELF文件结构"></p><h3 id="ELF头"><a href="#ELF头" class="headerlink" title="ELF头"></a>ELF头</h3><p>elf头是位于elf文件的头部，里面存储着一些机器和该ELF文件的基本信息。</p><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>   e_ident[EI_NIDENT];        Elf64_Half      e_type;        Elf64_Half      e_machine;        Elf64_Word      e_version;        Elf64_Addr      e_entry;        Elf64_Off       e_phoff;        Elf64_Off       e_shoff;        Elf64_Word      e_flags;        Elf64_Half      e_ehsize;        Elf64_Half      e_phentsize;        Elf64_Half      e_phnum;        Elf64_Half      e_shentsize;        Elf64_Half      e_shnum;        Elf64_Half      e_shstrndx;&#125; Elf64_Ehdr;</code></pre><p>我们分别介绍其含义</p><hr><h4 id="1、e-ident"><a href="#1、e-ident" class="headerlink" title="1、e_ident"></a>1、e_ident</h4><ul><li><strong>长度：16字节</strong></li><li><strong>简介：包含着文件和操作系统信息</strong></li><li><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosklimwgzj30m00fmq55.jpg" style="zoom:50%;"></li></ul><h5 id="Magic-Num-e-ident-0-3"><a href="#Magic-Num-e-ident-0-3" class="headerlink" title="Magic Num - e_ident[0:3]"></a>Magic Num - e_ident[0:3]</h5><p>​    前四个字节包含着一个 magic number，表示该文件是一个 ELF 文件</p><h5 id="EI-Class-e-ident-4"><a href="#EI-Class-e-ident-4" class="headerlink" title="EI_Class - e_ident[4]"></a>EI_Class - e_ident[4]</h5><p>​    指示文件类型，是ELF32还是ELF64位</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskl3oqhyj30dq05qq3h.jpg" style="zoom:50%;"></p><h5 id="EI-DATA-e-ident-5"><a href="#EI-DATA-e-ident-5" class="headerlink" title="EI_DATA - e_ident[5]"></a>EI_DATA - e_ident[5]</h5><p>​    指示文件的编码方式，是大端法还是小端法</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskkp5pdjj30fy05ggm5.jpg" style="zoom:50%;"></p><p>​    <strong>ELFDATA2LSB - 小端法</strong></p><p>​    <strong>ELFDATA2MSB - 大端法</strong></p><h5 id="EI-Version-e-ident-6"><a href="#EI-Version-e-ident-6" class="headerlink" title="EI_Version - e_ident[6]"></a>EI_Version - e_ident[6]</h5><p>​    标识ELF Version, 该值等于EV_CURRENT，目前为1</p><h5 id="EI-OSABI-e-ident-7"><a href="#EI-OSABI-e-ident-7" class="headerlink" title="EI_OSABI - e_ident[7]"></a>EI_OSABI - e_ident[7]</h5><p>​    表示着该文件运行的操作系统</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskk8xx2wj30oi0jmadb.jpg" alt="操作系统类型对应" style="zoom:50%;"></p><h5 id="EI-ABIVERSION-e-ident-8"><a href="#EI-ABIVERSION-e-ident-8" class="headerlink" title="EI_ABIVERSION - e_ident[8]"></a>EI_ABIVERSION - e_ident[8]</h5><p>​    标志着 ABI （应用二进制接口）的版本，ABI相当于硬件层级的API（见下图）</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosknnji29j31400u0qd8.jpg" alt="ABI解释" style="zoom:40%;"></p><h5 id="EI-PAD-e-ident-8-15"><a href="#EI-PAD-e-ident-8-15" class="headerlink" title="EI_PAD - e_ident[8:15]"></a>EI_PAD - e_ident[8:15]</h5><p>​    填充位，用零填充用以对齐，可以预留给未来使用</p><h4 id="2、e-type"><a href="#2、e-type" class="headerlink" title="2、e_type"></a>2、e_type</h4><ul><li><p><strong>长度：2字节</strong></p></li><li><p><strong>简介：</strong>指示文件类型</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosm36oov3j30he0da40a.jpg" style="zoom:50%;"></p></li></ul><p>​    </p><h4 id="3、e-machine"><a href="#3、e-machine" class="headerlink" title="3、e_machine"></a>3、e_machine</h4><ul><li><p><strong>长度：2字节</strong></p></li><li><p><strong>简介：</strong>指示机器类型</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosm42l3lxj30u00x2wkc.jpg" alt="部分机器类型" style="zoom:50%;"></p></li></ul><h4 id="4、e-version"><a href="#4、e-version" class="headerlink" title="4、e_version"></a>4、e_version</h4><p>​    <strong>长度：4字节</strong></p><p>​    <strong>简介：指示文件版本</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosm8c0knij30dk04gglx.jpg" style="zoom:50%;"></p><h4 id="5、e-entry"><a href="#5、e-entry" class="headerlink" title="5、e_entry"></a>5、e_entry</h4><p>​    <strong>长度：4字节（32位）/8字节（64位）</strong></p><p>​    <strong>简介：进程开始的虚拟地址</strong></p><h4 id="6、e-phoff"><a href="#6、e-phoff" class="headerlink" title="6、e_phoff"></a>6、e_phoff</h4><p>​    <strong>长度：4字节（32位）/8字节（64位）</strong></p><p>​    <strong>简介：指向程序头部表的开始</strong>    </p><h4 id="7、e-shoff"><a href="#7、e-shoff" class="headerlink" title="7、e_shoff"></a>7、e_shoff</h4><p>​    <strong>长度：4字节（32位）/8字节（64位）</strong></p><p>​    <strong>简介：指向节头部表的开始</strong>    </p><h4 id="8、e-flags"><a href="#8、e-flags" class="headerlink" title="8、e_flags"></a>8、e_flags</h4><p>​    <strong>长度：4字节</strong></p><p>​    <strong>简介：意义取决于目标架构</strong>    </p><h4 id="9、e-ehsize"><a href="#9、e-ehsize" class="headerlink" title="9、e_ehsize"></a>9、e_ehsize</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：该文件头部的大小</strong></p><h4 id="10、e-phentsize"><a href="#10、e-phentsize" class="headerlink" title="10、e_phentsize"></a>10、e_phentsize</h4><p>​    <strong>长度：2字节</strong>    </p><p><strong>简介：程序头部的大小</strong>    </p><h4 id="11、e-phnum"><a href="#11、e-phnum" class="headerlink" title="11、e_phnum"></a>11、e_phnum</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：程序头部的条目数</strong></p><h4 id="12、e-shentsize"><a href="#12、e-shentsize" class="headerlink" title="12、e_shentsize"></a>12、e_shentsize</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：节头部表的大小</strong></p><h4 id="13、e-shnum"><a href="#13、e-shnum" class="headerlink" title="13、e_shnum"></a>13、e_shnum</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：节头部表的条目数</strong></p><h4 id="14、e-shstrndx"><a href="#14、e-shstrndx" class="headerlink" title="14、e_shstrndx"></a>14、e_shstrndx</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：节头部表的条目和其位置 (idx) 的对应关系</strong></p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">https://en.wikipedia.org/wiki/Executable_and_Linkable_Format</a></p><p>[2] <a href="https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html">https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Link</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CaDDN论文阅读</title>
    <link href="/2021/03/09/Research/CaDDN-Paper/"/>
    <url>/2021/03/09/Research/CaDDN-Paper/</url>
    
    <content type="html"><![CDATA[<h1 id="Categorical-Depth-Distribution-Network-for-Monocular-3D-Object-Detection"><a href="#Categorical-Depth-Distribution-Network-for-Monocular-3D-Object-Detection" class="headerlink" title="Categorical Depth Distribution Network for Monocular 3D Object Detection"></a><strong>Categorical Depth Distribution Network for Monocular 3D Object Detection</strong></h1><p><strong>关键词： 单目3d检测、绝对深度分配网络</strong></p><p><strong>论文链接：</strong><a href="https://arxiv.org/pdf/2103.01100.pdf">https://arxiv.org/pdf/2103.01100.pdf</a></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1godx97xntnj30bl08p0wn.jpg" alt></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    单目3D检测的难点一直在于对深度的预测，实例从3D空间被映射到2D平面的图像上丢失了深度信息，对深度的处理一直是单目3D目标检测研究的重点方向，目前主流的方法主要分为三类。</p><p><strong>1、直接检测  (Direct Methods)</strong></p><p>​    直接检测方法没有显式的对深度进行学习，比较有代表性的是关键点检测方法，通过关键点结合几何特征来帮助3D-Bbox的检测，好处是简单直接且高效，但这类方法由于没有显式的学习深度信息，往往导致深度预测的结果不尽理想。</p><p><strong>2、基于深度  (Depth-Based Methods)</strong></p><p>​    基于深度的方法通常先会通过一个单目深度预测分支来得到一张深度图作为网络的输入从而辅助对深度的检测，由于有了深度信息其可被转换成点云来处理（可以用上3d检测的方法)。但由于其深度和目标检测分离训练的结构，导致其可能会丢失一些隐含的信息。</p><p><strong>3、基于网格  (Grid-Based Methods)</strong></p><p>​    基于网格的方法避免了对深度的直接预测，而是通过预测一个 BEV grid 的表达来作为3D检测网络的输入，OFT[1]提出了一种体素网格，通过把体素投影到图像平面上进而采样图像特征将其转换成BEV的形式。但这也会导致大量体素和特征的重叠从而降低检测的准确性。</p><p>​    <strong>CaDDN</strong> 网络对上面三种情况的优点进行结合，整体网络结构是同时训练了深度预测和3D检测（jointly）以期待其能够解决方法2中的问题，同时利用也将图像平面转换成了BEV的形式来提高检测的准确性。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1godxz73f1jj30nm0dntcy.jpg" alt="网络结构"></p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><h3 id="Frustum-Feature-Network"><a href="#Frustum-Feature-Network" class="headerlink" title="Frustum Feature Network"></a>Frustum Feature Network</h3><ul><li><strong>Depth Distribution Network</strong></li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1godzoe00t7j30b908dabe.jpg" alt></p><p>对于特征提取网络，其输出形似一个截角锥形，因而作者称其为Frustum feature Network，其输入是原始图像 $I \in R^{W_1\times H_1\times 3}$ 输出 $G \in R^{W_F\times H_F\times D \times C}$ 其中 W和H是特征的宽高，D 是深度桶，用以深度预测，C 是特征的维度。图像特征被用以在每个像素上预测绝对的深度分布 $D \in R^{W_F\times H_F\times D}$ 网络对每个像素预测其落入某一深度桶（深度离散化）的概率，总共D个。</p><p>（这一网络其是从 DeepLabV3[2] 上魔改过来的。）</p><ul><li>Image Channel Reduce</li></ul><p>同时在分配深度桶的同时，网络另一分支用1x1卷积 + BN + ReLU 把特征的维数从256降到了64。</p><p>​    经过这两个分支后，将预测出来的深度桶和特征像素做外积得到了带有深度信息的特征图（$G(u,v) = D(u,v) \otimes F(u,v)$）且由于特征桶的结构，具有较高的容错性。称 G 为 frustum features</p><h3 id="Frustum-to-Voxel-Trans"><a href="#Frustum-to-Voxel-Trans" class="headerlink" title="Frustum to Voxel Trans"></a>Frustum to Voxel Trans</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1godzokeng2j30b907ujsr.jpg" alt></p><p>​    G 之后将被转换成体素的形式，这里的问题是在第分辨率的frustum features进行高分辨率的体素采样会导致过采样，导致出现大量相同的体素特征，浪费算力不说还降低预测准确性。所以这边作者直接把降采样前的特征层拉了过来，来保证不会出现上述问题。</p><h3 id="Voxel-Collapse-to-BEV-gt-Detection"><a href="#Voxel-Collapse-to-BEV-gt-Detection" class="headerlink" title="Voxel Collapse to BEV -&gt; Detection"></a>Voxel Collapse to BEV -&gt; Detection</h3><p>​    由于BEV在保证同等检测效果的情况下能够节省计算资源，作者将体素的 Z 轴和 channels 直接连接起来，继续用1x1卷积 + BN + ReLU 将体素块压缩成 BEV的形式。然后接着在 BEV 特征块上连接检测头进行 3D目标检测。</p><h2 id="深度离散化"><a href="#深度离散化" class="headerlink" title="深度离散化"></a>深度离散化</h2><p>​    本文的主要亮点就是其对于深度的处理，其对每个像素位置分配了离散化的深度桶，预测其属于某一深度的概率。这里的深度离散化作者使用的是 LID (Linear-increasing discretization)[3] 因为其对不同深度之间提供了最为平衡的预测概率。对于检测任务的深度我们最需要的是检测目标的深度信息，而更少去在意背景点的深度。</p><p>​                                                            <script type="math/tex">d_c = d_min + \frac{d_{max}-d_{min}}{D(D+1)}\cdot{d_i}{(d_1+1)}</script></p><p>​    <em>（其中 $d<em>c$ 是连续深度值，[$d</em>{min},d_{max}$]是离散化的上下界，D是深度桶的数量，$d_i$ 是下标）</em></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goe03wlr9sj30dn0bd0tp.jpg" alt></p><h2 id="实验效果"><a href="#实验效果" class="headerlink" title="实验效果"></a>实验效果</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goe0ckxhf6j30r10fgn17.jpg" alt="KITTI实验效果"></p><p>​    可以看到其在车辆和新人检测上都打破了目前最好的检测方法，对骑行者的检测不如 MonoPSR 但也大大超过了其余检测模型。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1goe0gh8vyhj30dw07jdgw.jpg" alt></p><p>这张表可以看出其将深度预测和特征融合所得到的 frustum features 确实有助于提升检测效果。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>​    个人觉得这篇paper的主要成功点在于其对于单目深度预测的创新解决方法，不同于传统的深度预测模型，提出了离散化深度将每个像素的深度概率离散化分配在不同的深度桶中，避免了网络过度依赖于深度的准确检测。但同时其也没有从根本上解决深度预测的问题，同时其中间对于特征图进行体素化投影再转为 BEV 的过程较为复杂，虽然其把降采样前的特征层拿来转成体素形式但是仍然还是无法避免会有损失。</p><p>​    个人觉得可以借鉴该模型的深度预测方法，应用在现有的模型上或者对该模型的网络结构进行简化，可能会带来更好的效果。</p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1]  Thomas Roddick, Alex Kendall, and Roberto Cipolla. Ortho graphic feature transform for monocular 3D object detection.<em>BMVC</em>, 2018</p><p>[2] Liang-Chieh Chen, George Papandreou, Florian Schroff, andHartwig Adam. Rethinking atrous convolution for semantic image segmentation. <em>arXiv preprint</em>, 2017</p><p>[3] Yunlei Tang, Sebastian Dorn, and Chiragkumar Savani. Center3d: Center-based monocular 3d object detection with joint depth understanding. <em>arXiv preprint</em>, 2020</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>Object Detection</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Monocular OD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法及编译器优化效果对比</title>
    <link href="/2021/03/08/ICS/ICS_Normal/"/>
    <url>/2021/03/08/ICS/ICS_Normal/</url>
    
    <content type="html"><![CDATA[<h2 id="ICS-Normal-第一周作业"><a href="#ICS-Normal-第一周作业" class="headerlink" title="ICS (Normal) 第一周作业"></a><em>ICS (Normal) 第一周作业</em></h2><h3 id="冒泡与快排用时对比"><a href="#冒泡与快排用时对比" class="headerlink" title="冒泡与快排用时对比"></a>冒泡与快排用时对比</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocut0coevj31do0sggpl.jpg" alt="冒泡排序"></p><h3 id="相同算法在-GCC-编译优化下用时对比"><a href="#相同算法在-GCC-编译优化下用时对比" class="headerlink" title="相同算法在 GCC 编译优化下用时对比"></a>相同算法在 GCC 编译优化下用时对比</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocvbzmuy0j31cy0s842c.jpg" alt="冒泡排序"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocut5qwjwj31a80smjvj.jpg" alt="快速排序"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocutaoylej31b40sqtcm.jpg" alt="优化快速排序"></p><h3 id="不同排序算法在不同GCC优化下的变化"><a href="#不同排序算法在不同GCC优化下的变化" class="headerlink" title="不同排序算法在不同GCC优化下的变化"></a>不同排序算法在不同GCC优化下的变化</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocutf9rb3j31cs0s8dih.jpg" alt="冒泡排序"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocuthxygzj31b20t4jtt.jpg" alt="快速排序"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocutkvifhj31b20swdi8.jpg" alt="优化快速排序"></p><hr><h3 id="改进快速排序"><a href="#改进快速排序" class="headerlink" title="改进快速排序"></a>改进快速排序</h3><p>对于快速排序的改进策略一般有两种</p><ul><li><strong><em>Pivot 三值取中</em></strong></li></ul><p>快速排序最坏情况是枢纽元为最大或者最小数字，那么所有数都划分到一个序列去了时间复杂度为O(n^2)，为了保证最坏情况不出现，尽量使pivot能够二分序列，我们采用三值取中法，既开头、中间、结尾三个元素选取大小中等的元素与首元交换成为Pivot，避免最坏情况出现。</p><p><strong>效果：</strong>在应用三值取中后可以发现优化快排的排序速度变得较为稳定，不像普通版本一样依赖于序列的形态。</p><ul><li><strong><em>小规模插入排序</em></strong></li></ul><p>即当快速排序所划分的子序列的长度小于某个定值k时，该子序列基本有序，可以采用插入排序的办法对子序列进行排序，从而使整体算法的时间复杂度的期望下降为 $O(nk+nlg(\frac{n}{k}))$</p><h3 id="实验效果"><a href="#实验效果" class="headerlink" title="实验效果"></a>实验效果</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocuto6qwgj317w0t076c.jpg" alt></p><p>可以看到在同等数据量下，对于快速排序具有一定优化效果</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocutsrs9ij31au0sctcp.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocutvjlj6j31bg0rkwig.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocutym2uij31bm0sotct.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocuu1tn5uj31b20swdk0.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gocuu4kk90j31b20s4n1a.jpg" alt></p><p>可以看到，随着优化等级的增加，优化的快排几乎成线性，更加稳定，而普通快排有所波动。</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DETR 论文阅读</title>
    <link href="/2021/01/22/Research/DETR/"/>
    <url>/2021/01/22/Research/DETR/</url>
    
    <content type="html"><![CDATA[<h1 id="End-to-End-Object-Detection-with-Transformers"><a href="#End-to-End-Object-Detection-with-Transformers" class="headerlink" title="End-to-End Object Detection with Transformers"></a>End-to-End Object Detection with Transformers</h1><p><em>关键词： 目标检测， Transformer，End-to-End</em></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    Detr 这篇文章抛弃了传统 Fast-RCNN 基于 ROI 的目标检测方式，使用了Transformer以及其提出的 bipartite matching 做到位置无关和生成唯一的目标检测框，以此省去了 Anchor 和 NMS。以非常简单的架构达到媲美甚至超越 Fast-RCNN 的准确率，在能够做目标检测的同时，该模型还有较好的迁移能力，在原论文中通过 Transformer 的 Attention 机制实现了全景分割。</p><h2 id="结构分析"><a href="#结构分析" class="headerlink" title="结构分析"></a>结构分析</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmwgc8ubqoj310s07t435.jpg" alt="网络结构图"></p><p>​    DETR 的网络结构很简单，分为三个部分，第一部分是一个传统 CNN 用于提取图片特征到更高维度，第二部分一个Transformer 的 Encoder 和 Decoder 来提取 Bounding Box，最后使用 Bipartite matching loss 来训练网络。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmwghk322pj30m8069adc.jpg" alt="结构细节"></p><p>​        更加细致的划分可划分为 CNN backbone 部分，Transformer 中的 Encoder 和 Decoder 部分，预测前馈网络 (FFN) 部分。接下来会详细讲解。</p><h3 id="CNN-部分"><a href="#CNN-部分" class="headerlink" title="CNN 部分"></a>CNN 部分</h3><p>​    DETR 的第一部分用了一个 CNN backbone 将 $x_{img} \in R^{3 \times H_0 \times W_0}$ (3 的 RGB 深度) 转换为 $f \in R^{C \times H \times W}$ 的特征层。论文中用了 $C = 2048, H = \frac{H_0}{32}, W = \frac{W_0}{32}$ </p><h3 id="Transformer-部分"><a href="#Transformer-部分" class="headerlink" title="Transformer 部分"></a>Transformer 部分</h3><h4 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h4><p>​    先用 1x1 的卷积核将纬度从 C 降到 d，获得一个新的特征图 $R^{ d \times H \times W}$ 。由于 Encoder 需要一个序列，我们要将特征图拉平成为 $d \times HW$ 的向量，输入到 encoder 中，每一个 encoder 都是同样的结构，由一个多头注意力模块和一个前馈网络（FFN）组成。不像RNN，transformer 的输入是顺序无关的，于是我们也学 NLP 对每一个注意力层加一个位置编码 （position encodings）。将状态编码和之前拉平的特征图向量相加之后喂入 encoder 中。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmwioerjhbj30ea0ghgq4.jpg" style="zoom:80%;"></p><h4 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h4><p>​    decoder 的输入有两个，一个是 Object Queries 另一个是刚刚 Encoder 的输出，结构和传统 Transformer 差不多。比较有意思的是这个输入的 Object Queries，由于 Transformer 是 fixed size，如果我们需要 N 个 Bounding Box 那么我们就需要 N 个输入，同时这个 Object Queries 顺便充当了 decoder 的 position encodings，是通过学习得来的。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmwi2hocbcj30eh0gb421.jpg" style="zoom:80%;"></p><p>​    encoder 的输出直接喂到的是 Encoder-Decoder Attention 层，这 N 个位置嵌入要先通过自注意力层才获得 encoder 的信息。作者将这 N 个 序列最后生成的 Bounding Box 拿出来可视化，结果非常 Amazing 啊。</p><p>​    <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmwinw5iwbj30wn075ale.jpg" alt></p><p>​    图中的不同颜色的点代表不同大小形态的 Bounding Box，绿色代表较小的 Bounding Box，紫色代较大的 Bounding Box，红色代表大的水平的 boxes，蓝色代表大的竖直的 boxes。 对于每一个输入序列，其都有所侧重，有的侧重与左侧的小 Bounding Box 有的侧重于中间大的Bounding Box。</p><h3 id="Bipartite-matching-loss"><a href="#Bipartite-matching-loss" class="headerlink" title="Bipartite matching loss"></a>Bipartite matching loss</h3><p>​    之前检测器往往通过anchor和groundtruth的IOU来确定正负样本，而DETR使用了bipartite matching loss 来确定正负样本。</p><p>​    <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmzoqacu30j307d01waa0.jpg" alt="bipartite matching loss"></p><p>​    其中 $L_{match}$ 是 ground true 和预测 bounding boxes 之间的 pair-wise matching cost （一一配对 penalty）</p><p>​    <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmzoq11i5jj303405hmxa.jpg" alt="bipartite matching"> </p><p>​    通过一一配对，就不需要再采取传统的 NMS 了，因为一个bounding box 只能和一个 ground true 进行匹配，必然会引入 loss。算法实现采用的是<strong>匈牙利算法</strong>，这个后期我会写在博客上。</p><h3 id="FFN"><a href="#FFN" class="headerlink" title="FFN"></a>FFN</h3><p>​    最后得出结果的网络，是一个三层的感知机，activation function 用的是 ReLU，以及一个线性映射层。输出的是每一个 bounding box 的中心坐标，以及它的宽高 $(x,y,w,h)$ 以及物体的分类。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>​    原文在 COCO 2017 数据集上做的实验，模型虽然简单但却消耗了大量的训练时间 （Training the baseline model for 300 epochs on 16 V100 GPUs takes 3 days, with 4 images per GPU），最后效果媲美甚至超过了经过良好调教的 Fast-RCNN 类的人工 head + anchor 的模式。</p><p>​    <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmzpkgtz3xj30gj06n75k.jpg" alt="实验结果"> </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​    这篇文章还是相当惊艳的，一直以来不管是 anchor based 还是 anchor free 的目标检测方法都难以脱离人工定义 anchor 的过程，而本篇文章通过使用 Transformer + positional encoding 达到甚至超越了传统方法的性能，里面特别是 positional encodings 的 object queries 非常耐人寻味，这些 queries 学到的真的只是 positional encoding吗？这个 queries 是否有可能是 tasks 无关的？如果是能不能通过预训练的方式来提高训练速度，这些问题都是后期值得探索的。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] Nicolas Carion, Francisco Massa, Gabriel Synnaeve, Nicolas Usunier, Alexander Kirillov, Sergey Zagoruyko: “End-to-End Object Detection with Transformers”, 2020; <a href="http://arxiv.org/abs/2005.12872">arXiv:2005.12872</a></p><p>[2] 如何评价FAIR的新论文DETR？ <a href="https://www.zhihu.com/question/397692959/answer/1258046044">https://www.zhihu.com/question/397692959/answer/1258046044</a> </p><p>[3] 如何看待End-to-End Object Detection with Transformers? <a href="https://www.zhihu.com/question/397624847/answer/1250143331">https://www.zhihu.com/question/397624847/answer/1250143331</a></p><p>[4] 详解Transformer （Attention Is All You Need）<a href="https://zhuanlan.zhihu.com/p/48508221">https://zhuanlan.zhihu.com/p/48508221</a></p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
      <category>Object Detection</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS_PJ Y86 Extended CPU</title>
    <link href="/2021/01/06/ICS/ICS_PJ/"/>
    <url>/2021/01/06/ICS/ICS_PJ/</url>
    
    <content type="html"><![CDATA[<p><em>项目地址： <a href="https://github.com/fdu2019xzy/ICS_Y86">https://github.com/fdu2019xzy/ICS_Y86</a></em></p><hr><h2 id="一、项目基本信息"><a href="#一、项目基本信息" class="headerlink" title="一、项目基本信息"></a>一、项目基本信息</h2><h3 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1. 项目简介"></a>1. 项目简介</h3><p>Y86-Extended 是由谢子飏和王少文组队合作完成的项目，作为复旦大学 ICS (上) 的期末PJ，<br>本项目在实现了本项目在基础流水线处理器架构之上添加了<strong>更高级的分支预测</strong>、<strong>硬件栈</strong>、 <strong>y86 指令集扩展</strong>，并编写了一个<strong>汇编器</strong> yyas (支持宏定义)，以及其他特殊功能。结合精美的前端，根据上传文件性质不同 (yo/ys) 可以在普通模式和编译模式下运行程序, 具有较高的鲁棒性, 能够直观的看到基本信息、所有的寄存器信息 (包括流水线寄存器)、运行进度、当前指令和其他信息。</p><p>支持任意<strong>前进回溯</strong>、<strong>设置断点</strong>、<strong>终端输出</strong> (包含<strong>彩色矩阵</strong>)等扩展功能</p><h3 id="2-项目分工"><a href="#2-项目分工" class="headerlink" title="2. 项目分工"></a>2. 项目分工</h3><p>王少文：后端 CPU 主体设计及汇编器<br>谢子飏： (中) 前端及测试</p><h3 id="3-项目架构及设计思路"><a href="#3-项目架构及设计思路" class="headerlink" title="3. 项目架构及设计思路"></a>3. 项目架构及设计思路</h3><p>我们的项目使用<strong>前后端分离</strong>开发策略，考虑到运行速度后端由 C++ 编写，中前端使用 Python, Vue.js, Js 开发。</p><ul><li>项目架构图</li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sAvtMV.png" style="width:500px"></p><ul><li>交互逻辑和运行过程</li></ul><p>整个交互逻辑和运行过程分为，前端上传 ys/yo 文件 post 到中端的 lauch.py 的flask服务器，flask驱动编译器编译并将编译好的yo文件传到 CPU 中。CPU 按设计跑完输出 data.json 文件，前端 fetch 后端 CPU 生成的 data.json 在前端按操作逻辑进行展示。</p><p>由于后端 C++ 跑的非常快，我们前端在上传后几乎能够即时获得 data, 而这样前后端分离的好处在于，我们前端可以非常自由的展现数据，所有的前进回溯甚至跳跃，都可以在 O(1) 内实现，不会出现很大的限制。</p><hr><h2 id="二、使用方式及功能详解"><a href="#二、使用方式及功能详解" class="headerlink" title="二、使用方式及功能详解"></a>二、使用方式及功能详解</h2><h3 id="1-具体使用方法"><a href="#1-具体使用方法" class="headerlink" title="1. 具体使用方法"></a>1. 具体使用方法</h3><p>(见项目目录下 README.md)</p><h3 id="2-功能详解"><a href="#2-功能详解" class="headerlink" title="2. 功能详解"></a>2. 功能详解</h3><ul><li>主体功能介绍图</li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sAv8Gn.png" alt></p><p><img src="https://s3.ax1x.com/2021/01/06/sAv3Ps.png" alt></p><ul><li>当前指令模块</li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sAvV2t.png" style="width:250px"></p><p>当前指令显示我们当前运行到的指令 (PC 所指)，并包含前后文2条指令的信息。</p><p><strong>隐藏断点设置</strong></p><p>为了前端的布局美观和统一性，断点设置被隐藏进了当前指令卡片中，点击当前指令卡片即可设置断点。</p><p><img src="https://s3.ax1x.com/2021/01/06/sAvE8I.png" style="width:400px"></p><p>可以任意设置增删断点</p><ul><li><strong>终端字符及彩色矩阵输出</strong></li></ul><p>根据后端的内存映射，我们可以让终端输出字符以及彩色矩阵。</p><p><img src="https://s3.ax1x.com/2021/01/06/sAvJx0.png" style="width:300px"></p><ul><li>附带我们编写的 YYAS 汇编器，能够实现 ys 到 yo 的编译</li></ul><hr><h2 id="三、代码详解"><a href="#三、代码详解" class="headerlink" title="三、代码详解"></a>三、代码详解</h2><h3 id="1-前端代码架构分析"><a href="#1-前端代码架构分析" class="headerlink" title="1. 前端代码架构分析"></a>1. 前端代码架构分析</h3><ul><li>前端代码架构图</li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sAvl5j.png" alt></p><p>前端设计采用 Vue.js 和前端框架 iView 设计，由于 Vue 的<strong>响应式渲染</strong>性质，非常适合我们本次的前端要求，同时为了保持多平台使用的可能性，Vue并没有使用脚手架，所有的 Vue.js、jQuery 都采用了 <strong>CDN 引入</strong>模式。</p><p>其中 Index 是主页面入口，Index.js 包括 Vue app 的创建和 Vue 页面路由， Index.html 包含主页面的 DOM 树</p><p>Pages 里面包含了主要的界面，主页面是 main.js 包含 cpu 的主要功能。<br>所有的 Pages 作为 export 模块被引入到 Index.js 中进行路由。<br>main.js 里面包含了 main 页面所有<strong>逻辑函数</strong>，<strong>声明周期钩子</strong>，以及 main 页面的 DOM 树， 其他页面也是同样架构。</p><p>（由于是 CDN 引入 main 页面要插入路由的话， DOM 树应当是字符串形式传入 template 中）</p><p>CSS 里面包含了所有主要的样式表，对功能和作用区域的不同做了简单的分类。</p><p>Static 里面包含了需要读取的 Json data 信息，以及当前处理编译文件放置在 Source 中。</p><ul><li><strong>中台前后端链接代码</strong></li></ul><p>前后端连接使用的是 python flask 服务器，通过接前端上传表单的 post，将获得的文件传入编译器编译之后喂入 CPU 中，获得 data.json 前端再 getData。</p><h3 id="2-后端代码架构分析"><a href="#2-后端代码架构分析" class="headerlink" title="2. 后端代码架构分析"></a>2. 后端代码架构分析</h3><ul><li>后端代码架构图</li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sAvQaQ.png" alt></p><ul><li>汇编器部分<ul><li>汇编器的可执行文件为yyas.py，这是包含了所有代码（不需要import）的最终文件，试试./yyas -v 和 ./yyas -h，有惊喜</li><li>instr.py为Y86所有指令的信息（不含Y86 Extended的扩展部分）</li><li>striper.py为Stage1时，将yo文件转化为yoraw的脚本，目前已经被弃用，仅作为存档提交。现在实现相同功能请使用./yyas -r -np</li></ul></li><li>CPU部分<ul><li>Controller.cpp 为CPU的控制器，主要包含了流水线的控制逻辑</li><li>Device.cpp 为CPU流水线的核心，包含了FDEMW五个阶段的运行逻辑</li><li>Output.cpp 有一些用于输出的函数，用于Stage1输出至命令行或Stage2输出至json文件</li><li>Util.cpp包含了一些辅助的函数，例如In函数和Format函数（这里用了很多modern cpp的魔法）</li></ul></li></ul><hr><div style="page-break-after: always;"></div><h2 id="四、-实现细节"><a href="#四、-实现细节" class="headerlink" title="四、 实现细节"></a>四、 实现细节</h2><h4 id="前端细节"><a href="#前端细节" class="headerlink" title="前端细节"></a>前端细节</h4><p>前端搭建了 anywhere 服务器 (用于解决跨域问题, 踩坑经历可以看第五节)，主要函数在 main.js 文件中， 通过各类声明周期函数和写的 handle 来处理上传，运行，停止，重置，以及断点设置等功能，此处不展开细讲，主要是后端。</p><p>（前端使用了 anywhere 服务器 + 中端 flask 服务器的双服务器架构，其主要是因为我们前端在 import 模块时不开本地服务器会产生跨域问题。对于跨域问题我们最开始遇到是在获取 data.json 的时候，踩坑过程中我们曾尝试通过jsonp 解决跨域问题，并且成功了，但在 import 模块时再次遇到了跨域问题，为了一劳永逸，我们直接使用了 anywhere 直接开了一个本地服。）</p><h4 id="后端细节"><a href="#后端细节" class="headerlink" title="后端细节"></a>后端细节</h4><ol><li><p><strong>关于流水线</strong>：为了尽可能的靠近实际的硬件架构，我们的CPU核心实现分成了<strong>wire</strong>和<strong>reg</strong>两种struct，用来模拟verilog硬件语言中的wire和reg，reg是实际存在的寄存器，而wire只是用于逻辑中转。为了模拟CPU的并行化，我们采用了如下的逻辑</p><ol><li>利用Reg中的数据计算F D E M W，写入wire变量（实际不存在）</li><li>利用现在的wire上的值，更新流水线及其他状态</li><li>将wire的值写入下一个Reg，例如f_wire写入D_Reg，当流水线状态为NORMAL时回到a</li></ol></li><li><p>每个阶段的具体实现逻辑， 与CSAPP上的电路实现差别不大，此处不再赘述</p></li><li><p><strong>关于扩展指令集</strong>：我们的指令集扩展见<strong>ISA.md</strong>，具体到流水线上只需少许修改各个阶段的逻辑，与官方设计思路差不太多，依次修改FDEMW就行。</p></li><li><p><strong>关于分支预测策略</strong>：我们的分支预测采用的是<strong>2比特溢出预测器</strong>，该预测器采用的逻辑如下图</p><p><img src="https://s3.ax1x.com/2021/01/06/sAvG2q.png" alt="预测器"></p><ol><li>当JXX的信号不是Jmp时，更新上述的状态机</li><li>若状态机信号为3或者2，则进行跳转</li><li>若状态机信号为1或者0，则不进行跳转</li></ol><p>除此之外，我们也需要相应的改变分支错判的逻辑，需要加一个IfJump信号，当E阶段输出的信号与IfJump信号不同，说明分支预测错误，需要清空流水线。</p><p>这样的分支预测器，据统计可以达到90%的正确率（<a href="https://en.wikipedia.org/wiki/Branch_predictor），在我们的测试中，一般情况下可以提升10%-30%的性能">https://en.wikipedia.org/wiki/Branch_predictor），在我们的测试中，一般情况下可以提升10%-30%的性能</a></p></li><li><p><strong>关于复杂指令</strong>：在我们增加的指令中，有一些指令如mulq、divq和remq都是很耗时的指令，如果强行让他们在一个周期内完成，我们的CPU时钟频率就会非常低。因此我们假定这部分指令所需要的时间为其他指令最长耗时的10倍，在E阶段设置一个counter，建立一个递减的状态机，使用下面的控制逻辑</p><ol><li>如果指令属于上述复杂指令，将状态机置于10</li><li>如果状态机不为0，则使F D阶段进入STALL阶段，E阶段继续计算，但阻断E到M的输入，状态机减1</li><li>如果状态机为0，则流水线继续执行</li></ol><p>这样就可以实现维持较高CPU频率的同时，实现复杂指令。（即不会因为加了这个指令使其他指令的执行变慢）</p></li><li><p><strong>关于硬件栈</strong>：为了避免每次调用ret指令时两个时钟周期的浪费，我们采用了CSAPP上的硬件栈。在硬件上，硬件栈可以由多路选择器和多个寄存器构成，在这里我们简单的使用Stack实现（大小为0x20）。采用如下的控制逻辑：</p><ol><li>如果调用call指令，在栈没有满时，将地址载入硬件栈</li><li>如果调用ret指令，在栈非空时，弹栈，将值读出</li><li>在M阶段执行后，判断硬件栈的预测是否正确<ol><li>若正确，则继续执行</li><li>若不正确，则清空 F D E的流水线</li></ol></li></ol><p>使用硬件栈后，最差的情况即是与无硬件栈情况相同，最好情况在我们的测试中，可以增加30%+的性能。</p></li><li><p>关于指令不可写和非指令不可读保护：我们的汇编器会计算yo文件中，最后一个是指令的位置，在CPU运行时，会进行动态的判断</p><ol><li>在Fetch阶段读取不可读的位置，会产生INS错误</li><li>在其他阶段写入不可写的位置，会产生ADR错误</li></ol></li><li><p>关于宏定义：为了CPU的扩展性和兼容性，我们使用了宏定义来动态的开关某些特性，例如 <code>OUTPUT_JSON</code> 宏定义后即可输出 data_json 供前端使用。</p></li></ol><h4 id="汇编器细节"><a href="#汇编器细节" class="headerlink" title="汇编器细节"></a>汇编器细节</h4><p>我们的汇编器采用了依次处理的方式，如下(Code Explains itself)</p><pre><code class="hljs python">lines = gen_list(lines) <span class="hljs-comment">#解析关键词</span>lines = remove_single_line_annot(lines) <span class="hljs-comment">#去除单行注释</span>lines = remove_multi_line_annot(lines) <span class="hljs-comment">#去除多行注释</span>lines = detach_label(lines) <span class="hljs-comment">#找到对应的label</span>lines_ref = copy.deepcopy(lines) <span class="hljs-comment">#复制一份用于输出</span>mem = get_memaddr(lines) <span class="hljs-comment">#找到内存对应的地址</span>labels = get_def_label(lines) <span class="hljs-comment">#处理.define</span>lines = replace_label(lines, mem, labels) <span class="hljs-comment">#处理label</span>byte_code = gen_byte_code(lines) <span class="hljs-comment">#产生yo代码</span></code></pre><h4 id="测试细节"><a href="#测试细节" class="headerlink" title="测试细节"></a>测试细节</h4><p>我们采用Google Test 和 Python Unitest来辅助我们进行我们的程序测试。其在我们项目文件的 test 文件夹下，我们通过 shell 脚本和 python 脚本将模拟器的输出进行处理，转换成 gtest 代码以便于我们进行测试。</p><p>基本语句即为 <code>EXPECT_EQ(x, y)</code></p><ul><li>测试代码结构</li></ul><p><img src="/2021/01/06/ICS/ICS_PJ/测试代码架构.png" alt></p><p>使用 Google Test 我们能够清晰的看到测试点信息。</p><ul><li>普通 yo_test</li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sAvZxP.png" style="width:300px"></p><ul><li>Hornor 测试</li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sAvmKf.png" style="width:300px"></p><ul><li>附加测试</li></ul><p><img src="https://s3.ax1x.com/2021/01/06/sAvMVg.png" style="width:400px"></p><hr><div style="page-break-after: always;"></div><h3 id="五、特点和创新"><a href="#五、特点和创新" class="headerlink" title="五、特点和创新"></a>五、特点和创新</h3><ol><li><p><strong>汇编器创新</strong>：我们兼容现有的所有ys文件的基础上，还添加了一些伪指令和语法</p><ol><li>不需要写逗号了：现在所有的ys指令操作数之间可以使用空格隔开</li><li>mrmovq和rmmovq：现在不需要强制写括号，可以直接mov至常数地址（此时寄存器为RNONE，我们的CPU也做了相应的修改）如rmmovq %rax $800</li><li>伪指令<ol><li>.define 类似C语言的宏定义</li><li>.string “mystring” 将后面的mystring转化为对应的ASCII码写入</li><li>.byte .hword .word支持</li></ol></li><li>能够生成yo文件和yoraw文件，生成的yo文件比官方的yo文件漂亮不少，完全对齐</li><li>有完整的命令行参数</li></ol><pre><code class="hljs"><span class="hljs-attribute">usage</span>: yyas [-h] [-o OUTFILE] [-r] [-np] [-v] sourcefile<span class="hljs-attribute">yyas</span>: Assemble .ys file to .yo file or/and .yo file to raw byte filepositional arguments:  sourcefile            The source file to be assembledoptional arguments:  -h, --help            show this help message and exit  -o OUTFILE, --output OUTFILE                        Assign the output file  -r, --raw             Generate raw byte file  -np, --noprefix       Do not generate prefix in raw output  -v, --version         show version</code></pre></li><li><p><strong>处理器创新</strong>（见具体实现）</p><ol><li>更好的分支预测器</li><li>硬件栈</li><li>几乎三倍的指令集支持（及其扩展含义）</li><li>复杂指令集的多周期支持</li></ol></li></ol><hr><h3 id="六、总结与回顾"><a href="#六、总结与回顾" class="headerlink" title="六、总结与回顾"></a>六、总结与回顾</h3><h4 id="PJ-心得总结及致谢"><a href="#PJ-心得总结及致谢" class="headerlink" title="PJ 心得总结及致谢"></a>PJ 心得总结及致谢</h4><p>本次 PJ 让我们更加深入的理解了现代流水线处理器的原理，各种硬件栈，扩展指令集的设计也拓展了我们的技术边缘，非常不错的体验。最后非常感谢助教和金老师一学期的辛苦工作。在很多方面帮助了我们，助教的 Lab 非常精彩有趣，金老师的课十分幽默风趣，非常感谢各位的付出。</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>期末 DDL + TODOList</title>
    <link href="/2020/12/17/final_todo/"/>
    <url>/2020/12/17/final_todo/</url>
    
    <content type="html"><![CDATA[<h1 id="期末季DDL"><a href="#期末季DDL" class="headerlink" title="期末季DDL"></a>期末季DDL</h1><h3 id="这周的-数据结构-离散-数逻-作业"><a href="#这周的-数据结构-离散-数逻-作业" class="headerlink" title="这周的 数据结构/离散/数逻 作业"></a>这周的 数据结构/离散/数逻 作业</h3><h4 id="预计需要-4h"><a href="#预计需要-4h" class="headerlink" title="- 预计需要: 4h+"></a>- 预计需要: 4h+</h4><h3 id="实验室-Reading-Group-ddl-12-23-下周三"><a href="#实验室-Reading-Group-ddl-12-23-下周三" class="headerlink" title="实验室 Reading Group ( ddl: 12/23 下周三 )"></a>实验室 Reading Group ( <em>ddl: 12/23 下周三</em> )</h3><h4 id="预计需要-2-3h"><a href="#预计需要-2-3h" class="headerlink" title="- 预计需要: 2 ~ 3h"></a>- 预计需要: 2 ~ 3h</h4><h3 id="毛概实践报告-ddl-12-24-下周四"><a href="#毛概实践报告-ddl-12-24-下周四" class="headerlink" title="毛概实践报告 ( ddl: 12/24 下周四 )"></a>毛概实践报告 ( <em>ddl: 12/24 下周四</em> )</h3><ul><li><ol><li>字数5k字<h4 id="预计需要-2-3h-1"><a href="#预计需要-2-3h-1" class="headerlink" title="- 预计需要: 2 ~ 3h"></a>- 预计需要: 2 ~ 3h</h4><h4 id="安排时间：今晚毛概课给它干掉！"><a href="#安排时间：今晚毛概课给它干掉！" class="headerlink" title="- 安排时间：今晚毛概课给它干掉！"></a>- 安排时间：今晚毛概课给它干掉！</h4></li></ol></li></ul><h3 id="ICSPJ-Stage2-ddl-12-24-下周四"><a href="#ICSPJ-Stage2-ddl-12-24-下周四" class="headerlink" title="ICSPJ-Stage2 ( ddl: 12/24 下周四 )"></a>ICSPJ-Stage2 ( <em>ddl: 12/24 下周四</em> )</h3><ul><li><ol><li>前端优化添加功能 ( 10h )</li></ol></li><li><ol><li>PPT ( 3h )<h4 id="预计需要-15h"><a href="#预计需要-15h" class="headerlink" title="- 预计需要: 15h+"></a>- 预计需要: 15h+</h4></li></ol></li></ul><h3 id="美国文学选读考试-ddl-12-27-下周日晚上"><a href="#美国文学选读考试-ddl-12-27-下周日晚上" class="headerlink" title="美国文学选读考试 ( ddl: 12/27 下周日晚上 )"></a>美国文学选读考试 ( <em>ddl: 12/27 下周日晚上</em> )</h3><ul><li><ol><li>文本复习 ( 5h )</li></ol></li><li><ol><li>作者复习 ( 5h )<h4 id="预计需要-1day"><a href="#预计需要-1day" class="headerlink" title="- 预计需要 ( 1day )"></a>- 预计需要 ( 1day )</h4></li></ol></li></ul><h3 id="数据结构上机考-ddl-12-28-下下周一"><a href="#数据结构上机考-ddl-12-28-下下周一" class="headerlink" title="数据结构上机考 ( ddl: 12/28 下下周一 )"></a>数据结构上机考 ( <em>ddl: 12/28 下下周一</em> )</h3><ul><li><ol><li>复习算法 ( 8h )</li></ol></li><li><ol><li>复习上机题 ( 10h+ )<h4 id="预计需要-20h"><a href="#预计需要-20h" class="headerlink" title="- 预计需要: 20h+"></a>- 预计需要: 20h+</h4></li></ol></li></ul><h3 id="数逻-LAB7-ddl-12-29-下下周二"><a href="#数逻-LAB7-ddl-12-29-下下周二" class="headerlink" title="数逻 LAB7 ( ddl: 12/29 下下周二 )"></a>数逻 LAB7 ( <em>ddl: 12/29 下下周二</em> )</h3><h4 id="预计需要-3h"><a href="#预计需要-3h" class="headerlink" title="- 预计需要: 3h+"></a>- 预计需要: 3h+</h4><h3 id="毛概考试-ddl-12-29-下下周二"><a href="#毛概考试-ddl-12-29-下下周二" class="headerlink" title="毛概考试 ( ddl: 12/29 下下周二 )"></a>毛概考试 ( <em>ddl: 12/29 下下周二</em> )</h3><ul><li><ol><li>复习 ( 1h )<h4 id="预计需要-1h"><a href="#预计需要-1h" class="headerlink" title="- 预计需要: 1h+"></a>- 预计需要: 1h+</h4></li></ol></li></ul><h3 id="ICS-LAB5-ddl-12-30-下下周三"><a href="#ICS-LAB5-ddl-12-30-下下周三" class="headerlink" title="ICS-LAB5 ( ddl: 12/30 下下周三 )"></a>ICS-LAB5 ( <em>ddl: 12/30 下下周三</em> )</h3><h4 id="预计需要-3h-1"><a href="#预计需要-3h-1" class="headerlink" title="- 预计需要: 3h"></a>- 预计需要: 3h</h4><h3 id="近代中国思想与人物期末论文-ddl-未知"><a href="#近代中国思想与人物期末论文-ddl-未知" class="headerlink" title="近代中国思想与人物期末论文 ( ddl: 未知 )"></a>近代中国思想与人物期末论文 ( <em>ddl: 未知</em> )</h3><h4 id="预计需要-1day-1"><a href="#预计需要-1day-1" class="headerlink" title="- 预计需要: 1day"></a>- 预计需要: 1day</h4><h3 id="数据结构PJ-ddl-1-3-下下周日"><a href="#数据结构PJ-ddl-1-3-下下周日" class="headerlink" title="数据结构PJ ( ddl: 1/3 下下周日 )"></a>数据结构PJ ( <em>ddl: 1/3 下下周日</em> )</h3><h4 id="预计需要-12h"><a href="#预计需要-12h" class="headerlink" title="- 预计需要: 12h+"></a>- 预计需要: 12h+</h4><h3 id="数据结构考试-ddl-1-5-下下下周二"><a href="#数据结构考试-ddl-1-5-下下下周二" class="headerlink" title="数据结构考试 ( ddl: 1/5 下下下周二 )"></a>数据结构考试 ( <em>ddl: 1/5 下下下周二</em> )</h3><ul><li><ol><li>复习课本 ( 5h )<h4 id="预计需要-5h"><a href="#预计需要-5h" class="headerlink" title="- 预计需要: 5h+"></a>- 预计需要: 5h+</h4></li></ol></li></ul><h3 id="数逻考试-ddl-1-11-下下下下周一"><a href="#数逻考试-ddl-1-11-下下下下周一" class="headerlink" title="数逻考试 ( ddl: 1/11 下下下下周一 )"></a>数逻考试 ( <em>ddl: 1/11 下下下下周一</em> )</h3><h4 id="预计需要-1d"><a href="#预计需要-1d" class="headerlink" title="- 预计需要: 1d+"></a>- 预计需要: 1d+</h4><h3 id="离散考试-ddl-1-12-下下下下周二"><a href="#离散考试-ddl-1-12-下下下下周二" class="headerlink" title="离散考试 ( ddl: 1/12 下下下下周二 )"></a>离散考试 ( <em>ddl: 1/12 下下下下周二</em> )</h3><h4 id="预计需要-2d"><a href="#预计需要-2d" class="headerlink" title="- 预计需要: 2d+"></a>- 预计需要: 2d+</h4>]]></content>
    
    
    <categories>
      
      <category>TODO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TODO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PointCNN论文阅读</title>
    <link href="/2020/12/08/Research/PointCNN/"/>
    <url>/2020/12/08/Research/PointCNN/</url>
    
    <content type="html"><![CDATA[<h1 id="PointCNN"><a href="#PointCNN" class="headerlink" title="PointCNN"></a>PointCNN</h1><p>回顾之前读过的 PointNet++ 是受到 CNN 启发，通过局部的特征提取器和hierarchy 结构解决了 PointNet 在 local 上的劣势。但同时这种基于 PointNet 的顺序不依赖性使用的 symmetry function 最终总会导致一部分的信息丢失，PointCNN 直接使用 CNN 架构和一种自定义的 $\chi -Conv$ 操作，使常规的卷积也能处理点云。</p><hr><h2 id="关键问题-PointCloud-上的卷积"><a href="#关键问题-PointCloud-上的卷积" class="headerlink" title="关键问题 - PointCloud 上的卷积"></a>关键问题 - PointCloud 上的卷积</h2><p>我们都知道普通的 2d 卷积的实现方式，因为在图片上像素都是紧密相连的，很好实现，但对于 3d 的 Points 点的空间位置，距离，顺序都会对卷积造成挑战和影响，下图就展示了普通的 2d卷积 和 3d PointCloud 卷积的区别。</p><p><img src="https://s3.ax1x.com/2020/12/08/r9iVTU.png" alt></p><p>显然 PointCloud 上的卷积和形状(即点的相对位置) 和输入顺序有关。如果直接在上面做卷积就会发生灾难。</p><p><img src="https://s3.ax1x.com/2020/12/08/r9infJ.png" alt></p><p>上图我们看出，直接做卷积的话 $f<em>{ii}$ 和 $f</em>{iii}$ 不同的形状信息被丢失了（这正是我们希望保留的），而 $f<em>{iii}$ 与 $f</em>{iv}$ 之间仅因为顺序不同而造成了结果不同，即顺序有关，这是我们不希望看到的。</p><p>对于这个的解决方式，PointCNN 的作者使用了一个 $\chi$ - transformer 矩阵，先对 sample point 作用 $\chi$ 变换矩阵，再进行 Convolution 从而做到顺序无关的同时，不像 symmetry function 会丢失信息。</p><p><img src="https://s3.ax1x.com/2020/12/08/r9ilOx.png" alt="有点懒得翻译了，直接放原文"></p><p>可以看出这个 $\chi$ - transformation 是通过训练一个多层感知机获得的。同时产生输入点集的权重和排序，进而直接作用一个经典的卷积。</p><p><img src="https://s3.ax1x.com/2020/12/08/r9imY4.png" alt></p><p>简单来说就是我们希望对于 $\chi<em>{iii}$ 、 $\chi</em>{iv}$ 对于 $f<em>{iii}$ 、 $f</em>{iv}$ 的作用能够得到相同的feature，一种简单的实现方式就是找到一个变换矩阵 $\Pi$ 使得 $f<em>{iii}^{T} = \Pi \times f</em>{iv}^T$ 这样  $\chi<em>{iii} = \chi</em>{iv} \times \Pi$ 就可以达到目标。</p><p>值得注意的是，多层感知机得出的 $\Pi$ 并非一定是理想化的0101矩阵，而是有如0.1，0.9这样接近01的值，也可以将其理解为 feature 的权重这样得到的结果并不是完美的 即 $f<em>{iii}^{T} ≈ \Pi \times f</em>{iv}^T$</p><hr><h2 id="点云的平移不变性"><a href="#点云的平移不变性" class="headerlink" title="点云的平移不变性"></a>点云的平移不变性</h2><p>对于平移不变性的处理 PointCNN 很简单的使用了局部坐标系的转换，对于分割问题，采用最远点采样方式，然后对于采样点取 k - nearnest neighbours 将坐标系转换到采样点为中心的局部坐标系(即减去采样点坐标)</p><p><img src="https://s3.ax1x.com/2020/12/08/r9iekF.png" alt></p><p>对于卷积层，具体算法如下</p><p><img src="https://s3.ax1x.com/2020/12/08/r9i3m6.png" alt></p><ul><li>先做feature的选点和聚合，先转换到采样点局部坐标系</li><li>利用MLP将每个点变换到高维空间$C_{\delta}$ （这里用的是一维卷积）</li><li>Concat 其他特征信息</li><li><strong>对每个局部区域中的点使用MLP，得到变换矩阵X</strong></li><li>将得到的 $\chi$ 作用在 $F<em>*$ 上生成顺序不依赖的 $F</em>{\chi}$</li><li>对顺序不依赖的 $F_{\chi}$ 做 Convolution (这里也是一维卷积)</li></ul><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p><img src="https://s3.ax1x.com/2020/12/08/r9i80K.png" alt></p><p>对于 $\chi$ - transformer 的效果有上图的 visualization 可以看到 $F<em>*$ 中不同的 class 还是有overlap的因为对于 $F</em>*$ 其仅将特征提取到了高维，但其结果还是依赖于输入的顺序，所以不能够很好的划分featrue，而经过了 $\chi$ - transformer 不同的feature 被划分开来且更为密集，结果较好。</p><h2 id="模型效果"><a href="#模型效果" class="headerlink" title="模型效果"></a>模型效果</h2><p><img src="https://s3.ax1x.com/2020/12/08/r9iMlR.png" alt></p><p>可以看到准确率保持在一个比较高的水平。</p><p><img src="https://s3.ax1x.com/2020/12/08/r9iQ61.png" alt></p><p>同时 PointCNN 具有更少的参数 (0.6M) 以及极快的速度 (0.012s)<br>PointCNN 极具前景可以将 CNN 现有的工作进行应用。后续会看 PointCNN++ 等论文。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PointCNN 直接将点云和CNN结合将点云的工作引入到了一个开阔的领域，但近来也有一些工作在质疑 CNN 的必要性，google 的论文 Attention is all you need 就指出在 NLP 领域 transformer attention based 方法巨大的前景，也为 3D instance segmentation 提供了新思路。<br>关于 PointCNN 这篇经典读的还不是很透，关于 sample 选点的顺序问题和一些训练细节还没有弄的很懂，之后找时间细看。</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PointCNN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PointNet++论文阅读</title>
    <link href="/2020/12/08/Research/PointNetpp/"/>
    <url>/2020/12/08/Research/PointNetpp/</url>
    
    <content type="html"><![CDATA[<h1 id="PointNet"><a href="#PointNet" class="headerlink" title="PointNet++"></a>PointNet++</h1><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><p>回顾一下 PointNet ，我们说PointNet解决了 PointCloud 输入的顺序无关问题，但其有一个缺点就是无法获取局部特征，即没有很好的处理 local information，使其在复杂场景下表现乏力。PointNet++正是针对PointNet这一弱点进行改进。</p><ul><li>主要改进方式</li></ul><ol><li><p>受到 CNN 神经元感受野不断扩大的启发，利用空间距离，使 PointNet对点集局部区域进行特征迭代提取。</p></li><li><p>使用最远点提取方式，能够实现较为均匀的点采样</p></li></ol><h2 id="关键问题"><a href="#关键问题" class="headerlink" title="关键问题"></a>关键问题</h2><p>一、如何做点集划分 (怎么划分空间)</p><p>二、如何利用特征提取器提取局部特征信息 (怎么提取特征)</p><p>这两个问题是相关的，如果和 CNN 做一个类比，在CNN中卷积核是基本的特征提取器，每个卷积核对应一个 n*n 的像素区域，在PointCloud中同样要找到结构相同的子区域和对应的特征提取器。</p><p>那么在 PointNet++ 中作者使用欧式空间中的邻接球作为子区域做点集的 Partition 使用 PointNet 作为特征提取器。</p><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p><img src="https://pic1.zhimg.com/80/v2-f3f9a70d0052be1949a18c6e556572b8_1440w.jpg" alt></p><p>主要包括三部分</p><h3 id="Sample-layer"><a href="#Sample-layer" class="headerlink" title="Sample layer"></a>Sample layer</h3><p>主要对输入点进行采样，使用最远点采样法，选择$N$个点，能够更均匀的覆盖整个点集。<br><img src="https://img-blog.csdnimg.cn/20200923132734170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1FUVkxD,size_16,color_FFFFFF,t_70#pic_center" alt></p><h3 id="Grouping-layer"><a href="#Grouping-layer" class="headerlink" title="Grouping layer"></a>Grouping layer</h3><p>确定点的局部划分，即确定邻接球的半径和内部的点的数量。<br>一种是 ball query 看半径，还有就是用 KNN 看内部点的数量</p><h3 id="PointNet-layer"><a href="#PointNet-layer" class="headerlink" title="PointNet layer"></a>PointNet layer</h3><p>通过 PointNet 进行特征提取，假设每个 Group 中有 $n$ 个点，那么通过 PointNet 将 $n\times 3$ 的矩阵转换成 $n\times K$ 的矩阵。迭代进行操作，感受野逐渐扩大，维数逐渐提升。</p><h2 id="不均匀点云数据"><a href="#不均匀点云数据" class="headerlink" title="不均匀点云数据"></a>不均匀点云数据</h2><p>我们知道点云数据不像图片中的信息是紧密连接的，空间中的点有稀疏和稠密之分。这时候如果平均采样那么会在空间中点稀疏的地方造成浪费，在点密集的地方却不足以提取到足够的信息。为此 PointNet++ 作者提出了两种方式来保证更加优化的特征提取。</p><p><img src="https://pic1.zhimg.com/80/v2-5389688194b56daf0311e926360f8e6c_1440w.jpg" alt></p><h3 id="多尺度组合-multi-scale-grouping-MSG"><a href="#多尺度组合-multi-scale-grouping-MSG" class="headerlink" title="多尺度组合 (multi-scale grouping, MSG)"></a>多尺度组合 (multi-scale grouping, MSG)</h3><p>对于同一个点多次采用不同的Grouping，过PointNet之后将特征 concat，增加了很多计算量，耗时。</p><h3 id="多分辨率组合（multi-resolution-grouping-MRG）"><a href="#多分辨率组合（multi-resolution-grouping-MRG）" class="headerlink" title="多分辨率组合（multi-resolution grouping, MRG）"></a>多分辨率组合（multi-resolution grouping, MRG）</h3><p>相当于多层之间采用了不同的分辨率，先用小的grouping通过两层正常提取出的特征，和一次大的grouping提取出的特征进行一个concat，组合了两种分辨率的信息。</p><hr><h2 id="实验效果"><a href="#实验效果" class="headerlink" title="实验效果"></a>实验效果</h2><p><img src="https://s3.ax1x.com/2020/12/08/rpkt39.png" alt></p><p>从实验效果上我们可以看出其准确率明显好于单一的PointNet，并且在使用了 MSG 和 MRG 后对于大量点集的鲁棒性明显提升了。</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PointNet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>素数筛法 (2020-12-7)</title>
    <link href="/2020/12/07/DS/DataStructureNote2/"/>
    <url>/2020/12/07/DS/DataStructureNote2/</url>
    
    <content type="html"><![CDATA[<h1 id="素数筛法"><a href="#素数筛法" class="headerlink" title="素数筛法"></a>素数筛法</h1><p>我们今天来讲讲筛法，今天上机出其不意的考了一手筛法，我居然天真的在写暴力素数判断。所以今天就来复习(重学)一下筛法。</p><p>如果我们想要判断一个数是否是素数有什么方法呢？ 暴力判断肯定是最容易想到的方法，按定义素数不能被1和其自身以外的数整除，我们自然会想到从 x - 1到2全判一遍的算法。但显然，我们做了很多重复的工作。</p><p>实际上我们可以发现，如果我们判断出了一个素数，那么它的倍数显然就不可能是素数，这样就可以直接将其开除“素籍“，踢出待选区域。这种筛选素数的方法就像一个筛子，每碰到一个素数就筛掉一批非素数，大大降低了复杂度。</p><p><img src="https://images2015.cnblogs.com/blog/927750/201612/927750-20161229220529101-1487746442.png" alt></p><h2 id="埃拉托斯特尼筛法"><a href="#埃拉托斯特尼筛法" class="headerlink" title="埃拉托斯特尼筛法"></a>埃拉托斯特尼筛法</h2><p>按上述思想写出代码，就是埃氏筛法。</p><ul><li>代码实现</li></ul><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Eratosthenes</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i)         is_prime[i] = <span class="hljs-number">1</span>;    is_prime[<span class="hljs-number">0</span>] = is_prime[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)     &#123;        <span class="hljs-keyword">if</span> (is_prime[i]) <span class="hljs-comment">// 直接从2开筛不会放进来一个非素数</span>        &#123;            prime[p++] = i;             <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)i * i &lt;= n)                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * i; j &lt;= n; j += i)                    <span class="hljs-comment">// 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i 的 i倍开始，提高了运行速度</span>                    is_prime[j] = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 是i的倍数的均不是素数</span>        &#125;    &#125;    <span class="hljs-keyword">return</span> p;&#125;</code></pre><h3 id="复杂度计算"><a href="#复杂度计算" class="headerlink" title="复杂度计算"></a>复杂度计算</h3><p>关于埃氏筛法的复杂度计算，我们来做一个推导，首先我们可以看出每次循环中，若当前素数是p，那么单次循环执行 n/p 次， 所以总的表达式就是 n 乘上所有素数的倒数和 $n\sum_{p} \frac{1}{p}$</p><p>关于所有素数的倒数和，在欧拉相关的论文中有明确的估计。</p><script type="math/tex; mode=display">\sum_{p\le x} \frac{1}{p} = \ln\ln(x) + \gamma + \sum_{m = 2}^{\infty}{\mu (m){\frac{\zeta(m)}{m} + \delta}}</script><p>论文链接 [<a href="https://arxiv.org/pdf/math/0504289.pdf">https://arxiv.org/pdf/math/0504289.pdf</a>]</p><p>可知埃氏筛法的复杂度为 $O(nloglogn)$</p><hr><h2 id="欧拉筛法-（线性筛）"><a href="#欧拉筛法-（线性筛）" class="headerlink" title="欧拉筛法 （线性筛）"></a>欧拉筛法 （线性筛）</h2><p>TODO</p>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Number theory</tag>
      
      <tag>Multiplication algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PointNet论文阅读</title>
    <link href="/2020/12/06/Research/PointNet/"/>
    <url>/2020/12/06/Research/PointNet/</url>
    
    <content type="html"><![CDATA[<h3 id="PointCloud"><a href="#PointCloud" class="headerlink" title="PointCloud"></a>PointCloud</h3><p>何谓点云，点云数据和普通的照片又有什么不同？实际上点云并非什么高深的东西，下图就是一张点云的可视化数据。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1607249767189&amp;di=e4964b8b875326b97e5ab06da6196601&amp;imgtype=0&amp;src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fq_70%2Cc_zoom%2Cw_640%2Fimages%2F20180118%2F537a4b5eab09459881f9bc6ca18834f9.jpeg" alt="点云街道"></p><ul><li><strong>位置信息</strong><br>不同于原先2D的图像，每个像素点仅有RGB信息，点云自带了欧式空间中的位置信息，即坐标(x,y,z) 之后会附带一些RGB灰度值之类的普通图像像素就具有的东西。</li></ul><p>了解了点云之后我们来解析一下PointNet这篇论文[1]</p><hr><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>不同于当时许多处理3D点云任务时，直接将3D点云转化成体素矩阵(Voxel grid)的方式，但由于3D空间不同于2D大量的空间里都是空的(zero grid)，将他们全部体素化会造成不必要的浪费。PointNet可以<strong>直接输入点云</strong>信息，来解决这一问题，同时避免一些转换中造成的其他问题。</p><h3 id="点云数据的特点"><a href="#点云数据的特点" class="headerlink" title="点云数据的特点"></a>点云数据的特点</h3><p><strong>1. 无序性 （Unordered）</strong><br>我们都知道在欧式空间的度量中点和点之间是不存在像一维二维空间中的序关系的。(可能不严谨，数学不太好，暂时就这样理解)<br>对于点云数据信息，每个点<strong>喂入的顺序不应当影响到结果</strong></p><p><strong>2. 局部相关性 (Interaction among points)</strong><br>我们知道在<strong>空间中的点和其周边点之间的位置关系信息是有意义的</strong>，它代表了物体的形状特征。这正是我们在2D CNN工作中卷积层所提取的东西，因而我们要保留这个特征信息。</p><p><strong>3. 不变性 （Invariance under transformation）</strong><br>对于点云数据应该满足一些<strong>空间变换的不变性</strong>，例如平移和旋转，这些都不会影响最终的结果</p><p>PointNet的工作就是尝试解决这三个问题。</p><hr><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><img src="https://pic1.zhimg.com/80/v2-8dc76710bd09c25d5c8196d6aff56fec_1440w.jpg" alt></p><p>我们看一下 PointNet 的网络架构，首先喂入原始的 PointNet，是一个 $N\times 3$ 的矩阵(n个点,xyz)先通过一个 $T-Net$ 层进行对齐，然后用感知机 mlp 进行特征提取，装换到 $N\times 1024$ 1024维空间上再进行 Max Pooling 提取出 Global feature，然后就干自己该干的事去了，对分类任务，将全局特征通过mlp来预测最后的分类分数；对分割任务，将全局特征和之前学习到的各点云的局部特征进行串联，再通过mlp得到每个数据点的分类结果。<br>下文会展开更详细的讲解</p><h3 id="解决无序性-symmetry-function"><a href="#解决无序性-symmetry-function" class="headerlink" title="解决无序性 (symmetry function)"></a>解决无序性 (symmetry function)</h3><p>对于无序性 PointCloud 数据的处理当时一般有三种方法，</p><ul><li>1）对数据进行排序成 canonical order. </li></ul><p>对于这种方法，其实不存在一种高维空间的排序。由于CNN中数据抽象纬度很高，要保证高维中的点向一维的稳定映射无关数据顺序是十分困难的，所以其效果有限。</p><ul><li>2) 用大量打乱数据序列训练一个 RNN，寄希望于这种方式能消除顺序依赖</li></ul><p>这种方法看上去可行，然而其仍然无法做到完全顺序无关，在[2]中有详细证明。实验表示，这种方法对于小型数据具有一定鲁棒性，但对于大量point的场景仍然表现疲软。</p><p><strong>3) 通过一个简单的对称函数来处理每个点，获得每个点的 Global signature</strong></p><p>这是本文所使用的方法，很简单却很有效，我们知道一个symmetry function 的输出是无关顺序的, 例如我们熟悉的加法和乘法，这里选用了CNN中常用的 max 函数作为 symmetry function，通过 max pooling 消除数据顺序的影响。</p><p><img src="https://s3.ax1x.com/2020/12/08/rpks4e.png" alt></p><p>$f$ 这个函数输出一个数据不依赖的值作为该组数据的 <em>Global signature</em> 每一个输入值 $x_{1\to n}$ 是PointCloud中的点，带有 (x,y,z)位置信息以及一些rgb信息，组成共 $NxN$ 的矩阵，$h$ 是一个变换方程，将 $1\times N$的向量转换为 $1\times K$，然后 $g$ 就是我们的 symmetry function 将 $N\times K$ 的矩阵映射到一个值 $R$ 就能够代表这组数据，因为 symmetry function 的顺序无关性，我们能够保证这个值对于相同数据的不同排列是相同的。</p><hr><h3 id="局部和全局数据聚合-Local-and-Global-Information-Aggregation"><a href="#局部和全局数据聚合-Local-and-Global-Information-Aggregation" class="headerlink" title="局部和全局数据聚合 (Local and Global Information Aggregation)"></a>局部和全局数据聚合 (Local and Global Information Aggregation)</h3><p>这边先讲一下我自己的想法，我很怀疑它到底有没有做局部信息的处理，既解决第二个问题，据PointNet这篇文章自己写的这一章，他说他做了。然后后面PointNet++ 说他没做。我这段看的也比较迷惑，但我个人倾向于原作者尝试去做但做的比较弱。</p><h3 id="理论证明可行性-Theory-Analysis"><a href="#理论证明可行性-Theory-Analysis" class="headerlink" title="理论证明可行性 (Theory Analysis)"></a>理论证明可行性 (Theory Analysis)</h3><p><img src="https://pic3.zhimg.com/80/v2-1bee125c29ac11faba0e0a095207a396_1440w.jpg" alt="拟合可行性"></p><p>这个定理说我们通过之前讲的 $h$ 和 Max pooling 操作能够拟合任意的连续集合函数 $f$<br>最坏的拟合就是将其转换成空间中的体素，但通常来说我们的神经网络在调校的过程中都会得到更好的 $h$ 来完成这一过程。</p><p>TODO: 详细证明过程在附录中我还没看</p><p><img src="https://pic1.zhimg.com/80/v2-43d9f406855cf5e4681cb3de08382b80_1440w.jpg" alt="扰动下的鲁棒性"></p><p>定理二告诉了我们该模型在扰动之下具有鲁棒性，只要不影响关键点集 $C_S$，或者超出最密上限点集 $N_s$ 该模型所得出的 Global signature 都是相同的，(2) 指出关键点集的上限在于我们的转换函数 $h$ 转换的维数 $K$</p><p>对于定理二原论文中有直观的图解帮助大家构造 intuition<br><img src="https://pic2.zhimg.com/80/v2-c1fc6e865ab685dcaefd18e8c063bef1_1440w.jpg" alt></p><p>最后的结果在当时看来是非常不错的。<br><img src="https://s3.ax1x.com/2020/12/08/rpk2jI.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PointNet 开创了3D点云的新纪元，日后的PointNet++，PointCNN等网络都是在其基础上发展起来的，作为点云的奠基其用十分简单的方式解决了3D点云数据的顺序 (symmetry function) 和空间不变性 (high demension). 但它没有很好的解决 Local 数据的关系，这一问题会在PointNet++中得到解决。</p><p>最后说点自己的话，感觉现在读论文并不是很静得下心来，读的也很笼统不深入，被太多乱七八糟的事情困扰心烦意乱。但事情总得做下去，状态是在做事的过程中一点点找回来的，干等等不来。注重积累一点点来，相信自己在不久的将来能够做出一点自己的东西。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] PointNet论文链接：<a href="https://arxiv.org/abs/1612.00593">https://arxiv.org/abs/1612.00593</a><br>[2] O. Vinyals, S. Bengio, and M. Kudlur. Order matters: Sequence to sequence for sets. arXiv preprint arXiv:1511.06391, 2015.</p>]]></content>
    
    
    <categories>
      
      <category>Research</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PointNet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构笔记 (2020-11-30 ~ 2020-12-05)</title>
    <link href="/2020/12/05/DS/DataStructureNote1/"/>
    <url>/2020/12/05/DS/DataStructureNote1/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构-DataStructure"><a href="#数据结构-DataStructure" class="headerlink" title="数据结构 - DataStructure"></a>数据结构 - DataStructure</h1><p>数据结构这周依然是树上操作，课上学了AVL树，然后讲了之前用过的Hash，然后作业里面主要学会了LCA的倍增和不太熟练的欧拉序RMQ，最后学会了并查集的使用（就可以学最后的Tarjan LCA算法了) ，然后这周作业题主要是并查集，带有一道树上差分算法。</p><hr><h2 id="LCA-问题"><a href="#LCA-问题" class="headerlink" title="LCA 问题"></a>LCA 问题</h2><p>LCA (Least Common Ancestors) 最近公共祖先问题，顾名思义既要找到两个节点最近的公共祖先，朴素做法是，两个节点中深的那个节点向上跳，直到两个节点深度相同，两个节点再同时向上跳（询问父节点）如果他们跳到最后的父节点是同一个那么这个节点就是他们的最近公共祖先。</p><p>这种朴素的算法很好思考，但复杂度也是很高的，单次询问时间复杂度 O(n) 因为最坏要把所有节点都跳一遍。</p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1414039454,330983716&amp;fm=26&amp;gp=0.jpg" alt></p><h3 id="LCA-倍增算法"><a href="#LCA-倍增算法" class="headerlink" title="LCA - 倍增算法"></a><strong>LCA - 倍增算法</strong></h3><p>倍增算法是LCA的经典算法，如同二分算法的本质一样，都是通过每次尽量把问题规模缩减2的幂次，从而达到 O(lgn) 的时间复杂度。</p><p>我们简单讲解一下，倍增算法就是我不再像朴素算法一样一个个往上跳，我直接跳2的幂次，从大到小枚举，如果符合题意就跳，直到 2^0 跳一个节点，这样一次遍历下来，总能覆盖所有情况而满足题意跳到要跳的地方，但复杂度却大大降低减为 O(lgn)</p><ul><li>代码实现<pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span></span><span class="hljs-function"></span>&#123;    up[u][<span class="hljs-number">0</span>] = fa;  <span class="hljs-comment">// 预处理父亲</span>    dep[u] = dep[fa] + <span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v : tree[u])    &#123;        <span class="hljs-keyword">if</span>(v == fa)            <span class="hljs-keyword">continue</span>;        dfs(v, u);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; k) &lt;= n; ++k)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)            up[i][k] = up[up[i][k - <span class="hljs-number">1</span>]][k - <span class="hljs-number">1</span>];             <span class="hljs-comment">// 预处理所有的上跳</span>            <span class="hljs-comment">// 状态转移方程 跳 2^k 步，等于先跳2^k-1步再往上跳2^k-1步</span>            <span class="hljs-comment">// 2 ^ k = 2 ^ (k - 1) + 2 ^ (k - 1)</span>&#125;   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(dep[x] &lt; dep[y])        swap(x, y); <span class="hljs-comment">// 让深度大的为x</span>    <span class="hljs-keyword">if</span>(dep[x] != dep[y])    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">31</span>; k &gt;= <span class="hljs-number">0</span>; --k)        &#123;            <span class="hljs-keyword">if</span>(dep[up[x][k]] &gt;= dep[y])                x = up[x][k];   <span class="hljs-comment">// 调整为同一深度</span>        &#125;    &#125;    <span class="hljs-keyword">if</span>(x == y)        <span class="hljs-keyword">return</span> x;           <span class="hljs-comment">// 如果一个是另外一个的长辈那么这时候两个直接就相等了，直接返回</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">31</span>; k &gt;= <span class="hljs-number">0</span>; --k)    &#123;        <span class="hljs-keyword">if</span>(up[x][k] != up[y][k])    <span class="hljs-comment">// 同时上跳不过头</span>        &#123;            x = up[x][k];               y = up[y][k];        &#125;    &#125;    <span class="hljs-keyword">return</span> up[x][<span class="hljs-number">0</span>];    <span class="hljs-comment">// 最后 lca 就是里面任意一个的父亲</span>&#125;</code></pre></li></ul><hr><h3 id="LCA-欧拉序RMQ算法"><a href="#LCA-欧拉序RMQ算法" class="headerlink" title="LCA - 欧拉序RMQ算法"></a><strong>LCA - 欧拉序RMQ算法</strong></h3><p>这边涉及到RMQ问题，我们就先来讲一讲RMQ问题。</p><ul><li><em>RMQ 问题</em><br>RMQ 是英文 Range Maximum/Minimum Query 的缩写，表示区间最大（最小）值。</li></ul><p>RMQ问题一般可以使用单调栈、ST表、线段树来解决</p><p>通过欧拉序将LCA问题转为RMQ问题后，我们一般使用ST表来解决RMQ问题。因为ST表在时间复杂度上表现优秀，需要 O(nlgn)的预处理，就能做到O(1)的询问。而写起来又较为简单，不像线段树一样复杂。可以处理大部分不需要在线修改的 RMQ 问题。</p><p>另一方面如果我们使用单调栈和线段树在单次询问的时间复杂度仍然是 O(lgn) 级别的本没有做到比倍增算法更优，但在代码方面却比倍增算法更为复杂，因而我们选择ST表进行处理。</p><h3 id="ST表-Sparse-table"><a href="#ST表-Sparse-table" class="headerlink" title="ST表 - Sparse table"></a><strong>ST表 - Sparse table</strong></h3><p>我们说 ST 表可以用来解决可重复贡献问题，因为ST表涉及到区间重叠，我们要保证区间重叠不会影响到我们要求的问题。所以ST表只能解决可重复贡献问题，例如最值和gcd。</p><p>ST表运用的也是倍增的思想，通过倍增区间覆盖来解决问题。</p><pre><code class="hljs cpp"><span class="hljs-comment">// ST表</span><span class="hljs-keyword">int</span> f[Max][lgn], Logn[Max], a[Max];<span class="hljs-comment">// f[i][k] 表示区间 i ~ i + 2^k - 1 的最值</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Logn[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; Max; ++i)        Logn[i] = Logn[i / <span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">// 状态转移：</span>    <span class="hljs-comment">// 前者表示 i ~ i + 2^(k - 1) - 1 的区间最值</span>    <span class="hljs-comment">// 后者表示 i + 2^(k - 1) ~ i + 2^k - 1 的区间最值</span>    <span class="hljs-comment">// 合并即为 i ~ i + 2^k - 1的区间最值</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preSet</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)        f[i][<span class="hljs-number">0</span>] = a[i]; <span class="hljs-comment">// 显然 f[i][0] = a[i]</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; lgn; ++k)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>)) &lt;= n; ++i)            f[i][k] = max(f[i][k - <span class="hljs-number">1</span>], f[i + (<span class="hljs-number">1</span> &lt;&lt; (k - <span class="hljs-number">1</span>))][k - <span class="hljs-number">1</span>]);&#125;<span class="hljs-comment">// 查询操作：</span>    <span class="hljs-comment">// 如果我们要查询 区间 l ~ r 的最值, 我们根据ST表性质知道</span>    <span class="hljs-comment">// f[i][k] 表示 l ~ l + 2^k - 1 的区间最值</span>    <span class="hljs-comment">// r - 2^k + 1 ~ r 的区间最值就可以用 f[r - 1 &lt;&lt; k + 1][k] 表示</span>    <span class="hljs-comment">// 那么我们需要这两个区间覆盖整个查询区间且不超过</span>    <span class="hljs-comment">// 则 l + 2^k - 1 &gt;= r - 2^k + 1 且 l + 2^k - 1 &lt;= r 且 r - 2^k + 1 &gt;= l</span>    <span class="hljs-comment">// 则 k &gt;= lg(r - l + 2) - 1 且 k &lt;= floor(lg(r - l + 1));</span>    <span class="hljs-comment">// 我们直接取 k == floor(lg(r - l + 1))</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> k = Logn[r - l + <span class="hljs-number">1</span>];    <span class="hljs-keyword">return</span> max(f[i][k], f[r - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]); <span class="hljs-comment">// O(1) 查询</span>&#125;</code></pre><p>这样一个ST表就写好了，回到正题，我们是通过欧拉序把 LCA问题转换为RMQ问题，我们现在来看这是如何进行的。</p><p>在看欧拉序之前我们先看一看基本的 dfs 序是怎么做的（真就递归学习呗）</p><p><img src="https://img-blog.csdnimg.cn/20191008210415266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3djeHlreQ==,size_16,color_FFFFFF,t_70" alt="dfs序"></p><p>正常的dfs序是深度优先不记录回溯的，如上图 dfs 序就是<br><strong>A-&gt;B-&gt;D-&gt;E-&gt;G-&gt;C-&gt;F-&gt;H</strong><br>每个节点在dfs序中出现且仅出现一次</p><p>而我们再来看欧拉序</p><p><img src="https://img-blog.csdnimg.cn/20191008210445328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3djeHlreQ==,size_16,color_FFFFFF,t_70" alt="欧拉序"></p><p>它不同于dfs序将栈pop的元素也加入队列中，从而就形成了上图“逆时针”的模式<br>上图欧拉序就是<br><strong>A-&gt;B-&gt;D-&gt;B-&gt;E-&gt;G-&gt;E-&gt;B-&gt;A-&gt;C-&gt;F-&gt;H-&gt;F-&gt;C-&gt;A</strong><br>一种intuition就是欧拉序是一种正常人走路遍历所有节点的顺序，只要叶节点大于2个的树就不可能是欧拉图或半欧拉图，那么必然要走回头路，在dfs序的基础上将回头路线画出就是欧拉序。</p><p>我们来观察欧拉序可以发现，其首尾必然是根节点，然后除了叶节点仅出现一次，其余点出现2次以上(取决于是几叉树)，如果我们默认是二叉树，那么欧拉序的大小就不会超过 2n - 1 (考虑单链或就两叉到底的最坏情况)</p><p>如果我们在欧拉序节点旁配上它的深度再结合图来观察<br><strong>A(0)-&gt;B(1)-&gt;D(2)-&gt;B(1)-&gt;E(2)-&gt;G(3)-&gt;E(2)-&gt;B(1)-&gt;A(0)-&gt;C(1)-&gt;F(2)-&gt;H(3)-&gt;F(2)-&gt;C(1)-&gt;A(0)</strong><br>我们根据欧拉序的性质不难发现一个节点的左右子树必然夹在其在欧拉序中第二次出现的位置的左右两边，例如 B 的 左右子树 D, E 出现在B第二次出现位置[3]的两边[2]、[4]。<br>那么我们想如果我们找，两个节点的 LCA 就直接找两个节点第一次出现的位置，将其作为区间左右，在中间找深度最小的点就行了，这样找到的一定就是他们的LCA (不可能找到更浅的祖先) 。 当然其中包含了左边一个节点的子树，但为了方便我们就统一取第一次出现的位置即可。</p><p>这样我们就在线性的时间内将LCA问题转化成了RMQ问题，然后通过之前O(nlgn)的预处理我们可以做到 O(1)的询问，这样LCA问题的总复杂度就是ST表预处理的 O(nlogn) 的复杂度。</p><p>似乎总体没有比倍增更优，但单次询问比倍增快了很多，适合需要及时快速反馈的应用场景。</p><ul><li>代码实现</li></ul><pre><code class="hljs cpp"><span class="hljs-comment">// get eula array</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa, <span class="hljs-keyword">int</span> level)</span></span><span class="hljs-function"></span>&#123;    pos[u] = cnt_2;    find_u[cnt_2++] = u;    dep[u] = level;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; i != <span class="hljs-number">-1</span>; i = e[i].nex)    &#123;        <span class="hljs-keyword">int</span> v = e[i].v;                <span class="hljs-comment">// 欧拉序，回溯也放入</span>        pos[v] = cnt_2;        find_u[cnt_2++] = v;        dep[v] = level + <span class="hljs-number">1</span>;        dfs(v, u, level + <span class="hljs-number">1</span>);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ST</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">// Preset Log</span>    Logn[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)        Logn[i] = Logn[i &gt;&gt; <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)        f[i][<span class="hljs-number">0</span>] = find_u[i];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= logn; ++j)        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)            f[i][j] = dep[f[i][j - <span class="hljs-number">1</span>]] &lt; dep[f[i + (j &lt;&lt; <span class="hljs-number">1</span>)][j - <span class="hljs-number">1</span>]] ? f[i][j - <span class="hljs-number">1</span>] : f[i + (j &lt;&lt; <span class="hljs-number">1</span>)][j - <span class="hljs-number">1</span>];&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> l = pos[u], r = pos[v];    <span class="hljs-keyword">int</span> j = Logn[r - l + <span class="hljs-number">1</span>];    <span class="hljs-comment">// 直接找区间最小深度的节点</span>    <span class="hljs-keyword">int</span> ans = min(f[l][j], f[r - (<span class="hljs-number">1</span> &lt;&lt; j) + <span class="hljs-number">1</span>][j]);    <span class="hljs-keyword">return</span> pos[ans];    <span class="hljs-comment">// 返回节点位置...</span>&#125;</code></pre><hr><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>再来讲讲这周学的并查集</p><p>并查集顾名思义支持且仅支持两种操作</p><ol><li>合并两个集合</li><li>查询元素所在的集合</li></ol><p>并查集是一种树上的操作，通过根节点直接代表整棵树，初始化的时候根节点父节点为自身。</p><ul><li>合并操作</li></ul><p>合并操作相对比较简单，由于我们通过根节点来代表这个集合，那么合并两个集合只需要将其中一个的根节点作为另一个的子节点连接上即可。但同时我们要注意整棵树的深度会影响我们的时间复杂度，因而我们要尽可能不加深或是少加深树的深度，所以我们采用将深度较小的树连接到深度较大的树上，每次这样操作，树深度每次至多 +1，这种策略称之为<strong>按秩合并（启发式合并）</strong></p><p><img src="https://oi-wiki.org/ds/images/dsu1.png" alt></p><ul><li>代码</li></ul><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unionSet</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> tmp_x = find(x);    <span class="hljs-keyword">int</span> tmp_y = find(y);    <span class="hljs-keyword">if</span>(tmp_x == tmp_y)  <span class="hljs-comment">// 本来就在同一集合中</span>        <span class="hljs-keyword">return</span>;     <span class="hljs-keyword">if</span>(sz[tmp_x] &gt; sz[tmp_y])        swap(tmp_x, tmp_y); <span class="hljs-comment">// 让 tmp_x 是深度小的集合</span>    fa[tmp_x] = tmp_y; <span class="hljs-comment">// 将 tmp_x 连接到 tmp_y 上</span>&#125;</code></pre><ul><li>查询操作</li></ul><p>我们来讲并查集关键的查询操作，并查集的查询操作给出一个节点，我们查询其父节点，如若其父节点不是自身就继续向上查询，直到查询到根节点（父节点为自身）返回根节点作为这个集合的代表。</p><p>我们不难看出这样的查询操作单次是 $O(n)$ 的，原因是我们每次查询都要走完完整的一条链，但是其实我们并不关心该节点的父节点是谁，我们只想知道其根节点是什么。所以我们可以直接让它的父节点直接是根节点，这样虽然在第一次操作的时候，我们还是要走完一条链，但之后该节点的父节点直接就是根节点。这种操作称为<strong>路径压缩</strong></p><p><img src="https://oi-wiki.org/ds/images/dsu2.png" alt></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(fa[x] == x)        <span class="hljs-keyword">return</span> x;    <span class="hljs-keyword">return</span> fa[x] = find(fa[x]); <span class="hljs-comment">// 路径压缩</span>&#125;</code></pre><ul><li><strong>复杂度分析</strong></li></ul><p>我们现在来分析一下复杂度，朴素算法毫无疑问单次操作是 $O(mn)$ 的<br>如果我们使用了路径压缩，在Tarjan大神的论文[1] 中给出了复杂度的证明，只使用路径压缩不使用按秩合并的最坏时间复杂度是 $O(mlogn)$ 已经满足大部分题的需求，所以一般只需要路径压缩就能过题。<br>在姚期智的论文 [2] 中，证明了只路径压缩的平均复杂度为 $O(m\alpha{(m,n)})$<br><em>注： $\alpha$ 是阿克曼函数的反函数，其增长极其缓慢，也就是说其单次操作的平均运行时间可以认为是一个很小的常数。</em></p><p>如果我们同时使用了路径压缩和按秩合并，那么我们可以做到 $O(m\alpha{(m,n)})$ 的最坏时间复杂度。相当于单次询问是常数级别复杂度。</p><p>Ackermann 函数</p><script type="math/tex; mode=display">A(m,n) =\left\{\begin{array}{l}    n + 1, \; m = 0 \\    A(m - 1, 1), m > 0 \;and\; n = 0 \\    A(m - 1, A(m, n - 1)),\;othercases\end{array}\right.</script><p>$A(4, 3)$ 大的惊人，其反函数增长就相对应慢的惊人，直接可看为常数</p><hr><h2 id="树上差分算法"><a href="#树上差分算法" class="headerlink" title="树上差分算法"></a>树上差分算法</h2><p>讲一下这周作业题里涉及到的树上差分算法<br>树上差分问题可以用树链剖分解决，但我目前还不太会，就写一下现在会一点的树上差分。</p><p>树上差分分为两种，边差分和点差分。</p><ul><li>边差分<br>考虑一个经典问题，<strong>给出两点x, y 将其路径上的边权加1，最后给出所有边权。</strong></li></ul><p><img src="https://s3.ax1x.com/2020/12/08/r99w60.png" alt="图源:https://www.cnblogs.com/zhwer/p/12800475.html"></p><p>我们看这张图，数组 c[k] 是差分数组只不过我们是自下而上加的，为不影响其他子树的结果，我们的统计在回溯过程中完成，因而是自下而上的，那么这个边权修改过程就可以看做是 c[x]++, c[y]++, 然后 根节点到lca(x, y)被加了两次，我们都要减去 c[lca(x, y)] -= 2</p><p>既然是差分那么对于权值的更新，我们就可以如同前缀和一样计算，这不过这里的”前缀”是所有的子树权值，我们将所有子树权值收集起来到父节点上。</p><ul><li>代码实现</li></ul><pre><code class="hljs cpp"><span class="hljs-comment">// 已求出差分数组c</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getAns</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span></span><span class="hljs-function"></span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; i != <span class="hljs-number">-1</span>; i = e[i].nex)    &#123;        <span class="hljs-keyword">int</span> v = e[i].v;        <span class="hljs-keyword">if</span>(v != fa)        &#123;            getAns(v, u);            c[u] += c[v] <span class="hljs-comment">// 收集子树权值更新c为原本数组</span>            <span class="hljs-comment">// 更新后的c就代表其和其父节点连接边的边权</span>        &#125;    &#125;&#125;</code></pre><ul><li>点差分<br>点差分和边差分差不多，但这回每个点都代表的是自己了。<br><img src="https://s3.ax1x.com/2020/12/08/r990XV.png" alt="图源:https://www.cnblogs.com/zhwer/p/12800475.html"></li></ul><p>和边差分不同的是，这回lca不需要减2了，因为每个点代表的就是自己，在统计的时候 x, y 路径上是有 lca(x, y) 的，因而只需要减去一次重复计算即可。但这边lca在计算”前缀和”的时候会 +1，差分数组某一地方值的变动会影响到后面所有的值（这就是差分数组的精髓和意义所在）但lca的父亲并不应该 +1 所以我们要将 c[fa[lca(x,y)]]— 这个过程之后，我们的差分数组就完成了。<br>最后自下而上的收集一下，就能得到所有节点的权值了。</p><ul><li>思想总结</li></ul><p>差分的思想就是将原来本不相干的值联系到了一起，把后面点的部分信息移到了前面的点中，形成了区间的覆盖，这种效果正好能够用于解决区间修改问题，避免了暴力算法对每个点都进行操作，很巧妙的思想。</p><hr><h2 id="最后总结"><a href="#最后总结" class="headerlink" title="最后总结"></a>最后总结</h2><p>本周DS主要学习这些内容，AVL树很惭愧虽然上课讲了但还没有深入去看，线段树和树链剖分还不太会，树状数组也快忘记了。最近又重新听到了《蜗牛》这首歌，隔了这么多年，再听还是很感动。“历经的伤都不感觉疼”，“任风吹干流过的泪和汗，总有一天我有属于我的天。”<br>每周都在不断吸收新知识，很充实也很疲倦，每天都学到12点之后。就是希望能够在未来有一片自己的天。科研也在不断做，但进度很慢，时间分配越来越不够了，最近越来越感到拔尖班的藏龙卧虎，个个都是人才，让我感到了很大的压力。但就像《蜗牛》中说的即使我很慢，拖着重重的壳，只要我每天一步一步的向上爬，我总能触碰到那片属于我的蓝天。</p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]Tarjan, R. E., &amp; Van Leeuwen, J. (1984). Worst-case analysis of set union algorithms.<br>[2]Yao, A. C. (1985). On the expected performance of path compression algorithms. SIAM Journal on Computing, 14(1), 129-133.</p>]]></content>
    
    
    <categories>
      
      <category>DataStructure</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LCA</tag>
      
      <tag>UFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近期进展 (2020-11-15 ~ 2020-11-27)</title>
    <link href="/2020/11/27/Recent-Progress%20(2020-11-15%20~%202020-11-27)/"/>
    <url>/2020/11/27/Recent-Progress%20(2020-11-15%20~%202020-11-27)/</url>
    
    <content type="html"><![CDATA[<h1 id="最近进展"><a href="#最近进展" class="headerlink" title="最近进展"></a>最近进展</h1><p>近来比较忙，一直没时间写博客，就暂将这段时间的进展写作一个综述发在博客上</p><hr><h2 id="学业方面"><a href="#学业方面" class="headerlink" title="学业方面"></a><strong>学业方面</strong></h2><h3 id="数据结构-DataStructure"><a href="#数据结构-DataStructure" class="headerlink" title="数据结构 - DataStructure"></a>数据结构 - DataStructure</h3><p>数据结构这几周以来都是学的树相关的操作, 对树的相关操作进行了学习和进一步的探究</p><h4 id="已经掌握"><a href="#已经掌握" class="headerlink" title="已经掌握"></a>已经掌握</h4><h5 id="树的储存"><a href="#树的储存" class="headerlink" title="树的储存"></a>树的储存</h5><ol><li><p>邻接表形式</p><pre><code class="hljs cpp"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; Tree[Max]</code></pre></li><li><p>链式前向星形式</p><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">edge</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> v;    <span class="hljs-keyword">int</span> w;    <span class="hljs-keyword">int</span> nex;&#125;;edge e[Max];<span class="hljs-keyword">int</span> head[Max], cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// init -1</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span></span><span class="hljs-function"></span>&#123;    e[cnt].v = v;    e[cnt].w = w;    e[cnt].nex = head[u];    head[u] = cnt++;&#125;<span class="hljs-comment">//遍历方式</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; i != <span class="hljs-number">-1</span>; i = e[i].nex)</code></pre><blockquote><p>邻接表相比链式前向星更为动态，但有些阴间题会卡掉邻接表</p></blockquote></li></ol><hr><h5 id="深度优先搜索-dfs"><a href="#深度优先搜索-dfs" class="headerlink" title="深度优先搜索 (dfs)"></a>深度优先搜索 (dfs)</h5><p>基本原则是一种与广度优先搜索对立的，能搜到子节点就往子节点走的搜索方式，既“深度”优先，我们熟知的二叉树的前序和后序遍历都是深度优先搜索的一种。</p><ol><li><p>代码实现 (邻接表形式)</p> <pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v : tree[u])    &#123;        <span class="hljs-keyword">if</span>(v == fa)            <span class="hljs-keyword">continue</span>;        dfs(v, u)    &#125;&#125;</code></pre><p> 其中 dfs(v,u) 是 dfs 的精华， 指代如若没搜到叶节点那么则继续向深度搜索，这时候当前节点的子节点作为下一个节点，而当前节点成为其子节点的父节点，因而有从 dfs(u, fa) 到 dfs(v, u) 的向深度搜索</p></li><li><p>前序遍历 - PreOrder (先出根再出子节点)</p> <pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode* root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(!root)        <span class="hljs-keyword">return</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, root-&gt;val);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> child : root-&gt;children)        preOrder(root-&gt;child)    <span class="hljs-comment">//递归子树</span>&#125;</code></pre></li><li><p>后序遍历 - PosOrder (先出子节点再出根)</p> <pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">posOrder</span><span class="hljs-params">(TreeNode* root)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(!root)        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> child : root-&gt;children)        preOrder(root-&gt;child)    <span class="hljs-comment">//递归子树</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, root-&gt;val);&#125;</code></pre><p>通过两次 dfs 我们可以求树的直径，一次 dfs 到直径的端点，再一次求出直径长度。</p></li></ol><p>dfs 所使用的数据结构是栈，这种数据结构隐含在函数的递归调用中，而对于 bfs 所使用的数据结构是队列，我们就需要</p><hr><h5 id="广-宽-度优先搜索-bfs"><a href="#广-宽-度优先搜索-bfs" class="headerlink" title="广(宽)度优先搜索 (bfs)"></a>广(宽)度优先搜索 (bfs)</h5><p>bfs 不同于 dfs 是深度优先的搜索，bfs是将同层的节点全部搜索过后再进入到下一次，既注重 “广度” 的搜索模式</p><ol><li><p>代码实现 (邻接表形式)</p><pre><code class="hljs cpp">bfs(s) &#123;    q = <span class="hljs-keyword">new</span> <span class="hljs-built_in">queue</span>();    q.push(s), visited[s] = <span class="hljs-literal">true</span>;    <span class="hljs-keyword">while</span> (!q.empty())     &#123;        u = q.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v : tree[u])        &#123;            <span class="hljs-keyword">if</span> (!visited[v])             &#123;                q.push(v);                visited[v] = <span class="hljs-literal">true</span>;            &#125;        &#125;    &#125;&#125;</code></pre></li><li><p>层序遍历<br> 层序遍历就是一种典型的 bfs，先将同层的打印出来之后再深入一层，代码同上。当然也可以通过 dfs 实现层序这时候就要区分节点的层数</p></li></ol><pre><code class="hljs cpp"><span class="hljs-comment">//dfs版本层序</span><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &gt; ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa, <span class="hljs-keyword">int</span> level)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(level &gt; ans.size())        ans.emplace_back(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;())    ans[level - <span class="hljs-number">1</span>].emplace_back(u);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v : tree[u])    &#123;        <span class="hljs-keyword">if</span>(v == fa)            <span class="hljs-keyword">continue</span>;        dfs(v, u, level + <span class="hljs-number">1</span>)    &#125;&#125;</code></pre><hr><h5 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h5><p>树形dp，顾名思义是在树上进行的dp，在dfs或bfs的过程中进行动态更新。例如通过树形dp求树的直径</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> fa)</span></span><span class="hljs-function"></span>&#123;    vis[x] = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> d1 = <span class="hljs-number">0</span>, d2 = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> tmp = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; v : tree[u])    &#123;        <span class="hljs-keyword">if</span>(v == fa)            <span class="hljs-keyword">continue</span>;        tmp = dfs(v, u) + <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(tmp &gt; d1)        &#123;            d2 = d1;            d1 = tmp;        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tmp &gt; d2)            d2 = tmp;        d = max(d, d1 + d2);    &#125;    <span class="hljs-keyword">return</span> max;&#125;</code></pre><hr><h4 id="尚未熟练-TODO"><a href="#尚未熟练-TODO" class="headerlink" title="尚未熟练 - TODO"></a><strong>尚未熟练 - TODO</strong></h4><ol><li>LCA问题</li><li>树状数组</li><li>线段树</li><li>树链剖分</li></ol><hr><h3 id="计算机系统-ICS"><a href="#计算机系统-ICS" class="headerlink" title="计算机系统 - ICS"></a>计算机系统 - ICS</h3><p>最近布置了 y86-64 的 PJ，学习了 CPU 的顺序以及流水线设计模式，开始做PJ。</p><h4 id="PJ进展"><a href="#PJ进展" class="headerlink" title="PJ进展:"></a>PJ进展:</h4><h5 id="设计模式-C-with-Class"><a href="#设计模式-C-with-Class" class="headerlink" title="设计模式 - C with Class"></a>设计模式 - C with Class</h5><p>在面向过程的 Fetch -&gt; Decode -&gt; Execute -&gt; Memory -&gt; WriteBack 基础上套instr的类壳</p><h5 id="后端进度"><a href="#后端进度" class="headerlink" title="后端进度"></a>后端进度</h5><ol><li>完成了Prototype设计<ul><li>目前 CC 的 OF 有一点 BUG</li></ul></li><li>完成了 UniTest 的 Generater<ul><li>准备用宏改为 gtest 移植到cpp上</li></ul></li></ol><ul><li>TODO:<ol><li>完成 python 到 cpp 的移植</li><li>尝试添加寄存器</li><li>实现硬件栈</li></ol></li></ul><h5 id="前端进度"><a href="#前端进度" class="headerlink" title="前端进度"></a>前端进度</h5><p>TODO中，思考如何设计</p><ul><li>可选方案:<ol><li>Python 作为中间件用 jinja 模板替换</li><li>C++ 作为后端 js 前端接口（学习中）</li><li>CGI</li></ol></li></ul><hr><h2 id="科研进度-CNN"><a href="#科研进度-CNN" class="headerlink" title="科研进度 - CNN"></a>科研进度 - CNN</h2><h3 id="目前方向"><a href="#目前方向" class="headerlink" title="目前方向"></a>目前方向</h3><p>3D Instance Segmentation</p><h3 id="论文收集"><a href="#论文收集" class="headerlink" title="论文收集"></a>论文收集</h3><ol><li>(RDCNet)mini ResNet in 2d Instance Seg</li><li>Attention Based 3d instance segmentation</li><li>Learning Gaussian Instance Segmentation in Point Clouds</li><li>3D Sementic &amp; Instance Segmentation via Salient Point Clustering Optimization</li></ol><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ol><li>实现 ResNet Backbone</li><li>复现 Fast R-CNN &amp; Mask R-CNN</li></ol>]]></content>
    
    
    <categories>
      
      <category>Summary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Summary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS-Lab4.2 各种链接姿势</title>
    <link href="/2020/11/15/ICS/ICS_Lab3/"/>
    <url>/2020/11/15/ICS/ICS_Lab3/</url>
    
    <content type="html"><![CDATA[<h3 id="Task0-简单链接"><a href="#Task0-简单链接" class="headerlink" title="Task0 - 简单链接"></a>Task0 - 简单链接</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;some.h&quot;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    testPrint();    testPrint(<span class="hljs-number">5</span>);    notATest();    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li><strong>错误分析</strong></li></ul><blockquote><p>我们可以看到main函数中调用了三个函数，全是外部的，在链接时，符号表会进行搜索匹配。我们再来看some.h中定义了哪些函数.</p></blockquote><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testPrint</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testPrint</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>;</code></pre><blockquote><p>发现只有两个test函数,而没有notATest定义的函数，根据这个离谱的名字我们可以断定在cstdio中也没有同名函数。<br>所以最后符号表中没有匹配上，会引发链接错误。</p></blockquote><ul><li><strong>解决方法</strong></li></ul><blockquote><p>直接将 notATest() 注释掉, 再在 makefile 中使用<br><pre><code class="hljs css"><span class="hljs-selector-tag">g</span>++ <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.cpp</span> <span class="hljs-selector-tag">some</span><span class="hljs-selector-class">.cpp</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">main</span></code></pre></p></blockquote><hr><h3 id="Task1-链接与重复包含问题"><a href="#Task1-链接与重复包含问题" class="headerlink" title="Task1 - 链接与重复包含问题"></a>Task1 - 链接与重复包含问题</h3><ul><li><strong>解题过程</strong></li></ul><p>通过阅读代码，我们可以发现改题的代码会根据宏DEBUG是否被定义而有不同的行为，决定是否打印更加详细的内容</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;function0.h&quot;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func0</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-meta"># <span class="hljs-meta-keyword">ifdef</span> DEBUG</span>    printDebug(); <span class="hljs-comment">//打印debug信息 (详细操作在shared.cpp中)</span>    <span class="hljs-meta"># <span class="hljs-meta-keyword">else</span></span>    print(); <span class="hljs-comment">//打印正常信息</span>    <span class="hljs-meta"># <span class="hljs-meta-keyword">endif</span></span>&#125;</code></pre><blockquote><p>根据题意，我们需要在 Makefile 中,对于要求的 main1 需要做一个相等的条件判断</p></blockquote><pre><code class="hljs makefile"><span class="hljs-section">main0:</span>    g++ main0.cpp function0.cpp function1.cpp shared.cpp -o main0debug = False<span class="hljs-section">main1:</span><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(debug)</span>,True) g++ main1.cpp -DDEBUG function0.cpp function1.cpp shared.cpp -o main1<span class="hljs-keyword">else</span>g++ main1.cpp function0.cpp function1.cpp shared.cpp -o main1<span class="hljs-keyword">endif</span></code></pre><p><em>值得注意的是，makefile中 if 语句前不能有 tab 或者空格</em></p><p><strong>Include 路径</strong><br><img src="https://s3.ax1x.com/2020/11/15/DFeVyt.png" alt></p><ul><li><strong>问题</strong></li></ul><ol><li>为什么两个function.h都引⽤了shared.h⽽没有出问题？本来有可能出什么问题。</li></ol><blockquote><p>因为 shared.h 中仅包含函数声明，而不包含函数的定义，因而不会有重定义问题。如果 #include shared.cpp 则会出现重定义问题。</p></blockquote><ol><li>如果把shared.h中注释掉的变量定义取消注释会出什么问题？为什么？</li></ol><blockquote><p>会出现变量重定义问题，由于全局变量 string 被两次 include 到func0 和 func1 中，最后被同时引用至 main 中，导致重定义。在符号表中产生冲突，报错。</p></blockquote><ol><li>通常使⽤shared.h中另外被注释掉的宏命令(#开头的那些⾏)来规避重复引⽤的⻛险，原理是什么？取消这些注释之后上⼀题的问题解除了吗？背后的原因是什么？</li></ol><blockquote><p>通过宏定义，在第一次 include 的时候定义宏为函数名，之后再次include 的时候由于已经 define 就不再次 include。这种方式的缺点是如果有已有宏名与函数名重复时，将会报错。使用 #pragama once 则是由c++编译器保证 include 一次，不会有宏名重复问题。</p><p>上题的问题并没有解决，因为FOO是全局变量，其赋了初值，被链接器标记为strong，被重复 include 到了 main 中，两个 strong 标记冲突报错。</p></blockquote><hr><h3 id="Task2-静态链接库"><a href="#Task2-静态链接库" class="headerlink" title="Task2 - 静态链接库"></a>Task2 - 静态链接库</h3><p>在这个 Task 中我们需要编译2个静态链接库，并链接3个静态链接库，完成编译。</p><p><strong>A Makefile</strong><br><pre><code class="hljs makefile"><span class="hljs-section">libA:</span>g++ -c A.cpp ar -r libA.a A.o</code></pre></p><blockquote><p>先用g++ -c编译出A.o可重定位目标文件，再通过 ar 命令编译静态链接库。（libC 同理）</p></blockquote><p><strong>Main Makefile</strong><br><pre><code class="hljs makefile">main : cd A &amp;&amp; make libAcd C &amp;&amp; make libCg++ main.cpp B/libB.a A/libA.a C/libC.a -o main</code></pre></p><blockquote><p>再 CD 入每个目录进行 make 编译， 最后把静态链接库进行链接。 </p></blockquote><ul><li><strong>静态库链接搜索路径顺序：</strong></li></ul><ol><li>ld会去找GCC命令中的参数-L</li><li>再找gcc的环境变量LIBRARY_PATH</li><li>再找内定目录 /lib /usr/lib /usr/local/lib </li></ol><ul><li><strong>问题</strong></li></ul><ol><li><p>若有多个静态链接库需要链接，写命令时需要考虑静态链接库和源⽂件在命令中的顺序吗？是否需要考虑是由什么决定的？</p><blockquote><p><strong>需要考虑</strong>，链接器在链接过程中按命令中输入的顺序进行符号表匹配，可以将这个匹配过程抽象的看作链接器在维护三个集合 E(待合并文件), U(被引用且尚未匹配), D（已匹配），根据顺序动态更新E, 和U,D, 最后如果 U 为空则正常整合 E 生成可执行文件，不然则报错有符号被引用了但未能匹配。所以如果我们的静态库都是相互独立的，那么顺序是没关系的。但如果互相依赖，那么我们必须保证在对某个符号的引用的库后，必然有一个库中存在对其的定义，不然则会报错。</p></blockquote></li><li><p>可以使⽤size main命令来查看可执⾏⽂件所占的空间，输出结果的每⼀项是什么意思？</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">text</th><th style="text-align:center">data</th><th style="text-align:center">bss</th><th style="text-align:center">dec</th><th style="text-align:center">hex</th><th style="text-align:center">filename</th></tr></thead><tbody><tr><td style="text-align:center">22721</td><td style="text-align:center">712</td><td style="text-align:center">288</td><td style="text-align:center">23721</td><td style="text-align:center">5ca9</td><td style="text-align:center">main</td></tr></tbody></table></div><ul><li><strong>text:</strong> 机器代码字节</li><li><strong>data:</strong> 包含静态变量和已经初始化的全局变量的数据段字节数大小</li><li><strong>bss:</strong> Block Started by Symbol (better save space) 存放程序中未初始化的全局变量的字节数大小，BBS段属于静态内存分配, 不占真实内存空间（仅占位符）</li><li><strong>dec:</strong> = test + data + bss</li><li><strong>hex:</strong> 16进制的dec</li><li><strong>filename:</strong> 顾名思义，文件名</li></ul><hr><h3 id="Task3-动态链接库"><a href="#Task3-动态链接库" class="headerlink" title="Task3 - 动态链接库"></a>Task3 - 动态链接库</h3><p>整体操作和上一个Task很像，只是链接的是动态链接库 .so</p><p><strong>A Makefile</strong><br><pre><code class="hljs makefile"><span class="hljs-section">libA:</span>g++ -fPIC -c A.cppg++ -shared -fPIC A.o -o libA.so</code></pre></p><blockquote><p>在 A 中先编译出 A.o 再用 -shared 编译出动态链接库 .so</p></blockquote><p><strong>Main Makefile</strong><br><pre><code class="hljs makefile">main : cd A &amp;&amp; make libAcd C &amp;&amp; make libCg++ main.cpp A/libA.so ./libB.so C/libC.so -o main</code></pre></p><blockquote><p>直接 cd 进去 make 出动态链接库后，再进行链接。</p></blockquote><ul><li><strong>问题</strong></li></ul><ol><li><p>动态链接库在运⾏时也需要查找库的位置，在Linux中，运⾏时动态链接库的查找顺序是怎样的？</p><blockquote><p><strong>动态链接时、执行时搜索路径顺序:</strong></p><ol><li>编译目标代码时指定的动态库搜索路径</li><li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</li><li>配置文件/etc/ld.so.conf中指定的动态库搜索路径</li><li>默认的动态库搜索路径/lib</li><li>默认的动态库搜索路径/usr/lib</li></ol></blockquote></li><li><p>使⽤size main查看编译出的可执⾏⽂件占据的空间，与使⽤静态链接库相⽐占⽤空间有何变化？哪些部分的哪些代码（也要具体到本task）会导致编译出⽂件的占⽤空间发⽣这种变化？</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">text</th><th style="text-align:center">data</th><th style="text-align:center">bss</th><th style="text-align:center">dec</th><th style="text-align:center">hex</th><th style="text-align:center">filename</th></tr></thead><tbody><tr><td style="text-align:center">3089</td><td style="text-align:center">720</td><td style="text-align:center">96</td><td style="text-align:center">3905</td><td style="text-align:center">f41</td><td style="text-align:center">main</td></tr></tbody></table></div><blockquote><p><strong>占用空间变小了</strong>，因为不同于静态链接库将所有的静态库都整合入可执行文件中，动态链接库是在程序开始或正在运行时被链接加载的，所有可执行文件本身的空间占用会大幅缩小。</p><p>main 中调用了 A, B, C 函数，所以其中的函数以及静态全局变量 A_name, B_name 会被被置于动态链接库.so中动态加载</p></blockquote><ol><li>编译动态链接库时-fPIC的作⽤是什么，不加会有什么后果？<br>-fPIC 含义是 Generate position-independent code (PIC)，例如在汇编的 jmp 语句中通常使用的是固定的内部地址<pre><code class="hljs angelscript"><span class="hljs-number">100</span>: COMPARE REG1, REG2<span class="hljs-number">101</span>: JUMP_IF_EQUAL <span class="hljs-number">111</span>...<span class="hljs-number">111</span>: NOP</code></pre><blockquote><p>而通过 -fPIC 参数 jmp 语句所指向的是相对地址<br>使用的是代码段和数据段的OFFSET，从而实现位置无关，可以动态加载到内存中，不同进程可以共享。</p></blockquote></li></ol><pre><code class="hljs angelscript"><span class="hljs-number">100</span>: COMPARE REG1, REG2<span class="hljs-number">101</span>: JUMP_IF_EQUAL CURRENT+<span class="hljs-number">10</span>...<span class="hljs-number">111</span>: NOP</code></pre><blockquote><p>如果不加，在某些系统下不会有很大的问题，但一般在 -shared 后面最好加上 -fPIC 来保证动态链接库是位置无关的，不然无法实现动态链接（由于位置相关即分配绝对内存地址，导致多个副本存在于内存中，无法实现动态链接）</p></blockquote><p><strong>info in gcc manual</strong></p><ul><li><strong>-shared:</strong>  Produce a shared object which can then be linked with other objects to forman executable. Not all systems support this option. For predictable results,<br>you must also specify the same set of options used for compilation (‘-fpic’,‘-fPIC’, or model suboptions) when you specify this linker option.*</li></ul><ol><li>现在被⼴泛使⽤的公开的动态链接库如何进⾏版本替换或共存（以linux系统为例）？</li></ol><blockquote><p>通过动态链接，如果开发者需要维护程序的某一部分（某几个功能的函数），仅需要维护修改所在的动态链接库即可，然后将其发布。用户只需要替换动态链接库，在程序运行的时候自然会动态链接到新的链接库，<strong>在接口保持不变</strong>的情况下完成很自然流畅的版本更新。</p></blockquote><hr><h3 id="Task4-ld手动链接"><a href="#Task4-ld手动链接" class="headerlink" title="Task4 - ld手动链接"></a>Task4 - ld手动链接</h3><ul><li><strong>解题过程</strong><br>这题要求我们用ld链接器，进行手动链接，我们先试一下直接链接会发生什么</li></ul><pre><code class="hljs makefile"><span class="hljs-comment">#链接代码</span>ld -o main main.o some.o</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">//报错信息</span>ld: warning: cannot find entry symbol _start; defaulting to <span class="hljs-number">00000000004000b</span>0some.o: In function `notATest()<span class="hljs-string">&#x27;:</span>some.cpp:(.text+0xc): undefined reference to `puts&#x27;some.o: In function `testPrint()<span class="hljs-string">&#x27;:</span>some.cpp:(.text+0x1f): undefined reference to `puts&#x27;some.o: In function `testPrint(<span class="hljs-keyword">int</span>)<span class="hljs-string">&#x27;:</span>some.cpp:(.text+0x52): undefined reference to `printf&#x27;Makefile:2: recipe for target &#x27;main&#x27; failedmake: *** [main] Error <span class="hljs-number">1</span></code></pre><blockquote><p>发现主要报错信息是 undefined reference to ‘puts’, ‘printf’, 说明标准库中的函数符号没有被成功匹配，我们需要把 stdc 加进去</p></blockquote><pre><code class="hljs makefile"><span class="hljs-comment"># 链接代码</span>ld -o main main.o some.o -lc<span class="hljs-comment"># 通过 -lc 命令直接添加标准库，也可以自行指定libc.so路径</span></code></pre><blockquote><p>可以发现main被成功编译出来，但运行时候发现bash报目录中无此文件<br><pre><code class="hljs bash">bash: ./main: No such file or directory</code></pre></p><p>也就是我们并不能运行这个可执行文件，查找资料之后我们尝试指定使用的动态链接器再进行编译，就可以运行了</p></blockquote><pre><code class="hljs makefile">ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o main main.o some.o -lc</code></pre><blockquote><p>我查询了ld的手册试图查找原因，但并未发现为什么必须要使用—dynamic-linker指令</p></blockquote><div style="page-break-after: always;"></div><ul><li><strong>—dynamic-linker=file</strong><blockquote><p>   Set the name of the dynamic linker.  This is only meaningful when generating dynamically linked ELF executables.  <strong>The default dynamic linker is normally correct; don’t use this unless you know what you are doing.</strong></p></blockquote></li></ul><blockquote><p>接下去，我们的程序虽然能够运行起来了，但在 main 函数跑完之后会出现 <em>Segmentation fault (core dumped)</em> 提示，这也提示了我们对于 main 函数的初始化和结束可能并未正常执行。</p></blockquote><ul><li><strong>GDB查看正常程序</strong></li></ul><p><img src="https://s3.ax1x.com/2020/11/15/DFeZOP.png" alt></p><blockquote><p>通过 gdb 查看正常程序我们发现，正常的 main 函数执行栈中需要有两个函数为其保证环境 <em>__lib_csu_init</em> 和 <em>__libc_start_main</em></p></blockquote><ul><li><strong>__libc_start_main</strong><br>我们需要知道，在linux中，main函数的初始化环境和参数传递以及返回值处理工作是由 __libc_start_main 来保证的。一个正常的程序执行需要包含以下要素。</li></ul><ol><li>performing any necessary security checks if the effective user ID is not the same as the real user ID.</li><li>initialize the threading subsystem.</li><li>registering the <em>rtld_fini</em> to release resources when this dynamic shared object exits (or is unloaded).</li><li>registering the <em>fini</em> handler to run at program exit.</li><li>calling the initializer function <em>(</em>init)()*.</li><li>calling <em>main()</em> with appropriate arguments.</li><li>calling <em>exit()</em> with the return value from <em>main()</em>.</li></ol><blockquote><p>具体的初始化和结束调用路径异常复杂，在此不多赘述，放一张图有待进一步研究。</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/15/DFemef.png" alt></p><p><em>图片来源: <a href="https://luomuxiaoxiao.com/?p=516">https://luomuxiaoxiao.com/?p=516</a></em></p><hr><p>然后介绍完了主函数的初始化和返回，我们需要知道保证上述的两个函数在哪个动态链接库中，这就涉及到了 <em>crt1.o, crti.o, crtbegin.o, crtend.o, crtn.o</em> 这几个库<br><em>参考： <a href="https://blog.csdn.net/farmwang/article/details/73195951">https://blog.csdn.net/farmwang/article/details/73195951</a></em></p><blockquote><p><strong>crt是c runtime 的缩写</strong>,用于执行进入main之前的初始化和退出main之后的扫尾工作。</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">目标文件</th><th style="text-align:center">crt1.o</th><th style="text-align:center">crti.o</th><th style="text-align:center">crtbegin.o</th><th style="text-align:center">crtend.o</th><th style="text-align:center">crtn.o</th></tr></thead><tbody><tr><td style="text-align:center">作用</td><td style="text-align:center">启动</td><td style="text-align:center">初始化</td><td style="text-align:center">构造</td><td style="text-align:center">析构</td><td style="text-align:center">结束</td></tr></tbody></table></div><blockquote><p>在标准的linux平台下,link的顺序是</p></blockquote><pre><code>ld crt1.o crti.o [user_objects] [system_libraries] crtn.o</code></pre><p>所以我们按照顺序进行链接有如下命令</p><pre><code class="hljs makefile"><span class="hljs-comment"># 链接指令</span>ld -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o main /usr/lib/x86_64-linux-gnu/crt1.o main.o some.o -lc /usr/lib/x86_64-linux-gnu/crti.o /usr/lib/x86_64-linux-gnu/crtn.o</code></pre><blockquote><p>成功的手动完成了程序的链接工作。</p></blockquote><p>以上艰苦的工作告诉我们，不要轻易尝试手动链接，除非你知道你在干什么。平时好好用 gcc。</p><ul><li>动态链接器⼀个操作系统中只需要⼀个吗？为什么？<blockquote><p>一般来说只要有一个支持的动态链接器即可，完成程序的动态链接工作。 但linux中可能有两个 ld 的版本</p></blockquote></li></ul><ol><li>ld.so针对a.out格式的二进制可执行文件</li><li>ld-linux.so针对ELF格式的二进制可执行文件</li></ol><p>a.out是旧版类Unix系统中用于执行档、目的码和后来系统中的函数库的一种文件格式，该版本的链接器仍被保留用以向前支持。</p><hr><h3 id="Task5-运行时打桩"><a href="#Task5-运行时打桩" class="headerlink" title="Task5 - 运行时打桩"></a>Task5 - 运行时打桩</h3><p>Task5 是一个典型的运行时打桩的 task，给了我们编译好的login程序，让我们改变其行为，让它能够输出 login_success.</p><blockquote><p>阅读源码，我们可以发现，login将我们输入的字符串做了hash，与已有某不明hash值，进行比较，如果相等则登陆成功。根据本 lab 的内容主要是讲 make 和链接的，让我们碰撞这个hash显然不是本意。那另一种方法就是通过运行时打桩，改变标准库的链接方式，让strcmp 链接到我们自己写的 strcmp 版本上去，从而我们可以控制其返回值让其返回0使得登陆成功。</p></blockquote><p><em>首先要注意 strcmp 并非只有判断密码时的一次唯一调用，在别处还有调用，所以我们要保证 strcmp 函数的基本功能正确</em><br><pre><code class="hljs cpp"><span class="hljs-comment">// mystrcmp.c</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _GNU_SOURCE</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;dlfcn.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strcmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *lhs, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *rhs)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span>(*strcmpp)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *lhs, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *rhs);    strcmpp = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;strcmp&quot;</span>);    <span class="hljs-keyword">char</span> tmp[] = <span class="hljs-string">&quot;3983709877683599140&quot;</span>;    <span class="hljs-keyword">if</span>(strcmpp(tmp, rhs) == <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">return</span> strcmpp(lhs, rhs);&#125;</code></pre></p><blockquote><p>我们直接写一个自己的 strcmp 版本，用 dlsym 可以获取在运行时 strcmp 函数的指针 <em>（不这样做也可以，可以直接自己重写一遍strcmp程序）</em>，相当于可以直接使用 <strong>真实的标准库中的 strcmp</strong>，然后我们稍微改写一下，让它和我们的hash值比较的时候直接返回0，能够让我们不管输入什么密码都能够 login_success。</p></blockquote><p>接下来我们先将我们写的strcmp编译成动态链接库</p><pre><code class="hljs shell">gcc -shared -fpic -o mystrcmp.so mystrcmp.c -ldl</code></pre><blockquote><p>然后使用 <strong>LD_PRELOAD=”./mystrcmp.so”</strong> 指令，从而在 strcmp 动态链接到标准库之前让其优先匹配我们写的动态链接库中的 strcmp 符号。</p></blockquote><p>这里需要注意由于是要直接运行 ./login, 所以我们需要把LD_PRELOAD的效果全局化，也既在前面加上 export 标记。</p><pre><code class="hljs shell">export LD_PRELOAD=&quot;./mystrcmp.so&quot;</code></pre><p>最后注意不要忘记卸载全局 preload， 不然之后所有程序都 preload 这个strcmp。</p><pre><code class="hljs shell">export LD_PRELOAD=NULL</code></pre>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Training Neural Networks II 06</title>
    <link href="/2020/11/13/CS231n/CS231n-06-Training-Neural-Networks-II/"/>
    <url>/2020/11/13/CS231n/CS231n-06-Training-Neural-Networks-II/</url>
    
    <content type="html"><![CDATA[<h3 id="PreView"><a href="#PreView" class="headerlink" title="PreView"></a>PreView</h3><ul><li>Fancier optimization</li><li>Regularization</li><li>Transfer Learning</li></ul><hr><h3 id="Problem-with-SGD"><a href="#Problem-with-SGD" class="headerlink" title="Problem with SGD"></a>Problem with SGD</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9JOns.png" alt></p><blockquote><p>The zig-zag path reveal the drawbacks of SGD</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9JbcQ.png" alt></p><blockquote><p>Stuck in the local minima.</p></blockquote><ul><li>Saddle points much more common in high dimension.</li></ul><p><strong>Add an Momentum term may solve these problems</strong></p><p><img src="https://s3.ax1x.com/2020/11/13/D9JqXj.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9JXBn.png" alt></p><blockquote><p>Owing to the exsistance of momentum we can training more faster and overcome the problems mentioned before.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9JH1g.png" alt></p><ul><li><strong>Nesterov Momentum</strong></li></ul><script type="math/tex; mode=display">v_{t+1} = \rho{v_t}-\alpha{\nabla{f(x_t+\rho{v_t})}}\\x_{t+1} = x_t + v_{t+1}</script><p><img src="https://s3.ax1x.com/2020/11/13/D9Jj7q.png" alt></p><blockquote><p>some kind error correcting term of present v and the previous v</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9JzNV.png" alt></p><hr><h3 id="AdaGrad"><a href="#AdaGrad" class="headerlink" title="AdaGrad"></a>AdaGrad</h3><pre><code class="hljs python">grad_squared = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    dx = compute_gradient(x)    grad_squared += dx * dx    x -= learning_rate * dx / (np.sqrt(grad_squared) + <span class="hljs-number">1e-7</span>)</code></pre><blockquote><p>The basic idea about AdaGrad algorithm is that the step of dimention with smaller gradients will be divided by small vals and make it move faster, while greater one slower to avoid zig-zag behavior.</p><p>while the step will become smaller and smaller while you get closer to the minima, but in turn with higher risks to stuck in the local minima.</p></blockquote><hr><h3 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9JxA0.png" alt></p><blockquote><p>With a decay rate to make a smooth stop the reducing of steps.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9Y99U.png" alt></p><hr><h3 id="Adam-almost"><a href="#Adam-almost" class="headerlink" title="Adam (almost)"></a>Adam (almost)</h3><pre><code class="hljs python">first_moment = <span class="hljs-number">0</span>second_moment = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    dx = compute_gradient(x)    first_moment = beta1 + first_moment + (<span class="hljs-number">1</span> - beta1) * dx    <span class="hljs-comment"># Momentum</span>    second_moment = beta2 * second_moment + (<span class="hljs-number">1</span> - beta2) * dx * dx    <span class="hljs-comment"># AdaGrad / RMSProp</span>    x -= learning_rate * first_moment / (np.sqrt(second_moment) + <span class="hljs-number">1e-7</span>)</code></pre><blockquote><p>It combine the two methods, but with a little bug of the first step, which gonna be super large.</p></blockquote><h3 id="Adam-full-form"><a href="#Adam-full-form" class="headerlink" title="Adam (full form)"></a>Adam (full form)</h3><pre><code class="hljs python">first_moment = <span class="hljs-number">0</span>second_moment = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_iterations):    dx = compute_gradient(x)    first_moment = beta1 + first_moment + (<span class="hljs-number">1</span> - beta1) * dx    <span class="hljs-comment"># Momentum</span>    second_moment = beta2 * second_moment + (<span class="hljs-number">1</span> - beta2) * dx * dx    <span class="hljs-comment"># AdaGrad / RMSProp</span>    first_unbias = first_moment / (<span class="hljs-number">1</span> - beta1 ** t)    second_unbias = second_moment / (<span class="hljs-number">1</span> - beta2 ** t)    x -= learning_rate * first_unbias / (np.sqrt(second_unbias) + <span class="hljs-number">1e-7</span>)</code></pre><blockquote><p>Bias correction for the fact that first and second moment estimates start at zero</p></blockquote><ul><li>Great starting point</li></ul><ol><li>beta1 = 0.9</li><li>beta2 = 0.999</li><li>learning_rate = 1e-3 or 5e-4</li></ol><hr><h3 id="Decay-the-learning-rate-to-make-it-finer"><a href="#Decay-the-learning-rate-to-make-it-finer" class="headerlink" title="Decay the learning rate to make it finer"></a>Decay the learning rate to make it finer</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9YShT.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9YPc4.png" alt></p><hr><h3 id="little-bit-Fancier-Optimization"><a href="#little-bit-Fancier-Optimization" class="headerlink" title="little bit Fancier Optimization"></a>little bit Fancier Optimization</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9YC3F.png" alt></p><blockquote><p>First derivative optimization</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9YijJ.png" alt></p><blockquote><p>Second derivative optimization, direct to the mini</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9Yku9.png" alt></p><blockquote><p>Don’t need learning rate, but impractical for Hessian has O(N^2) elements and Inverting takes O(N^3)</p></blockquote><h4 id="Quasi-Newton-methods-BGFS"><a href="#Quasi-Newton-methods-BGFS" class="headerlink" title="Quasi - Newton methods (BGFS)"></a>Quasi - Newton methods (BGFS)</h4><p><img src="https://s3.ax1x.com/2020/11/13/D9YABR.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9YEH1.png" alt></p><hr><h3 id="In-Practice"><a href="#In-Practice" class="headerlink" title="In Practice:"></a>In Practice:</h3><ul><li>Using Adam</li><li>If full batch updates can be afforded, try out <strong>L-BFGS</strong></li></ul><hr><h3 id="Reduce-the-gap-between-train-and-unseen-data"><a href="#Reduce-the-gap-between-train-and-unseen-data" class="headerlink" title="Reduce the gap between train and unseen data"></a>Reduce the gap between train and unseen data</h3><h4 id="Model-Ensembles"><a href="#Model-Ensembles" class="headerlink" title="Model Ensembles"></a>Model Ensembles</h4><ol><li>Train multiple independent models</li><li>At test time average their results</li></ol><p>2% improvement maybe</p><p><img src="https://s3.ax1x.com/2020/11/13/D9YeN6.png" alt></p><blockquote><p>Instead of using actual parameter vector, keep a moving average of the para vector and use that at test time</p></blockquote><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    data_batch = dataset.sample_data_batch()    loss = network.forward(data_batch)    dx = network.backward()    x += - learning_rate * dx    x_test = <span class="hljs-number">0.995</span>*x_test + <span class="hljs-number">0.005</span>*x</code></pre><h4 id="Regularization-to-make-single-model-performs-better"><a href="#Regularization-to-make-single-model-performs-better" class="headerlink" title="Regularization to make single model performs better"></a>Regularization to make single model performs better</h4><ul><li>Dropout</li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9Ym4K.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9YK3D.png" alt></p><blockquote><p>Another interpretation is that you can percive each binary mask as a single model, so it just like dropout is training a large ensemble of models with shared paras.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9Yu9O.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9YMge.png" alt></p><h4 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h4><blockquote><p>Which can achieve the same effect as the Dropout, for it includes some noises.</p><h4 id="Data-Augmentation"><a href="#Data-Augmentation" class="headerlink" title="Data Augmentation"></a>Data Augmentation</h4><p>To introduce noise to make it performs better on unseen data.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9YQjH.png" alt></p><h4 id="Stochastic-Depth"><a href="#Stochastic-Depth" class="headerlink" title="Stochastic Depth"></a>Stochastic Depth</h4><blockquote><p>Randomly drop layers during training.<br>Use the full networks during testing.</p></blockquote><hr><h3 id="Transfer-Learning"><a href="#Transfer-Learning" class="headerlink" title="Transfer Learning"></a>Transfer Learning</h3><blockquote><p>There is no need for huge amount of data.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9Y1ud.png" alt></p>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Training Neural Networks I 05</title>
    <link href="/2020/11/13/CS231n/CS231n-05-Training-Neural-Networks-I/"/>
    <url>/2020/11/13/CS231n/CS231n-05-Training-Neural-Networks-I/</url>
    
    <content type="html"><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><ol><li>One time setup</li><li>Training dynamics</li><li>Evaluation</li></ol><h3 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h3><ul><li>Activation Functions</li><li>Data Preprocessing</li><li>Weight initialization</li><li>Batch Normalization</li><li>Babysitting the Learning Process</li><li>Hyperparameter Optimization</li></ul><hr><h3 id="Activation-Functions"><a href="#Activation-Functions" class="headerlink" title="Activation Functions"></a>Activation Functions</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9uofs.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9uIYj.png" alt></p><h4 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h4><script type="math/tex; mode=display">\sigma(x) = 1/(1+e^{-x})</script><ul><li>Squashes numbers to range [0,1]</li><li>Historically popular “firing rate” of a neuron</li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9uhTg.png" alt></p><p><strong>3 Problems</strong></p><ol><li>Saturated the neural may kill the gradient.</li></ol><p><img src="https://s3.ax1x.com/2020/11/13/D9u5kQ.png" alt></p><blockquote><p>x is a very negative and very positive val, its gradient will be killed to zero</p></blockquote><ol><li>Sigmoid outputs are not zero-centered</li></ol><p><img src="https://s3.ax1x.com/2020/11/13/D9u7pn.png" alt></p><blockquote><p>For the sign of x and gradient is always the same, it gonna behaves like is above pic.</p><p>thats why we need zero-mean data, to optimize the w just through the zig zag path.</p></blockquote><ol><li>exp() is a bit compute expensive</li></ol><hr><h4 id="Tanh"><a href="#Tanh" class="headerlink" title="Tanh"></a>Tanh</h4><ul><li>Squashes numbers to range [-1, 1]</li><li>zero centered (nice)</li><li>still kills gradients when saturated</li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9uHlq.png" alt></p><hr><h4 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h4><script type="math/tex; mode=display">f(x) = max(0, x)</script><p><img src="https://s3.ax1x.com/2020/11/13/D9ub60.png" alt></p><ul><li>Does not saturate (in + region)</li><li>Very computationally efficient</li><li>Converges much faster than sigmoid/tanh in practice</li><li>Actually more biologically plausible than sigmoid</li></ul><p><strong>Problems</strong></p><ol><li>Not zero-centered output</li><li>An annoyance:</li><li>when x &lt;= 0 the gradient is slashed to zero (kill half the gradient)</li></ol><p><img src="https://s3.ax1x.com/2020/11/13/D9uX0U.png" alt></p><ul><li>Bad Init</li><li>Learning rate too high</li></ul><blockquote><p>people like to initialize ReLU neurons with slightly positive biases (eg 0.01), to increase the possibility that being activated.</p></blockquote><hr><h4 id="Leaky-ReLu"><a href="#Leaky-ReLu" class="headerlink" title="Leaky ReLu"></a>Leaky ReLu</h4><script type="math/tex; mode=display">f(x) = max(0.01x,x)</script><p><img src="https://s3.ax1x.com/2020/11/13/D9uqXV.png" alt></p><ul><li>Does not saturated</li><li>Computationally efficient</li><li>Converges much faster …</li><li><strong>will not die</strong></li></ul><p>or <strong>Para Rectifier ReLu</strong></p><script type="math/tex; mode=display">f(x) = max(\alpha{x},x)</script><hr><h4 id="Exponential-Linear-Units-ELU"><a href="#Exponential-Linear-Units-ELU" class="headerlink" title="Exponential Linear Units (ELU)"></a>Exponential Linear Units (ELU)</h4><p><img src="https://s3.ax1x.com/2020/11/13/D9uOmT.png" alt></p><ul><li>All benefits of ReLU</li><li>Closer to zero mean outputs</li><li>Negative saturation regime adds some robustness to noise</li></ul><p><em>While it requires exp()</em></p><hr><h4 id="Maxout-“Neuron”"><a href="#Maxout-“Neuron”" class="headerlink" title="Maxout “Neuron”"></a>Maxout “Neuron”</h4><p><img src="https://s3.ax1x.com/2020/11/13/D9uj7F.png" alt></p><hr><h4 id="In-practice"><a href="#In-practice" class="headerlink" title="In practice"></a>In practice</h4><ul><li>Use ReLU. (zbe careful with learning rates)</li><li>Try Leaky <em>ReLU / Maxout / ELU</em></li><li>Don’t use sigmoid</li></ul><hr><h3 id="Data-Preprocessing"><a href="#Data-Preprocessing" class="headerlink" title="Data Preprocessing"></a>Data Preprocessing</h3><h4 id="Step1-Preprocess-the-data"><a href="#Step1-Preprocess-the-data" class="headerlink" title="Step1: Preprocess the data"></a>Step1: Preprocess the data</h4><p><img src="https://s3.ax1x.com/2020/11/13/D9uxk4.png" alt></p><ul><li>In CV we usually don’t normalize the data.</li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9KSh9.png" alt></p><p>Practice above make the data zero-mean, but only the first layer, and that’s why we need the activation func tobe zero-mean.</p><hr><h3 id="Weight-Initialization"><a href="#Weight-Initialization" class="headerlink" title="Weight Initialization"></a>Weight Initialization</h3><h4 id="First-idea-Small-random-numbers"><a href="#First-idea-Small-random-numbers" class="headerlink" title="First idea: Small random numbers"></a>First idea: Small random numbers</h4><pre><code class="hljs python">W = <span class="hljs-number">0.01</span>* np.random.randn(D,H)</code></pre><blockquote><p>Works Okay for small, but have problems in big one.</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9KC11.png" alt></p><h4 id="How-about-making-Weight-big"><a href="#How-about-making-Weight-big" class="headerlink" title="How about making Weight big?"></a>How about making Weight big?</h4><p><img src="https://s3.ax1x.com/2020/11/13/D9KP6x.png" alt></p><blockquote><p>it gonna saturated the regime to be either very possitive or very negative input of tanh, and comes out near zero gradients. The weight will not be updated.</p></blockquote><h4 id="Xavier-initialization"><a href="#Xavier-initialization" class="headerlink" title="Xavier initialization"></a>Xavier initialization</h4><p><em>Woo my initialzation? haha</em></p><p><img src="https://s3.ax1x.com/2020/11/13/D9KiX6.png" alt></p><blockquote><p>ensure we are at the active region of tanh</p></blockquote><p><img src="https://s3.ax1x.com/2020/11/13/D9KA0O.png" alt></p><blockquote><p>Can be addressed by add an extra /2， to ensure the neural won’t die in ReLU</p></blockquote><hr><h3 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h3><p><img src="https://s3.ax1x.com/2020/11/13/D9KknK.png" alt></p><blockquote><p>To regulize the input tobe unit gaussian.</p></blockquote><p><em>I have no idea about it. What is unit gaussian?</em></p><p><img src="https://s3.ax1x.com/2020/11/13/D9KetH.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9KE7D.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9KZAe.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9Kmhd.png" alt></p><hr><h3 id="Babysitting-the-Learning-Process"><a href="#Babysitting-the-Learning-Process" class="headerlink" title="Babysitting the Learning Process"></a>Babysitting the Learning Process</h3><ul><li><ol><li>Preprocess data</li></ol></li><li><ol><li>Choose the architecture:</li></ol></li><li><ol><li>Double check that the loss is reasonable</li></ol></li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9KK1I.png" alt></p><h4 id="The-Learning-Rate"><a href="#The-Learning-Rate" class="headerlink" title="The Learning Rate"></a>The Learning Rate</h4><ul><li>Very small learning rate 1e-6<blockquote><p>litter help</p></blockquote></li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9K3B8.png" alt></p><ul><li>Very great learning rate 1e6<blockquote><p>go extreme</p></blockquote></li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9KQjP.png" alt></p><ul><li>A Rough Range</li></ul><script type="math/tex; mode=display">1\times{10}^{-3} \to 1\times{10}^{-5}</script><hr><h3 id="Hyperparameter-Optimization"><a href="#Hyperparameter-Optimization" class="headerlink" title="Hyperparameter Optimization"></a>Hyperparameter Optimization</h3><ul><li><p>Cross-validation strategy<br><em>coarse -&gt; fine</em></p></li><li><p>Random Sample</p></li></ul><p><img src="https://s3.ax1x.com/2020/11/13/D9Ku9A.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9KMct.png" alt></p><p><img src="https://s3.ax1x.com/2020/11/13/D9K1nf.png" alt></p>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Convolutional_Neural_Networks 04</title>
    <link href="/2020/11/11/CS231n/CS231n-04-Convolutional-Neural-Networks/"/>
    <url>/2020/11/11/CS231n/CS231n-04-Convolutional-Neural-Networks/</url>
    
    <content type="html"><![CDATA[<h3 id="A-bit-of-CNN-History"><a href="#A-bit-of-CNN-History" class="headerlink" title="A bit of CNN History"></a>A bit of CNN History</h3><p><img src="https://s1.ax1x.com/2020/11/11/BOGJ5n.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/11/BOGGUs.png" alt></p><h4 id="Fully-Connected-Layer"><a href="#Fully-Connected-Layer" class="headerlink" title="Fully Connected Layer"></a>Fully Connected Layer</h4><p><img src="https://s1.ax1x.com/2020/11/11/BOGlDg.png" alt></p><h4 id="Convolution-Layer"><a href="#Convolution-Layer" class="headerlink" title="Convolution Layer"></a>Convolution Layer</h4><p><img src="https://s1.ax1x.com/2020/11/11/BOG1bQ.png" alt></p><blockquote><p>We just let the 5x5x3 filter $w$ to take a dot product between itself and a small 5x5z3 chunck of the image</p></blockquote><script type="math/tex; mode=display">W^Tx+b</script><p><strong>The $W$ and $x$ is streched into 1 dimention vec</strong></p><ul><li>Then the Outcome:</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOG8Ej.png" alt></p><blockquote><p>We can use different layers on the top of it and get more activation maps stack them together to get a new image, just as the following pic depicted.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/11/BOGtCq.png" alt></p><blockquote><p>Then we can recursively do that work, make the front layer’s output be the next layer’s input</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/11/BOGU2V.png" alt></p><p><strong>The Layers may look like..</strong><br><em>Simple -&gt; Complex</em></p><p><img src="https://s1.ax1x.com/2020/11/11/BOGN80.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/11/BOGrVJ.png" alt></p><ul><li>The Convolution of two signals:</li></ul><script type="math/tex; mode=display">f[x,y]*g[x,y] = \sum\limits_{n_1 = -\infin}^{\infin}\sum\limits_{n_2 = -\infin}^{\infin}f[n_1,n_2]·g[x-n_1,y-n_2]</script><ul><li>A little bit preview</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOG0rF.png" alt></p><hr><ul><li>Convolution Box</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOGwKU.png" alt></p><blockquote><p>We can tell that the activation maps are becomming smaller after the filter, so we commonly use zero pad to deal with it.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/11/BOGBb4.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/11/BOGsa9.png" alt></p><blockquote><p>The Matrix shrinks from 32 —&gt; 28 -&gt; 24 (lose info)</p></blockquote><hr><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ol><li>Accepts a volume of size $W_1 <em> H_1 </em> D_1$</li><li>Four Hyperparas<ul><li>Number of filters $K$</li><li>spatial extent $F$</li><li>stride $S$</li><li>zero padding amount $P$</li></ul></li><li>Produces a volume of size $W_2 <em> H_2 </em> D_2$<ul><li>$W_2 = (W_1 - F + 2P)/S + 1$</li><li>$H_2 = (H_1 - F + 2P)/S + 1$</li><li>$D_2 = K$ <em>Depth keeps the same</em></li></ul></li></ol><h4 id="Common-Settings"><a href="#Common-Settings" class="headerlink" title="Common Settings"></a>Common Settings</h4><p>K = (powers of 2)</p><ul><li>F = 3, S = 1, P =1</li><li>F = 5, S = 1, P =2</li><li>F = 1, S = 1, P = 0 </li></ul><hr><h3 id="Conv-details"><a href="#Conv-details" class="headerlink" title="Conv details"></a>Conv details</h3><ul><li>One by One CONV</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOGy5R.png" alt></p><ul><li>EXAMPLE: CONV in pyTorch</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOGRxK.png" alt></p><ul><li>The Brain/Neuron View of CONV</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOG226.png" alt></p><ul><li>Pooling layer</li></ul><p><img src="https://s1.ax1x.com/2020/11/11/BOGg8x.png" alt></p><blockquote><p>Just spacially down sample the image to make it smaller.<br>Common Practice is Max Pooling</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/11/BOGcP1.png" alt></p><blockquote><p>We may can just use stride to replace pooling?</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Introduction to Convolutional neural network 03</title>
    <link href="/2020/11/10/CS231n/CS231n-03-Introduction-to-Convolutional-neural-network/"/>
    <url>/2020/11/10/CS231n/CS231n-03-Introduction-to-Convolutional-neural-network/</url>
    
    <content type="html"><![CDATA[<h3 id="Computational-graphs"><a href="#Computational-graphs" class="headerlink" title="Computational graphs"></a>Computational graphs</h3><p><img src="https://s1.ax1x.com/2020/11/10/BbDAaD.png" alt></p><h3 id="BackPropagation-A-method-to-compute-the-gradients-of-abitrarily-complex-function"><a href="#BackPropagation-A-method-to-compute-the-gradients-of-abitrarily-complex-function" class="headerlink" title="BackPropagation - A method to compute the gradients of abitrarily complex function"></a>BackPropagation - A method to compute the gradients of abitrarily complex function</h3><ul><li>A recursive application of Chain rule</li></ul><p><img src="https://s1.ax1x.com/2020/11/10/BbDCKx.png" alt></p><blockquote><p>We get the gradient backprop from the front and comupte with the local gradient to prop to the back.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/10/BbDPr6.png" alt></p><blockquote><p>In some cases, some part of the graph can be represented by some func that we already know to simplify the computations. (trade off the math)</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/10/BbDiqK.png" alt></p><ul><li>Patterns in backward flow</li></ul><ol><li><strong>add gate:</strong> gradient distributor (local = 1)</li><li><strong>max gate:</strong> gradient distributor (local = 1 &amp; 0)</li><li><strong>mul gate:</strong> gradient switcher (local = y &amp; x )</li></ol><p><em>Gradients add at branches n-&gt;1</em></p><ul><li>Then We Got the gradients in the form of Jacobian Matrix</li></ul><p><img src="https://s1.ax1x.com/2020/11/10/BbDkVO.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/10/BbDZPH.png" alt></p><p><em>This place include some linear algebra</em></p><h3 id="Modularized-implementation-Forward-Backward-API"><a href="#Modularized-implementation-Forward-Backward-API" class="headerlink" title="Modularized implementation: Forward / Backward API"></a>Modularized implementation: Forward / Backward API</h3><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComputationalGraph</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">inputs</span>):</span>        <span class="hljs-comment"># 1. pass inputs to input gates</span>        <span class="hljs-comment"># 2. forward the computational graph</span>        <span class="hljs-keyword">for</span> gate <span class="hljs-keyword">in</span> self.graph.nodes_topologically_sorted():            gate.forward()        <span class="hljs-keyword">return</span> loss    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backward</span>():</span>        <span class="hljs-keyword">for</span> gate <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(self.graph.nodes_topologically_sorted())            gate.backward() <span class="hljs-comment"># compute the gradients</span>        <span class="hljs-keyword">return</span> inputs_gradients</code></pre><h4 id="EXAMPLE-MulGate"><a href="#EXAMPLE-MulGate" class="headerlink" title="EXAMPLE: MulGate"></a>EXAMPLE: MulGate</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiplyGate</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">x, y</span>):</span>        z = x*y        self.x = x        self.y = y    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backward</span>(<span class="hljs-params">dz</span>):</span>        dx = self.y * z        dy = self.x * z        <span class="hljs-keyword">return</span> [dx, dy]</code></pre><blockquote><p>This practice is common.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/10/BbDeGd.png" alt></p><h3 id="Summary-so-Far"><a href="#Summary-so-Far" class="headerlink" title="Summary so Far"></a>Summary so Far</h3><p><img src="https://s1.ax1x.com/2020/11/10/BbDmRA.png" alt></p><h3 id="Neural-networks"><a href="#Neural-networks" class="headerlink" title="Neural networks"></a>Neural networks</h3><p>(Before) Linear score function: $f = Wx$<br>(Now) 2-layers Neural Network $f = W_2max(0, W_1x)$<br>….or more layers</p><p><img src="https://s1.ax1x.com/2020/11/10/BbDEIe.png" alt></p><blockquote><p>The h is the scores W1 output, and we put one more linear layer W2 on the top of it to weighting the scores given by h </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Loss Functions and Optimization 02</title>
    <link href="/2020/11/08/CS231n/CS231n_02_Loss-Functions-and-Optimization/"/>
    <url>/2020/11/08/CS231n/CS231n_02_Loss-Functions-and-Optimization/</url>
    
    <content type="html"><![CDATA[<h3 id="Preview-the-Goal-in-this-lecture"><a href="#Preview-the-Goal-in-this-lecture" class="headerlink" title="Preview the Goal in this lecture"></a>Preview the Goal in this lecture</h3><ol><li>Define a loss function</li><li>Come up with a way of finding the paras that minimize the (1)<br>(optimization)</li></ol><p><strong>The Remain Problem from last lecture</strong></p><ul><li>How to choose the W para ? </li></ul><p><img src="https://s1.ax1x.com/2020/11/08/BTZxgK.png" alt></p><h3 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h3><blockquote><p>A loss function tells how good our current classifier is.</p></blockquote><script type="math/tex; mode=display">{(x_i,y_i)}_{i=1}^N</script><p>The $X_i$ is image and the $y_i$ is label (int)</p><p>The Total loss is defined as the func follows.</p><script type="math/tex; mode=display">L = \frac{1}{N}\sum\limits_iL_i(f(x_i,W),y_i)</script><p><em>Which is the sum of every single test’s loss</em></p><hr><h4 id="Muticlass-SVM-loss"><a href="#Muticlass-SVM-loss" class="headerlink" title="Muticlass SVM loss"></a><strong>Muticlass SVM loss</strong></h4><p>Given an example $(x_i,y_i)$ where $x_i$ is the image and where $y_i$ is the (int) label, using the shorthand for the score vec $s = f(x_i,W)$</p><p>The SVM loss has the form:</p><p><img src="https://s1.ax1x.com/2020/11/08/BTZ7B4.png" alt></p><blockquote><p>if the incorrect score is smaller than the right score (x margin), we set the loss to 0.<br>in this case the safe margin is set to one<br><strong>Margin choice depends on our need</strong></p></blockquote><ul><li>Then we loop the class</li></ul><p><img src="https://s1.ax1x.com/2020/11/08/BTZqE9.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/08/BTZLNR.png" alt></p><ul><li>What if we use</li></ul><script type="math/tex; mode=display">L = \frac{1}{N}\sum\limits_iL_i(f(x_i,W),y_i)^2</script><blockquote><p>This is not a linear function and totally different, it’s may be useful sometimes depends on the way you care about the errors.</p></blockquote><h4 id="Example-Code"><a href="#Example-Code" class="headerlink" title="Example Code"></a>Example Code</h4><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">L_i_vectorized</span>(<span class="hljs-params">x, y, W</span>):</span>    scores = W.dot(x)    margins = np.maximun(<span class="hljs-number">0</span>, scores - scores[y] + margin)    margins[y] = <span class="hljs-number">0</span>    loss_i = np.<span class="hljs-built_in">sum</span>(margins)    <span class="hljs-keyword">return</span> loss_i    <span class="hljs-comment"># pretty easy</span></code></pre><p><img src="https://s1.ax1x.com/2020/11/08/BTZO41.png" alt></p><blockquote><p>It just change the gap bettween scores</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTZzjO.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/08/BTe9De.png" alt></p><blockquote><p>often use L2 regularization just Euclid norm.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTepuD.png" alt></p><blockquote><p>In this case the L1 and L2 reg is equal, but we can tell that L1 prefers the $w_1$ for it contains more zero, while the L2 prefers the $w_2$ for the weight is evenly spreaded through the test case.</p><p>The Multiclass SVM loss just care about the gap bettween the right labels and the wrongs.</p></blockquote><h4 id="Softmax-Classifier"><a href="#Softmax-Classifier" class="headerlink" title="Softmax Classifier"></a><strong>Softmax Classifier</strong></h4><p><img src="https://s1.ax1x.com/2020/11/08/BTeiEd.png" alt></p><blockquote><p>We just want to make the true probability closer to 1 (closer the better, eq is the best), so the loss func can be chosed by using the -log on the $P$.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTeCHH.png" alt></p><blockquote><p>If we want to get the zero loss, the score may goes to inf! But Computer don’t like that.</p></blockquote><ul><li>Debugging Way<br>outcomes might be $logC$</li></ul><hr><p><img src="https://s1.ax1x.com/2020/11/08/BTek4I.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/08/BTeECt.png" alt></p><hr><h3 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h3><h4 id="Random-Search-The-Naive-but-Simplest-way"><a href="#Random-Search-The-Naive-but-Simplest-way" class="headerlink" title="Random Search - The Naive but Simplest way"></a>Random Search - The Naive but Simplest way</h4><blockquote><p>Really Slow !!!</p></blockquote><h4 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h4><blockquote><p>We just get the Gradient of W and go down to the bottom (maybe local best?)</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTeFUA.png" alt></p><p><strong>Code</strong></p><pre><code class="hljs python"><span class="hljs-comment"># Vanilla Gradient Descent</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    weight_grad = evaluate_gradient(loss_fun, data, weights)    weights += -step_size * weight_grad</code></pre><p><strong>Step size is called elearning rate which is important</strong></p><p><img src="https://s1.ax1x.com/2020/11/08/BTeV8P.png" alt></p><blockquote><p>Since the N might be super large, we sample some sets called minibatch and use it to estimate the true gradient.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTeZgf.png" alt></p><hr><p><img src="https://s1.ax1x.com/2020/11/08/BTenKS.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/08/BTeuDg.png" alt></p><p><strong>Color Feature</strong><br><img src="https://s1.ax1x.com/2020/11/08/BTeQEj.png" alt></p><p><strong>Gradient</strong> <em>Extract the edge info</em><br><img src="https://s1.ax1x.com/2020/11/08/BTelUs.png" alt></p><p><strong>NLP?</strong><br><img src="https://s1.ax1x.com/2020/11/08/BTeG80.png" alt></p><blockquote><p>clustering different image patches from images</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/08/BTe15n.png" alt></p><ul><li>Differences</li></ul><ol><li>Extract the Feature at first and feed into the linear classificator</li><li>Convolutional Neutral Network would learn the feature automatically during the training process.</li></ol>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CS231n Image Classification 01</title>
    <link href="/2020/11/07/CS231n/CS231n_01_Image_Classification/"/>
    <url>/2020/11/07/CS231n/CS231n_01_Image_Classification/</url>
    
    <content type="html"><![CDATA[<p><strong>Preface:</strong> This is the note of Stanford course CS231n, paving the way for my lab research.</p><h1 id="Image-Classification"><a href="#Image-Classification" class="headerlink" title="Image Classification"></a>Image Classification</h1><p><em>A core task in Computer Vision</em></p><hr><h3 id="Computer’-Work"><a href="#Computer’-Work" class="headerlink" title="Computer’ Work"></a>Computer’ Work</h3><p>Input an image, and assign one of the label amoung the given labels.</p><ul><li><strong>The Problem:</strong> </li></ul><ol><li>Semantic Gap</li><li>Viewpoint variation</li><li>illumination </li><li>Deformation</li><li>Occlusion</li><li>Intraclass variation</li></ol><hr><h3 id="An-image-classifier"><a href="#An-image-classifier" class="headerlink" title="An image classifier"></a>An image classifier</h3><blockquote><p>Coding might be difficult </p></blockquote><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classify_image</span>(<span class="hljs-params">image</span>):</span>    <span class="hljs-comment"># Do Some Magic</span>    <span class="hljs-keyword">return</span> class_label</code></pre><ul><li>Attmpts</li></ul><p><img src="https://s1.ax1x.com/2020/11/07/BIMSmD.png" alt></p><hr><h3 id="Data-Driven-Approach"><a href="#Data-Driven-Approach" class="headerlink" title="Data-Driven Approach"></a>Data-Driven Approach</h3><ol><li>Collect a dataset of images and labels</li><li>Use Machine Learning to train a classifier</li><li>Evaluate the classifier on new images</li></ol><ul><li>First classifier: Nearest Neighbor</li></ul><p><em>Just Memorize all data and labels</em><br><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span>(<span class="hljs-params">images, labels</span>):</span>    <span class="hljs-comment"># Machine Learning!</span>    <span class="hljs-keyword">return</span> model</code></pre></p><p><em>Predict the label of the most similar training image</em><br><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span>(<span class="hljs-params">model, test_images</span>):</span>    <span class="hljs-comment"># Use model to predict labels</span>    <span class="hljs-keyword">return</span> test_labels</code></pre></p><p><strong>Example Dataset:</strong> CIFAR10</p><p><img src="https://s1.ax1x.com/2020/11/07/BIM9TH.png" alt></p><blockquote><p><strong>Issues:</strong> Although pics may seem visually similar, but still give lots of errors.</p><hr></blockquote><ul><li>Compare func used in it<h3 id="K-nearest-Neighbors-Method"><a href="#K-nearest-Neighbors-Method" class="headerlink" title="K nearest Neighbors Method"></a><strong>K nearest Neighbors Method</strong></h3></li></ul><p><strong>L1 distance:</strong> $d<em>1(I_1,I_2) = \sum\limits</em>{p} \mid I_1^p - I_2^p \mid$</p><p><img src="https://s1.ax1x.com/2020/11/07/BIKXSx.png" alt></p><p><em>Minimize the sum given the most similar pics</em></p><h4 id="BackWards"><a href="#BackWards" class="headerlink" title="BackWards"></a><strong>BackWards</strong></h4><p><img src="https://s1.ax1x.com/2020/11/07/BIKjl6.png" alt></p><h4 id="What-it-looks-like"><a href="#What-it-looks-like" class="headerlink" title="What it looks like"></a><strong>What it looks like</strong></h4><p><img src="https://s1.ax1x.com/2020/11/07/BIMp0e.png" alt></p><p><strong>Issues</strong></p><ol><li>Isolated Yellow Point</li><li>Noisy of one single point (green into blue)</li></ol><p><strong>Use K Nearest Neighbors to Optimize it</strong><br><img src="https://s1.ax1x.com/2020/11/07/BIMitA.png" alt></p><hr><p><em>A Better Cmp Func</em><br><strong>L2(Euclidean) distance:</strong> $d<em>1(I_1,I_2) = \sqrt{\sum\limits</em>{p}{(I_1^p - I_2^p)}^2}$</p><p><img src="https://s1.ax1x.com/2020/11/07/BIMFfI.png" alt></p><blockquote><p>The L1 Distance depends on the coordinate system, whenever there is a rotate, it would change the L1 Distance, while that won’t happen in the L2 Distance case (simply because it’s a circle)</p></blockquote><hr><h4 id="Hyperparameters"><a href="#Hyperparameters" class="headerlink" title="Hyperparameters"></a><strong>Hyperparameters</strong></h4><ul><li>What’s the best value of <strong>k</strong></li><li>What’s the best <strong>distance</strong> to use? (L1,L2 or anything else)</li></ul><p><em>These things are preset rather than learn automatically from learning process</em></p><p>This is <strong>Very problem-dependent</strong>, just try!, but How?</p><p><img src="https://s1.ax1x.com/2020/11/07/BIME1P.png" alt></p><p><strong>Training &amp; Validation process should not mixed with the test data</strong></p><ul><li>Cross Validation</li></ul><p><img src="https://s1.ax1x.com/2020/11/07/BIMApt.png" alt></p><ul><li>Validation process</li></ul><p><img src="https://s1.ax1x.com/2020/11/07/BIMV6f.png" alt></p><blockquote><p>using the validation data to choose the best hyperparameters.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/07/BIMu7Q.png" alt></p><blockquote><p>Cause we sum the offset, though the differences bettween pics and pics are various, they still got the same L2 distance, which is not so good.</p></blockquote><hr><h3 id="Linear-Classification"><a href="#Linear-Classification" class="headerlink" title="Linear Classification"></a><strong>Linear Classification</strong></h3><ul><li><strong>Parametric Model</strong><br><img src="https://s1.ax1x.com/2020/11/07/BIMZX8.png" alt></li></ul><script type="math/tex; mode=display">f(x,W) = Wx + b</script><blockquote><p>We need f(x,W) to be 10x1 and the x is actually 3072x1, so the W we input may be 10x3072, sometimes we add a bias to balance.</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/07/BIMn0g.png" alt></p><p><img src="https://s1.ax1x.com/2020/11/07/BIMMkj.png" alt></p><blockquote><p>It use a single line to separate the object based on its RGB info</p></blockquote><p>But how can we tell the quality of W ?<br>(View the next lecture)</p><ul><li><strong>Problems</strong><br><img src="https://s1.ax1x.com/2020/11/07/BIMQts.png" alt></li></ul><blockquote><p>Since it’s linear the Problems is obivious.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CS231n</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS-Lab2 二进制炸弹</title>
    <link href="/2020/11/06/ICS/ICS_Lab2/"/>
    <url>/2020/11/06/ICS/ICS_Lab2/</url>
    
    <content type="html"><![CDATA[<h1 id="ICS-Lab2-Bomb"><a href="#ICS-Lab2-Bomb" class="headerlink" title="ICS-Lab2-Bomb"></a>ICS-Lab2-Bomb</h1><blockquote><p>这个是CS:APP的第二个lab，主要着重于汇编代码的阅读</p></blockquote><hr><h2 id="完成截图"><a href="#完成截图" class="headerlink" title="完成截图"></a>完成截图</h2><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_244e1f55d2823d58f65eabab9478d7ce.png"></p><hr><h2 id="Phase-1-入门"><a href="#Phase-1-入门" class="headerlink" title="Phase 1 - 入门"></a>Phase 1 - 入门</h2><h3 id="一、分析"><a href="#一、分析" class="headerlink" title="一、分析"></a>一、分析</h3><blockquote><p>练手入门题，用esi寄存器储存答案地址 (一个立即数)<br><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">402400</span>,%esi</code></pre><br>之后调用了一个 string_not_equal 函数比较输入和答案是否一致，一致就通过了。<br><pre><code class="hljs angelscript">callq  <span class="hljs-number">401338</span> &lt;<span class="hljs-built_in">string</span>s_not_equal&gt;</code></pre></p></blockquote><h3 id="二、gdb调试"><a href="#二、gdb调试" class="headerlink" title="二、gdb调试"></a>二、gdb调试</h3><blockquote><p>看一下内存地址里面存了什么，获得flag</p></blockquote><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_4801c7e177c56f6e7299c273d0120988.png"></p><ul><li><strong>答案</strong>: Border relations with Canada have never been better.</li></ul><hr><h2 id="Phase-2-循环"><a href="#Phase-2-循环" class="headerlink" title="Phase 2 - 循环"></a>Phase 2 - 循环</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote><p>本题是一个do while Loop, 难度不大, 耐心读就行了</p></blockquote><p><strong>关键位置</strong></p><ul><li>信息1 ： 看到 read_six_number 知道输入6个数，再往下看</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">cmpl</span>   $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,(%rsp) # 比较栈顶地址所存变量大小是否为<span class="hljs-number">1</span><span class="hljs-attribute">je</span>     <span class="hljs-number">400</span>f<span class="hljs-number">30</span> &lt;phase_<span class="hljs-number">2</span>+<span class="hljs-number">0</span>x<span class="hljs-number">34</span>&gt; # 如果为<span class="hljs-number">1</span> 跳转至地址 <span class="hljs-number">400</span>f<span class="hljs-number">30</span><span class="hljs-attribute">callq</span>  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt; # 如果不为<span class="hljs-number">1</span>，直接炸了<span class="hljs-attribute">jmp</span>    <span class="hljs-number">400</span>f<span class="hljs-number">30</span> &lt;phase_<span class="hljs-number">2</span>+<span class="hljs-number">0</span>x<span class="hljs-number">34</span>&gt; # 跳转至地址 <span class="hljs-number">400</span>f<span class="hljs-number">30</span></code></pre><ul><li>信息2 : 第一个数为1</li></ul><p>下面进入Loop Body</p><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_27148224f8cf2be48266eaa52f50b2f8.png"></p><ul><li>信息3 :<br>可以看到这个循环把前一个数乘了2，跟后一个数比较, 如果相等就能够继续，不然就炸了。</li></ul><blockquote><p>综上也就是说这是一个首项为1，公比为2的等比数列，共6项。</p></blockquote><p>所以答案就是 1 2 4 8 16 32</p><hr><h2 id="Phase-3-分支"><a href="#Phase-3-分支" class="headerlink" title="Phase 3 - 分支"></a>Phase 3 - 分支</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><blockquote><p>第三题关键点在于用gdb查看一下jumptable</p></blockquote><p> 我们先看一下输入，在输入了两个变量后，esi里放了内存中的一个可疑的东西，我们用gdb看一眼。<br><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">4025</span>cf,%esi</code></pre></p><pre><code class="hljs shell">(gdb) p(char *) 0x4025cf&quot;%d %d&quot;</code></pre><p> 发现原来是输入两个整型，再往下看</p><pre><code class="hljs apache"><span class="hljs-attribute">cmpl</span>   $<span class="hljs-number">0</span>x<span class="hljs-number">7</span>,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp) # 将 M(rsp + <span class="hljs-number">8</span>) 看作<span class="hljs-number">32</span>位无符号数跟<span class="hljs-number">7</span>比较<span class="hljs-attribute">ja</span>     <span class="hljs-number">400</span>fad &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">6</span>a&gt; # 如果大于就跳转至 <span class="hljs-number">0</span>x<span class="hljs-number">400</span>fad (炸弹炸了)</code></pre><p> 发现如果输入的第一个数大于7就爆炸了，看来switch最多只有7个case</p><pre><code class="hljs angelscript">jmpq   *<span class="hljs-number">0x402470</span>(,%rax,<span class="hljs-number">8</span>) # 跳转至 (eax * <span class="hljs-number">8</span> + <span class="hljs-number">0x402470</span>)处所存的地址 （jumptable）</code></pre><blockquote><p>最关键的是这一句，构造了一个 switch 的 jumptable，我们知道地址是 0x402470，按照 case * 8 + 0x402470 跳转到该地址里面的地址，所以我们用gdb看一下。</p></blockquote><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_ae5e359c30ff5ccb9292a7472c39eb19.png"></p><ul><li><p>我通关选了case 1（它比较特殊，处理它其他内存地址跳转都是按case从小到大顺序的，只有case 1 在最后一个，当然其他也都能过。）</p></li><li><p>case 1 跳转到了 0x400fb9 地址</p></li></ul><pre><code class="hljs angelscript">mov    $<span class="hljs-number">0x137</span>,%eax # eax = <span class="hljs-number">0x137</span> (<span class="hljs-number">311</span>) (不用跳转了，下面就是 <span class="hljs-number">0x400fbe</span>)</code></pre><p>其将eax置为了0x137，要小心是16进制，所以对应十进制311</p><pre><code class="hljs apache"><span class="hljs-attribute">cmp</span>    <span class="hljs-number">0</span>xc(%rsp),%eax # 比较 M(rsp + <span class="hljs-number">12</span>) 和 eax<span class="hljs-attribute">je</span>     <span class="hljs-number">400</span>fc<span class="hljs-number">9</span> &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">86</span>&gt; # 如果相等就跳转至 <span class="hljs-number">0</span>x<span class="hljs-number">400</span>fc<span class="hljs-number">9</span> (过关了！)</code></pre><p>最后是一个比较，如果eax和第二个输入值相同就过了。</p><ul><li>本题答案（不唯一)</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">case</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">ans</td><td style="text-align:center">207</td><td style="text-align:center">311</td><td style="text-align:center">707</td><td style="text-align:center">256</td><td style="text-align:center">389</td><td style="text-align:center">206</td><td style="text-align:center">682</td><td style="text-align:center">327</td></tr></tbody></table></div><hr><h2 id="Phase-4-递归"><a href="#Phase-4-递归" class="headerlink" title="Phase 4 - 递归"></a>Phase 4 - 递归</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ul><li>这题是个递归，不过不用很深，很快就能看出答案。</li></ul><p>先正常读两个数，放在rdx，rcx中，检查输入。</p><pre><code class="hljs angelscript">cmpl   $<span class="hljs-number">0xe</span>,<span class="hljs-number">0x8</span>(%rsp) # 比较 M(rsp + <span class="hljs-number">8</span>) (既 rdx) 与 <span class="hljs-number">0xe</span>jbe    <span class="hljs-number">40103</span>a &lt;phase_4+<span class="hljs-number">0x2e</span>&gt; # 如果 rdx &lt;= <span class="hljs-number">0xe</span> (<span class="hljs-number">14</span>) 跳转至 <span class="hljs-number">0x40103a</span>, 不然就炸了 (作为无符号数)</code></pre><blockquote><p>这两行汇编告诉我们，rdx一定要小于 0xe (14) 且大于等于0, 不然炸了, 大幅度缩小了范围。</p><p>接下来就进入了函数递归调用，先做点预处理，把edx里面存一个立即数14，然后edi为第一个输入值，esi = 0 进入fun4</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>xe,%edx # edx = <span class="hljs-number">0</span>xe (<span class="hljs-number">14</span>)<span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%esi # esi = <span class="hljs-number">0</span><span class="hljs-attribute">mov</span>    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp),%edi # edi = (第一个输入值)<span class="hljs-attribute">callq</span>  <span class="hljs-number">400</span>fce &lt;func<span class="hljs-number">4</span>&gt; # 调用func<span class="hljs-number">4</span></code></pre><blockquote><p>先不着急看fun4，先看看最后要怎么过关<br><pre><code class="hljs apache"><span class="hljs-attribute">test</span>   %eax,%eax # eax &amp; eax<span class="hljs-attribute">jne</span>    <span class="hljs-number">401058</span> &lt;phase_<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">4</span>c&gt; <span class="hljs-comment"># 如果ZF == 0 就跳转（既eax != 0)，跳转至 0x401058 炸了</span><span class="hljs-attribute">cmpl</span>   $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,<span class="hljs-number">0</span>xc(%rsp) # 比较 M(rsp + <span class="hljs-number">12</span>) 和 <span class="hljs-number">0</span><span class="hljs-attribute">je</span>     <span class="hljs-number">40105</span>d &lt;phase_<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">51</span>&gt; # 如果相等就跳转到 <span class="hljs-number">0</span>x<span class="hljs-number">40105</span>d, 不然就炸了</code></pre></p><ul><li>test 实际上就是一个与操作，所以我们知道需要 eax == 0 且 M(rsp + 12) == 0，到这我们发现，第二个条件只要我们一开始输入的第二个参数为0，就能够保证，那么下面我们就要看进入fun4之后如何让返回值 eax == 0</li></ul><p>再回来看fun4，其分为两部分，一个是递归的主体，一个是判断是否继续递归。一开始先对eax 和 ecx 进行一些操作。</p><ul><li>我们发现 eax 和 ecx 的值在第一层递归都被置为14，(esi 为 0)按其操作得到 eax 除2, ecx 逻辑右移 31 位为0, 接着其实就是比较 edi 和 rax, <strong>相当于就是比较第一个参数和常数 7</strong></li></ul></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">jle</span>    <span class="hljs-number">400</span>ff<span class="hljs-number">2</span> &lt;func<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">24</span>&gt; # 若ecx &lt;= 就跳转至 <span class="hljs-number">0</span>x<span class="hljs-number">400</span>ff<span class="hljs-number">2</span></code></pre><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax # eax = <span class="hljs-number">0</span>;<span class="hljs-attribute">cmp</span>    %edi,%ecx # 比较 ecx 和 edi <span class="hljs-attribute">jge</span>    <span class="hljs-number">401007</span> &lt;func<span class="hljs-number">4</span>+<span class="hljs-number">0</span>x<span class="hljs-number">39</span>&gt; <span class="hljs-comment"># 若 edi &gt;= ecx 跳转至 0x401007 返回</span></code></pre><ul><li>接着是一个跳转, 如果满足我们就跳转至 0x400ff2, 我们发现这里已经满足了我们需要的 eax == 0，而想要结束就得使 edi &gt;= ecx (7), 所以我们发现，对于上下两个跳转条件，只要 edi == ecx == 7 就能一直成立，从而直接达成条件，不用进入递归。</li></ul><p>进而我们得到了本题答案：7 0</p><hr><h2 id="Phase-5-指针"><a href="#Phase-5-指针" class="headerlink" title="Phase 5 - 指针"></a>Phase 5 - 指针</h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><ul><li>这题我觉得是最好玩的一题，先直接分析如何通关。</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">40245</span>e,%esi # esi = <span class="hljs-number">0</span>x<span class="hljs-number">40245</span>e <span class="hljs-comment"># 待比较的 string (flyers) 从 0x40245e 移动至 esi</span></code></pre><ul><li>我们在接近返回时看到了一个非常可疑的内存地址，直接给它打出来。</li></ul><pre><code class="hljs lsl">(gdb) p(char*) <span class="hljs-number">0x40245e</span>$<span class="hljs-number">4</span> = <span class="hljs-number">0x40245e</span> <span class="hljs-string">&quot;flyers&quot;</span></code></pre><blockquote><p>发现是一个可疑字符串 flyers，阅读上下文汇编代码可知，最后是比较字符串是否和指定字符串 “flyers” 一致。</p></blockquote><ul><li>我们再往上看看要怎么输入</li></ul><pre><code class="hljs angelscript">callq  <span class="hljs-number">40131</span>b &lt;<span class="hljs-built_in">string</span>_length&gt; # 比较字符长度是否为<span class="hljs-number">6</span>cmp    $<span class="hljs-number">0x6</span>,%eax # 比较 eax 和 <span class="hljs-number">6</span></code></pre><p>发现输入一定要是六个字符 <em>(于是试了试 flyers 果然不对)</em></p><ul><li>往下看，发现了一个 Loop 循环了6次</li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_016df1440f7044a54fb4ced529595b58.png"></p><blockquote><p>经过仔细阅读后，发现这个居然是遍历六个输入字符，将其 ascii 码低4位取出来作为偏移量 (offset),在一个基地址 （0x4024b0）后面取字符出来组成 flyers.</p></blockquote><ul><li>立刻开启 gdb 查看基地址附近的内存</li></ul><p><strong>发现分别对应的偏移量是 9, 15, 14, 5, 6, 7</strong></p><blockquote><p>直接查 ascii 码，发现对应 ionefg 、IONEFG 或者有一些不是字母的字符也行，只要低四位是正确的就可以。 </p></blockquote><p><strong>本题答案:</strong>  ionefg (答案不唯一)</p><hr><h2 id="Phase-6-Node结构体"><a href="#Phase-6-Node结构体" class="headerlink" title="Phase 6 - Node结构体"></a>Phase 6 - Node结构体</h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>这题还是比较麻烦的，代码比较长也比较复杂，要耐心读。</p><ul><li>这题的代码可以大致分为输入检测与处理和一个对结构体的顺序检测.<blockquote><p>最开始上来先输入六个数之后有个双循环，外部保证输入的六个数要大于等于1，且小于等于6，内部保证互异。所以总体看来就是输入的六个数就是123456, 现在问题是输入的顺序。</p></blockquote></li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_7194e52688ff3d696a3b889e2b17d63f.png"></p><p>这段代码遍历了所有输入并用7减去了输入的每个数，所以最后做出答案要记得反一下。</p><ul><li>接下来代码比较复杂，外面大循环循环了六次，内部有两个平行的小循环。作用是构造结构体，并在栈帧中将其存放位置按照输入的数的大小计算得出</li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_9ea5cd30293a18357af1da93c35e0f59.png"></p><blockquote><p>分析代码，我们先发现一种特殊情况就是当前计算的数为1时（输入为6）edx直接就是给定的地址 0x6032d0, 其余的都按照其大小，在第一个小循环中循环相应次数，给 rdx 在原地址上相应偏移16位。</p><p>接着下来将其存入栈帧中 rsp + 32 到 rsp + 80 的位置</p></blockquote><ul><li>使用 gdb 查看 node</li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_f2ecdd05728cbefbba59b068a29fdfdc.png"></p><p>最后我们看如何通关</p><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_a18a67d1b4dbfa16a7fd8800e3ee304b.png"></p><blockquote><p>发现通关条件是要求定序，前面node大于后面的节点，根据gdb node节点的值和要求我们得到了 3 4 5 6 1 2 的结果，最后不要忘记这是被7减过之后的结果，原来的输入要还原。所以答案就是 4 3 2 1 6 5</p></blockquote><p><strong>本题答案:</strong> 4 3 2 1 6 5</p><hr><h2 id="Secret-Phase-递归"><a href="#Secret-Phase-递归" class="headerlink" title="Secret Phase- 递归"></a>Secret Phase- 递归</h2><h3 id="一、进入方法"><a href="#一、进入方法" class="headerlink" title="一、进入方法"></a>一、进入方法</h3><ul><li>输入上面六种答案之后，发现 secret phase 并没有出现，于是开始着手寻找入口。</li></ul><blockquote><p>根据最后结果出现的字符顺藤摸瓜找到了 phase_defuse 函数，一看发现其中有一个可疑的 <string_not_equal> 函数以及几个可疑的内存地址,统统用 gdb 打印。</string_not_equal></p></blockquote><pre><code class="hljs perl">(gdb) p(char*) <span class="hljs-number">0x402619</span>$2 = <span class="hljs-number">0x402619</span> <span class="hljs-string">&quot;%d %d %s&quot;</span></code></pre><pre><code class="hljs lsl">(gdb) p(char*) <span class="hljs-number">0x402622</span>$<span class="hljs-number">3</span> = <span class="hljs-number">0x402622</span> <span class="hljs-string">&quot;DrEvil&quot;</span></code></pre><blockquote><p>发现之前调用过的__isoc99_sscanf@plt 还有隐藏用法，在输入两个数后再输入一个字符串 “DrEvil” 就能成功开启secret phase.</p></blockquote><ul><li>所以我们在最后一次调用__isoc99_sscanf@plt的 phase 4 输入 7 0 DrEvil, 果然在 phase 6 之后进入了 secret phase。</li></ul><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><ul><li>虽然说是隐藏关，但是复杂度和难度比 phase 6 低了不少，和 phase 4 一样是一个递归，但不同的是这次真的需要递归几次，但也不深。只要确定好路线还是比较容易的。</li></ul><pre><code class="hljs angelscript">callq  <span class="hljs-number">40149</span>e &lt;read_line&gt; # 读一行...callq  <span class="hljs-number">400</span>bd0 &lt;<span class="hljs-symbol">strtol@</span>plt&gt; # 调用 <span class="hljs-symbol">strtol@</span>plt</code></pre><blockquote><p>secret phase上来读了一整行然后调用了一个 strtol，经过阅读strtol的源码，发现它是以10为base将字符串转为一个整型，实际上就是剔除了最后答案中除了数字以外的字符。(所以写上答案数字然后乱输字母也能过 bushi)</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">lea</span>    -<span class="hljs-number">0</span>x<span class="hljs-number">1</span>(%rax),%eax <span class="hljs-comment"># eax = (rax) - 1</span><span class="hljs-attribute">cmp</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">3</span>e<span class="hljs-number">8</span>,%eax <span class="hljs-comment"># eax == 0x3e8 ? (即判断返回值与0x3e9)</span></code></pre><ul><li>这段代码告诉我们输入的数要小于 1000</li></ul><pre><code class="hljs apache"><span class="hljs-attribute">mov</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">6030</span>f<span class="hljs-number">0</span>,%edi # edi = <span class="hljs-number">0</span>x<span class="hljs-number">6030</span>f<span class="hljs-number">0</span> (<span class="hljs-number">36</span>)<span class="hljs-attribute">callq</span>  <span class="hljs-number">401204</span> &lt;fun<span class="hljs-number">7</span>&gt; # 调用fun<span class="hljs-number">7</span></code></pre><ul><li>将edi置为 0x6030f0 (里面存的是36) 接着开始调用fun7</li></ul><blockquote><p>我们先不着急看fun7, 老样子先看过关要求。</p></blockquote><pre><code class="hljs apache"><span class="hljs-attribute">cmp</span>    $<span class="hljs-number">0</span>x<span class="hljs-number">2</span>,%eax # 比较一下 eax 返回是否为<span class="hljs-number">2</span></code></pre><p>发现非常简单，只要eax返回值为2就行</p><ul><li>再来看fun7</li></ul><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_64ed470376ec6b72dc43690bf9b4ea0e.png"></p><blockquote><p>一看这个递归是逃不过了，但我们要让eax == 2, 路线其实非常明确，第一次先走 way3 将 eax 弄成1，再走 way1 让eax<em>2， 最后一层我们让eax == 0 最后返回我们得到的 eax 就等于2</em>（eax = 0 -&gt; 1 -&gt; 2）*</p><p>关键是一个 edx 和 esi 的比较，edx == rdi, 然后每次改变rdi使其中储存地址中所储存的变量逐步接近 esi 完成递归操作。</p></blockquote><p>根据所存地址(注意/d打出的是10进制)，可以很容易找出递归路径</p><p><img src="https://codimd.s3.shivering-isles.com/demo/uploads/upload_dfddd1801cd10c701dd2753164434977.png" style="width:65%"></p><ul><li>输入22可以正好满足需求<blockquote><p><strong>22 &lt;= 36 因而 rdi = (rdi + 8) (存8)，22 &gt; 8 因而 rdi = = (rdi + 16) (存22), 22==22 所以 eax 返回 0 ，返回 1， 返回2，最终过关</strong></p></blockquote></li></ul><p><strong>本题答案:</strong> 22 (可以带非数字字符)</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Assembly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICS-Lab1 位运算</title>
    <link href="/2020/11/05/ICS/ICS_Lab1/"/>
    <url>/2020/11/05/ICS/ICS_Lab1/</url>
    
    <content type="html"><![CDATA[<h1 id="ICS-Lab1-位运算"><a href="#ICS-Lab1-位运算" class="headerlink" title="ICS_Lab1-位运算"></a>ICS_Lab1-位运算</h1><blockquote><p>这个是CS:APP的第一个lab，也是我ICS课上的第一个lab，主要注重于使用受限制的位运算来完成操作</p></blockquote><hr><h2 id="Bits-c"><a href="#Bits-c" class="headerlink" title="Bits.c"></a><strong>Bits.c</strong></h2><h3 id="1-bitAnd—与"><a href="#1-bitAnd—与" class="headerlink" title="1. bitAnd—与"></a><strong>1. bitAnd—与</strong></h3><p><strong>题目：</strong></p><pre><code>只用~和|实现&amp;</code></pre><p><strong>样例：</strong></p><pre><code>bitAnd(6, 5) = 4</code></pre><p><strong>可使用操作：</strong> ~ |</p><p><strong>最大操作数限制：</strong> 8</p><p><strong>使用操作数：</strong> 4</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitAnd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;  <span class="hljs-keyword">return</span> ~(~x | ~y); <span class="hljs-comment">//De Morgan&#x27;s laws</span>&#125;</code></pre><blockquote><p>应用摩根律 ~(x | y) = ~x &amp; ~y, 可得 x &amp; y = ~(~x | ~y)</p></blockquote><hr><h3 id="2-getByte—获取字节"><a href="#2-getByte—获取字节" class="headerlink" title="2. getByte—获取字节"></a><strong>2. getByte—获取字节</strong></h3><p><strong>题目：</strong></p><pre><code>从x中提取字节n, n编号从0至3</code></pre><p><strong>样例：</strong></p><pre><code>getByte(0x12345678,1) = 0x56</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 6</p><p><strong>使用操作数：</strong> 3</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getByte</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">return</span> (x &gt;&gt; (n &lt;&lt; <span class="hljs-number">3</span>)) &amp; <span class="hljs-number">0xff</span>;&#125;</code></pre></p><p><strong>分析：</strong></p><p><em>由于 1Byte = 8bits = 2^3bits， 所以 n Bytes = 2^3 </em> n bits*</p><blockquote><p>因而将n左移3位，即 n <em> 2^3, 再将x右移 n </em> 2^3 即可将所求字节放在低8位，将其与上0xff，即可取出字节。</p></blockquote><hr><h3 id="3-logicalShift—逻辑右移"><a href="#3-logicalShift—逻辑右移" class="headerlink" title="3. logicalShift—逻辑右移"></a><strong>3. logicalShift—逻辑右移</strong></h3><p><strong>题目：</strong></p><pre><code>将x逻辑右移n位</code></pre><p><strong>样例：</strong></p><pre><code>logicalShift(0x87654321,4) = 0x08765432</code></pre><p><strong>可使用操作：</strong>  ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 20</p><p><strong>使用操作数：</strong> 10</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">logicalShift</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-comment">//flag equals to: if n == 0 return 0; else return 1;</span>  <span class="hljs-keyword">int</span> flag = !!n;  <span class="hljs-keyword">int</span> mask = ~(flag &lt;&lt; (<span class="hljs-number">32</span> + (~n + <span class="hljs-number">1</span>)));  <span class="hljs-keyword">return</span> (x &gt;&gt; n) &amp; mask;&#125;</code></pre></p><p><strong>分析：</strong></p><ul><li><p>算数右移</p><blockquote><p>算数右移即在右移后用原符号位数将高位补齐，保持右移后二进制数的符号保持不变。</p></blockquote></li><li><p>逻辑右移</p><blockquote><p>逻辑右移即在右移后用 0 将高位补齐，是“逻辑上”的右移。</p></blockquote></li></ul><blockquote><p>在正常右移运算中使用的是算数右移，因而要解决的问题即对于负数如何将最高位补上0，而非符号位1。<br>我采取掩码的方式，先将x正常右移n位与上其高位的掩码，使其右移产生的高位变为0</p></blockquote><ul><li>掩码构造<blockquote><p>掩码不能草率的构造为 ~(-1 &lt;&lt; (32 - n)), 这种构造方式当n为0时会因-1被左移32位而导致异常，构造出来的mask仍为0</p></blockquote></li></ul><blockquote><p>由于不能使用if，为判断n是否为0，我才用了一个flag = !n + ~0, 其有很好的性质。当n为0时，flag也为0，而当n不为零时，flag统一为-1，这样使用flag代替原先的-1, 从而避免上述情况。</p><p>这样我们可以使用 mask = ~(flag &lt;&lt; (32 + (~n + 1)))，来构造掩码，当n为0时，flag为0，从而mask = -1，避免上述错误。</p></blockquote><hr><h3 id="4-bitCount—比特计数"><a href="#4-bitCount—比特计数" class="headerlink" title="4. bitCount—比特计数"></a><strong>4. bitCount—比特计数</strong></h3><p><strong>题目：</strong></p><pre><code>返回二进制数中1的个数</code></pre><p><strong>样例：</strong></p><pre><code>bitCount(5) = 2, bitCount(7) = 3</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 40</p><p><strong>使用操作数：</strong> 36</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">int</span> tmp, l1, l2, l4, l8, l16; <span class="hljs-comment">//tmp is used to save ops</span>  tmp = (<span class="hljs-number">0x55</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x55</span>;  l1 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp; <span class="hljs-comment">//0x55555555</span>  tmp = (<span class="hljs-number">0x33</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x33</span>;  l2 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp; <span class="hljs-comment">//0x33333333</span>  tmp = (<span class="hljs-number">0x0f</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x0f</span>;  l4 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp; <span class="hljs-comment">//0x0f0f0f0f</span>  l8 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">16</span>) + <span class="hljs-number">0xff</span>; <span class="hljs-comment">//0x00ff00ff</span>  l16 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xff</span>; <span class="hljs-comment">//0x0000ffff</span>  x = (x &amp; l1) + ((x &gt;&gt; <span class="hljs-number">1</span>) &amp; l1);  x = (x &amp; l2) + ((x &gt;&gt; <span class="hljs-number">2</span>) &amp; l2);  x = (x &amp; l4) + ((x &gt;&gt; <span class="hljs-number">4</span>) &amp; l4);  x = (x &amp; l8) + ((x &gt;&gt; <span class="hljs-number">8</span>) &amp; l8);  x = (x &amp; l16) + ((x &gt;&gt; <span class="hljs-number">16</span>) &amp; l16);  <span class="hljs-keyword">return</span> x;&#125;</code></pre></p><p><strong>分析：</strong></p><ul><li>分治思想<blockquote><p>本题使用了一个简单的分治思想，对于一个二进制数，要对其中为1的位做计数， 对于1位二进制数来说，1的个数无非就是其本身所表示的1或0。利用这个特性，我们可以先将一个二进制数每一位独立分开为相间隔的两部分, 其每位表示的就是自身的二进制个数，再将两串二进制数对其相加，所得到的每两位分隔的二进制数就是表达这个位置的位为1的个数。</p></blockquote></li></ul><blockquote><p>进一步相加为4位，8位其所代表的含义不变，最后合并至32位二进制数，其所表示的就是原二进制数中所含1的个数。</p></blockquote><pre><code class="hljs cpp"><span class="hljs-comment">//以八位二进制数 10101110 为例//</span>按 <span class="hljs-number">1</span>|<span class="hljs-number">0</span>|<span class="hljs-number">1</span>|<span class="hljs-number">0</span>|<span class="hljs-number">1</span>|<span class="hljs-number">1</span>|<span class="hljs-number">1</span>|<span class="hljs-number">0</span> 分割， 为两串<span class="hljs-number">1</span>|<span class="hljs-number">1</span>|<span class="hljs-number">1</span>|<span class="hljs-number">1</span>和<span class="hljs-number">0</span>|<span class="hljs-number">0</span>|<span class="hljs-number">1</span>|<span class="hljs-number">0</span>，再将其合并，成为 <span class="hljs-number">01</span> | <span class="hljs-number">01</span> | <span class="hljs-number">10</span> | <span class="hljs-number">01</span>, 再将两串 <span class="hljs-number">01</span> | <span class="hljs-number">10</span> 和<span class="hljs-number">01</span> | <span class="hljs-number">01</span>合并得 <span class="hljs-number">0010</span> | <span class="hljs-number">0011</span>（这个很容易看出表示左四位有<span class="hljs-number">2</span>个<span class="hljs-number">1</span>，右四位有<span class="hljs-number">3</span>个<span class="hljs-number">1</span>），再次合并得 <span class="hljs-number">00000101</span>, 得到总共有<span class="hljs-number">5</span>个<span class="hljs-number">1</span>。<span class="hljs-comment">//对于32位二进制数亦按此继续操作即可//</span></code></pre><blockquote><p>于是为完成分割取位的操作，我们需要采用掩码</p></blockquote><ul><li>0x55555555 \ 0x33333333 \ 0x0f0f0f0f \ 0x0000ffff</li></ul><blockquote><p>利用位运算分别构造，使用tmp可以节约ops, 之后按照分治思想进行操作即可。</p></blockquote><hr><h3 id="5-bang—逻辑非"><a href="#5-bang—逻辑非" class="headerlink" title="5. bang—逻辑非"></a><strong>5. bang—逻辑非</strong></h3><p><strong>题目：</strong></p><pre><code>计算 !x 而不使用逻辑非!</code></pre><p><strong>样例：</strong></p><pre><code>bang(3) = 0, bang(0) = 1</code></pre><p><strong>可使用操作：</strong> ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 12</p><p><strong>使用操作数：</strong> 6</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bang</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">return</span> ((x &gt;&gt; <span class="hljs-number">31</span>) | ((~x + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">31</span>)) + <span class="hljs-number">1</span>;&#125;</code></pre></p><p><strong>分析：</strong></p><ul><li>逻辑非<blockquote><p>对于逻辑非运算，应该都很熟悉，!x 当且仅当x为0时其为1，其余时候都为0，可以用来区分零和非零数。</p></blockquote></li></ul><blockquote><p>该问题的关键就是在于如何区分零和非零数，我们知道零的二补码仍然是零，而对于其余非零数，其符号位会有相应改变，利用这一性质，我们可以对零和非零数做出区分。</p><p>使用 <code>((x &gt;&gt; 31) | ((~x + 1) &gt;&gt; 31))</code>，将二进制数x的符号位与其补码左移31位相与，如若是非零数，其中符号位至少有一个为1，所以经过31位的算数右移后，其中一项必为-1，一项为0，相与之后得到-1,。而对于0来说，结果始终为0。</p><p>最后只要将结果+1，就能得到逻辑非的效果。</p></blockquote><hr><h3 id="6-tmin—最小数"><a href="#6-tmin—最小数" class="headerlink" title="6. tmin—最小数"></a><strong>6. tmin—最小数</strong></h3><p><strong>题目：</strong></p><pre><code>返回二补码中最小的数</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 4</p><p><strong>使用操作数：</strong> 1</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tmin</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>此题非常简单，我们知道计算机中负数是用其补码表示的，int所能表示的最小数为0x80000000(-2^31), 即符号位为1，其余皆为0，所以只要将1左移31位即可。</p></blockquote><hr><h3 id="7-fitsBits—填充比特"><a href="#7-fitsBits—填充比特" class="headerlink" title="7. fitsBits—填充比特"></a><strong>7. fitsBits—填充比特</strong></h3><p><strong>题目：</strong></p><pre><code>返回1如果x可以表示为n位二补码，反之返回0 (1 &lt;= n &lt;= 32)</code></pre><p><strong>样例：</strong></p><pre><code>fitsBits(5,3) = 0, fitsBits(-4,3) = 1</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 15</p><p><strong>使用操作数：</strong> 7</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fitsBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;  <span class="hljs-keyword">int</span> k = x &gt;&gt; (n + ~<span class="hljs-number">0</span>); <span class="hljs-comment">// if can k = 0 or -1</span>  <span class="hljs-keyword">return</span> !k | !(k + <span class="hljs-number">1</span>);&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>我们知道如若一个数能够被n位二进制数表示，则其第n位即最高位是符号位，那么将其右移n-1位后，根据算术右移，其得到的结果不是0，就是1。否则表示，其还有高于n位的位数， 即不能用n位表示。</p><p>所以用 k = x &gt;&gt; (n + ~0) 表示将其右移n-1位，再用 !k | !(k + 1) 判断k是否为0或-1</p></blockquote><hr><h3 id="8-divpwr2—除以2的n次方"><a href="#8-divpwr2—除以2的n次方" class="headerlink" title="8. divpwr2—除以2的n次方"></a><strong>8. divpwr2—除以2的n次方</strong></h3><p><strong>题目：</strong></p><pre><code>计算 x/(2^n), (0 &lt;= n &lt;= 30)</code></pre><p><strong>样例：</strong></p><pre><code>divpwr2(15,1) = 7, divpwr2(-33,4) = -2</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 15</p><p><strong>使用操作数：</strong> 7</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divpwr2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">int</span> sign = x &gt;&gt; <span class="hljs-number">31</span>;    <span class="hljs-keyword">int</span> bias = (<span class="hljs-number">1</span> &lt;&lt; n) + ~<span class="hljs-number">0</span>;    x = x + (bias &amp; sign);    <span class="hljs-keyword">return</span> x &gt;&gt; n;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>本题的难点在于Round toward zero, 我们知道除以2的n次方即为将x右移n位。对于正数，尾数截断，因而自然向0舍入。而对于负数则不是如此，经试验在gcc上对于负数，其是向偶数舍入的，因而我们要对负数进行操作。</p><p>同时由于其向偶数舍入，我们不能简单地对负数进行+1操作，例如原本正确的 -7/4 = -1.25 = -1，但是经过+1操作后变为-6/4 = -1.5 Round toward even则变为了2。所以我们不应简单加一，而是加一个偏差值，其为2^n - 1，对于-7/4来说，就是3，加上bias之后得到(-7 + 3)/4即为-1。</p><p>所以我们构造bias = (1 &lt;&lt; n) + ~0 (由于不能用减号，-1用+~0表示)，然后我们要记得将sign取出，在x进行加操作时先检查一下x是否是负数，再进行操作。最后只要方向的将x右移n位即可。</p></blockquote><hr><h3 id="9-negate—取负"><a href="#9-negate—取负" class="headerlink" title="9. negate—取负"></a><strong>9. negate—取负</strong></h3><p><strong>题目：</strong></p><pre><code>返回-x</code></pre><p><strong>样例：</strong></p><pre><code>negate(1) = -1.</code></pre><p><strong>可使用操作：</strong>  ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 5</p><p><strong>使用操作数：</strong> 2</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">negate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">return</span> ~x + <span class="hljs-number">1</span>;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>很简单，对于有符号二进制数取负就是取其补码，而补码等于其取反加一，返回取反加一即可。</p></blockquote><hr><h3 id="10-isPositive—是正数"><a href="#10-isPositive—是正数" class="headerlink" title="10. isPositive—是正数"></a><strong>10. isPositive—是正数</strong></h3><p><strong>题目：</strong></p><pre><code>返回1如果x大于0，反之返回0</code></pre><p><strong>样例：</strong></p><pre><code>isPositive(-1) = 0.</code></pre><p><strong>可使用操作：</strong>  ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 8</p><p><strong>使用操作数：</strong> 5</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">return</span> !(x &gt;&gt; <span class="hljs-number">31</span>) &amp; !!x;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>这题关键在于把0剔除了，区分正负数就是区分其符号位，将x右移31位，负数得-1，正数为0，用一个逻辑非使正数为1，负数为0，然后再和!!x与一下就能剔除0</p></blockquote><ul><li>!!x 当 x == 0 时返回 0，不为 0 时返回 1</li></ul><hr><h3 id="11-isLessOrEqual—小于等于"><a href="#11-isLessOrEqual—小于等于" class="headerlink" title="11. isLessOrEqual—小于等于"></a><strong>11. isLessOrEqual—小于等于</strong></h3><p><strong>题目：</strong></p><pre><code>如果x小于等于y返回1，反之返回0</code></pre><p><strong>样例：</strong></p><pre><code>isLessOrEqual(4,5) = 1.</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 24</p><p><strong>使用操作数：</strong> 14</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;  <span class="hljs-keyword">int</span> res = y + (~x + <span class="hljs-number">1</span>); <span class="hljs-comment">// y - x</span>  <span class="hljs-keyword">int</span> xSign = x &gt;&gt; <span class="hljs-number">31</span>;  <span class="hljs-keyword">int</span> ySign = y &gt;&gt; <span class="hljs-number">31</span>;  <span class="hljs-keyword">int</span> dif = ~xSign + ySign;  <span class="hljs-keyword">return</span> (~(dif + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">31</span>) &amp; !(res &gt;&gt; <span class="hljs-number">31</span>)) | !dif;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>我在这里采取了作差的方法 res = y + (~x + 1)，即计算一下y-x，判断其是否非负，同时也要考虑溢出问题，即 x 为负数，y为正数，y-x后溢出为负。</p><p>我将x,y右移31位代表其符号，若负则为-1，若正为0。我同时构造了一个 dif 以表示x,y符号之间的关系。</p><p><strong>dif = ~xSign + ySign</strong></p><ol><li>当 x &lt; 0 &amp;&amp; y &lt; 0 时，dif = -1 </li><li>当 x &lt; 0 &amp;&amp; y &gt; 0 时，dif = 0 </li><li>当 x &gt; 0 &amp;&amp; y &lt; 0 时，dif = -2 </li><li>当 x &gt; 0 &amp;&amp; y &lt; 0 时，dif = -1</li></ol><p>将 x,y 符号之间的关系表达出来，把 dif 加一我们可以观察到当 x,y 同号时，dif为0，所以将其取反和 !(res &gt;&gt; 31) 相与，就可以表示同号不溢出的情况，而当 x &lt; 0, y &gt; 0 的情况发生时，我们注意到 dif 就是 0 ，所以我们直接或上 !dif 即可表达这种情况。</p></blockquote><hr><h3 id="12-ilog2—以2为底的对数"><a href="#12-ilog2—以2为底的对数" class="headerlink" title="12. ilog2—以2为底的对数"></a><strong>12. ilog2—以2为底的对数</strong></h3><p><strong>题目：</strong></p><pre><code>返回x取以2为底的对数并向下取整，输入的 x &gt; 0</code></pre><p><strong>样例：</strong></p><pre><code>ilog2(16) = 4</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 90</p><p><strong>使用操作数：</strong> 48</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ilog2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">int</span> tmp, l1, l2, l4, l8, l16;  x |= x &gt;&gt; <span class="hljs-number">1</span>;  x |= x &gt;&gt; <span class="hljs-number">2</span>;  x |= x &gt;&gt; <span class="hljs-number">4</span>;  x |= x &gt;&gt; <span class="hljs-number">8</span>;  x |= x &gt;&gt; <span class="hljs-number">16</span>;    tmp = (<span class="hljs-number">0x55</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x55</span>;  l1 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;  tmp = (<span class="hljs-number">0x33</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x33</span>;  l2 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;  tmp = (<span class="hljs-number">0x0f</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x0f</span>;  l4 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;  l8 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">16</span>) + <span class="hljs-number">0xff</span>;  l16 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xff</span>;  x = (x &amp; l1) + ((x &gt;&gt; <span class="hljs-number">1</span>) &amp; l1);  x = (x &amp; l2) + ((x &gt;&gt; <span class="hljs-number">2</span>) &amp; l2);  x = (x &amp; l4) + ((x &gt;&gt; <span class="hljs-number">4</span>) &amp; l4);  x = (x &amp; l8) + ((x &gt;&gt; <span class="hljs-number">8</span>) &amp; l8);  x = (x &amp; l16) + ((x &gt;&gt; <span class="hljs-number">16</span>) &amp; l16);  <span class="hljs-keyword">return</span> x + ~<span class="hljs-number">0</span>;</code></pre><p><strong>分析：</strong></p><blockquote><p>我们知道二进制数每位有其位权，所以对 x 取以2为底的对数就是指其为1的最高位的位权。为了获得最高位的位置，其实我们可以将其最高位往下全部变为1，再类似bitsCount数其中1的个数就行了。</p><p>我把 x 移位相与，保证最高位往下所有数字为1，再使用bitsCount就得到答案。</p><p>最后不要忘记减一</p></blockquote><hr><h3 id="13-float-neg—浮点数的负数"><a href="#13-float-neg—浮点数的负数" class="headerlink" title="13. float_neg—浮点数的负数"></a><strong>13. float_neg—浮点数的负数</strong></h3><p><strong>题目：</strong></p><pre><code>返回-f，当NaN时，返回参数f</code></pre><p><strong>可使用操作：</strong> 所有的整型操作，包括 ||, &amp;&amp;. 以及 if, while</p><p><strong>最大操作数限制：</strong> 10</p><p><strong>使用操作数：</strong> 5</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_neg</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;  <span class="hljs-keyword">unsigned</span> <span class="hljs-built_in">exp</span> = uf &amp; <span class="hljs-number">0x7f800000</span>;  <span class="hljs-keyword">unsigned</span> frac = uf &amp; <span class="hljs-number">0x007fffff</span>;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> == <span class="hljs-number">0x7f800000</span> &amp;&amp; frac)    <span class="hljs-keyword">return</span> uf;  <span class="hljs-keyword">return</span> uf ^= <span class="hljs-number">0x80000000</span>;&#125;</code></pre></p><p><strong>分析：</strong></p><ul><li>IEEE-float<blockquote><p>我们知道IEEE单精度浮点数，最高位为符号位，其后8位为阶码exp，后23位为尾数frac。其牺牲了精度来扩大了表达范围。</p></blockquote></li></ul><blockquote><p>而当 exp 全 1 时，如若frac非全零，则表示NaN。若全零，则表示无穷大/小。</p><p>这里我们只要将原数和符号位0x80000000异或一下，即可取负。不要忘记排除NaN的情况。</p></blockquote><hr><h3 id="14-float-i2f—int转float"><a href="#14-float-i2f—int转float" class="headerlink" title="14. float_i2f—int转float"></a><strong>14. float_i2f—int转float</strong></h3><p><strong>题目：</strong></p><pre><code>把int类型的数转换为float表示(比特形式)</code></pre><p><strong>可使用操作：</strong> 所有的整型操作，包括 ||, &amp;&amp;. 以及 if, while</p><p><strong>最大操作数限制：</strong> 30</p><p><strong>使用操作数：</strong> 30</p><p><strong>代码：</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_i2f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-keyword">unsigned</span> frac, mask1, mask2, mask3, mask4, d;  <span class="hljs-keyword">int</span> high = <span class="hljs-number">0x80000000</span>;  <span class="hljs-keyword">unsigned</span> sign = x &amp; <span class="hljs-number">0x80000000</span>;  <span class="hljs-keyword">unsigned</span> <span class="hljs-built_in">exp</span> = <span class="hljs-number">127</span>;  <span class="hljs-keyword">int</span> count = <span class="hljs-number">32</span>, i;  <span class="hljs-keyword">if</span>(sign)    x = ~x + <span class="hljs-number">1</span>;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!x)    <span class="hljs-keyword">return</span> x;    frac = x;  <span class="hljs-keyword">for</span>(;high; high &gt;&gt;= <span class="hljs-number">1</span>)  &#123;    --count;    <span class="hljs-keyword">if</span>(high &amp; x)      <span class="hljs-keyword">break</span>;  &#125;  i = count - <span class="hljs-number">23</span>;  mask1 = ~(<span class="hljs-number">1</span> &lt;&lt; count); <span class="hljs-comment">// the highest 1</span>  mask2 = <span class="hljs-number">1</span> &lt;&lt; i; <span class="hljs-comment">//the lowest of remain frac;</span>  mask3 = mask2 &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// the highest of deserted bits </span>  mask4 = mask2 - <span class="hljs-number">1</span>; <span class="hljs-comment">// the deserted bits</span>  <span class="hljs-built_in">exp</span> += count;  frac &amp;= mask1;    <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span>)  &#123;    d = frac &amp; mask4; <span class="hljs-comment">// deserted bits</span>    <span class="hljs-keyword">if</span>(d &gt; mask3 | (d == mask3 &amp;&amp; frac &amp; mask2))    &#123;      frac += mask2;      <span class="hljs-keyword">if</span>(frac &gt; <span class="hljs-number">0x3fffffff</span>)      &#123;        frac = <span class="hljs-number">0</span>;        <span class="hljs-built_in">exp</span>++;      &#125;    &#125;    frac &gt;&gt;= i;  &#125;  <span class="hljs-keyword">else</span>    frac &lt;&lt;= -i;  <span class="hljs-keyword">return</span> sign | <span class="hljs-built_in">exp</span> &lt;&lt; <span class="hljs-number">23</span> | frac;&#125;</code></pre><p><strong>分析：</strong></p><blockquote><p>我认为这题比较难，我做了很久很久….它难在浮点数向偶数舍入以及其操作数的限制。</p><p>我们知道由于浮点数表示范围比整型大，我们可以将整型转换为浮点数，但是相应的会有一些精度的丢失，因为尾数frac只有23位，而int有31位可用。</p><p>所以其关键在于int的位数，一开始先把该取出来的都用掩码取出来，把负数和零处理一下。之后我利用了一个循环先找出int的最高位在哪，利用count计数。</p><p>后面我采取了四个掩码，分别代表最高位的1，留下的尾数中的最低位，要舍去的位数的最高位，以及舍弃的位数的掩码。利用这四个掩码我们可以达到存frac时，将其向<strong>偶数舍入</strong>。</p><p>具体操作是，先取出丢弃的尾数，将其存放在d中，看其有没有超过0.5 (即 d 是否大于 mask3) 如果大于，直接frac++就行。而如果等于的话，还要看frac是否是奇数 (即frac &amp; mask2是否为1) 如果是，则要向偶数舍入,frac++。</p><p>加完frac之后还要注意<strong>溢出问题</strong>，如果溢出了，要将frac置0，然后把阶码 exp++，再按照之前输出来的尾数移动，将尾数对齐即可 （位数最高默认为1不存，因而把最高位隐去）。</p><p>最后把符号位，阶码位和尾数位拼接，得到最后的结果。</p></blockquote><hr><h3 id="15-float-twice—float-2"><a href="#15-float-twice—float-2" class="headerlink" title="15. float_twice—float * 2"></a>15. float_twice—float * 2</h3><p><strong>题目：</strong></p><pre><code>返回float * 2, 当参数是NaN时，返回参数</code></pre><p><strong>可使用操作：</strong> 所有的整型操作，包括 ||, &amp;&amp;. 以及 if, while</p><p><strong>最大操作数限制：</strong> 30</p><p><strong>使用操作数：</strong> 20</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_twice</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;  <span class="hljs-keyword">unsigned</span> sign = uf &amp; <span class="hljs-number">0x80000000</span>;  <span class="hljs-keyword">unsigned</span> <span class="hljs-built_in">exp</span> = uf &amp; <span class="hljs-number">0x7f800000</span>;  <span class="hljs-keyword">unsigned</span> frac = uf &amp; <span class="hljs-number">0x007fffff</span>;  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> == <span class="hljs-number">0x7f800000</span>) <span class="hljs-comment">//NaN &amp; inf</span>    <span class="hljs-keyword">return</span> uf;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">exp</span> &amp;&amp; !frac) <span class="hljs-comment">// 0</span>    <span class="hljs-keyword">return</span> uf;  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">exp</span> &amp;&amp; frac &lt;= <span class="hljs-number">0x3fffff</span>)  <span class="hljs-comment">// low</span>    frac *= <span class="hljs-number">2</span>;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">exp</span> &amp;&amp; frac &gt; <span class="hljs-number">0x3fffff</span>) <span class="hljs-comment">// high</span>  &#123;    <span class="hljs-built_in">exp</span> += <span class="hljs-number">0x00800000</span>;    frac = (frac * <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x7fffff</span>;  &#125;  <span class="hljs-keyword">else</span> <span class="hljs-comment">// normal</span>    <span class="hljs-built_in">exp</span> += <span class="hljs-number">0x00800000</span>;  <span class="hljs-keyword">return</span> sign + <span class="hljs-built_in">exp</span> + frac;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>主要要分析的地方，在于当阶码exp为0时，是否在乘2之后进位。所以要考虑尾数是否大于0x3fffff，如果小于等于之，则直接尾数乘2就行，不会溢出，否则则exp要进位，同时尾数乘2之后要与上0x7fffff保证不溢出。</p><p>其他正常情况直接exp++就行，注意一下特殊情况;</p></blockquote><p><em>本题中测试集中有一个inf，也要直接返回参数uf</em></p><hr><h2 id="Bits-honor-c"><a href="#Bits-honor-c" class="headerlink" title="Bits_honor.c"></a><strong>Bits_honor.c</strong></h2><h3 id="1-bitReverse—比特翻转"><a href="#1-bitReverse—比特翻转" class="headerlink" title="1. bitReverse—比特翻转"></a><strong>1. bitReverse—比特翻转</strong></h3><p><strong>题目：</strong></p><pre><code>把32比特int的比特位翻转</code></pre><p><strong>样例：</strong></p><pre><code>bitReverse(0x80000004) = 0x20000001bitReverse(0x7FFFFFFF) = 0xFFFFFFFE</code></pre><p><strong>最大操作数限制：</strong> 40</p><p><strong>使用操作数：</strong> 40</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitReverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> tmp,l1, l2, l4, l8, l16;   tmp = (<span class="hljs-number">0x55</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x55</span>;   l1 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;   tmp = (<span class="hljs-number">0x33</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x33</span>;   l2 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;   tmp = (<span class="hljs-number">0x0f</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0x0f</span>;   l4 = (tmp &lt;&lt; <span class="hljs-number">16</span>) + tmp;   l8 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">16</span>) + <span class="hljs-number">0xff</span>;   l16 = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xff</span>;   x = ((x &gt;&gt; <span class="hljs-number">16</span>) &amp; l16) | (x &lt;&lt; <span class="hljs-number">16</span>);   x = ((x &gt;&gt; <span class="hljs-number">8</span>) &amp; l8) | ((x &amp; l8) &lt;&lt; <span class="hljs-number">8</span>);   x = ((x &gt;&gt; <span class="hljs-number">4</span>) &amp; l4) | ((x &amp; l4) &lt;&lt; <span class="hljs-number">4</span>);   x = ((x &gt;&gt; <span class="hljs-number">2</span>) &amp; l2) | ((x &amp; l2) &lt;&lt; <span class="hljs-number">2</span>);   x = ((x &gt;&gt; <span class="hljs-number">1</span>) &amp; l1) | ((x &amp; l1) &lt;&lt; <span class="hljs-number">1</span>);   <span class="hljs-keyword">return</span> x;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>这题和 bitsCount 有异曲同工之妙，也是一个分治法，将32位二进制数一分为二，交换，再将内部各自再一分为二，交换，直至最底层2位二进制数互换位置，最后完成了将所有位数翻转的工作。</p><p>但值得注意的是，给出的是有符号的int，所以在右移交换位置时，会发生因为负数算术右移导致高位全是1的情况，致使在与的过程中高位全部变为1。这边只要将其移动后在和掩码相与就能解决这一问题。而对于低位，先与掩码相与再移动，可以省去取反得到高位掩码的操作数。再用tmp省一下操作数。</p><p>最后操作数正好卡在40</p></blockquote><hr><h3 id="2-mod3—取模3"><a href="#2-mod3—取模3" class="headerlink" title="2. mod3—取模3"></a><strong>2. mod3—取模3</strong></h3><p><strong>题目：</strong></p><pre><code>计算 x 取模 3，而不用%</code></pre><p><strong>样例：</strong></p><pre><code>mod3(100) = 1mod3(-100) = -1</code></pre><p><strong>可使用操作：</strong> ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</p><p><strong>最大操作数限制：</strong> 90</p><p><strong>使用操作数：</strong> 24</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mod3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> mask = (<span class="hljs-number">0xff</span> &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">0xff</span>;   x = (x &gt;&gt; <span class="hljs-number">16</span>) + (x &amp; mask); <span class="hljs-comment">// sum base 4^8 digits (a &lt;= 0x1FFFE)</span>   x = (x &gt;&gt; <span class="hljs-number">8</span>) + (x &amp; <span class="hljs-number">0xff</span>); <span class="hljs-comment">// sum base 4^4 digits (a &lt;= 0x2FD)</span>   x = (x &gt;&gt; <span class="hljs-number">4</span>) + (x &amp; <span class="hljs-number">0xf</span>); <span class="hljs-comment">// sum base 4^2 digits (a &lt;= 0x3C)</span>   x = (x &gt;&gt; <span class="hljs-number">2</span>) + (x &amp; <span class="hljs-number">0x3</span>); <span class="hljs-comment">// sum base 4^1 digits (a &lt;= 0x1D)</span>   x = (x &gt;&gt; <span class="hljs-number">2</span>) + (x &amp; <span class="hljs-number">0x3</span>); <span class="hljs-comment">// sum base 4^1 digits (a &lt;= 0x9)</span>   x = (x &gt;&gt; <span class="hljs-number">2</span>) + (x &amp; <span class="hljs-number">0x3</span>); <span class="hljs-comment">// sum base 4^1 digits (a &lt;= 0x4)</span>   x = (((x + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">2</span>) + x) &amp; <span class="hljs-number">0x3</span>;   <span class="hljs-keyword">return</span> x;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>这题难度算是比较大的，我参考了一些资料最后才写出这个代码。其实这题也与bitsCount有着一定的联系。</p><p>对于解这题有一个根本的公式即 </p></blockquote><pre><code>a % m = ((b % m)(a/b) + (a % b)) % m其中b是进制数</code></pre><blockquote><p>我们知道，如果想要知道一个十进制的数能否被三整除，只要看它所有数位之和是否能被三整除就行了。其实这就是上述公式的特殊情况，由于10 mod 3 == 1 所以其就退化为</p></blockquote><pre><code>a mod m = (a/b + a % b) % m递归下来就是所有数位之和</code></pre><blockquote><p>而对于二进制的情况，我们可以将进制位b选为4，这样正好是两位二进制数，同时4 % 3 == 1，这样一来，对于二进制数中我们只需要统计所有两两数位(四进制)的和能否被三整除就行了。</p><p>而考虑到我们每做一次 a/b + a % b 统计数位和都减小了数的规模，这样只要做有限次就能够将数控制在&lt;=3的范围内。</p><p>对于a % 4，这是一个经典的trivial情况，我们只需要做 a &amp; 3，就能够轻松得到a % 4的值。而对于a/4，只需要做a &gt;&gt; 2即可。</p><p>对于二进制数我们不仅可以按两位两位的四进制数位和来数，也可以直接数其倍数(4^i)，从最大4^8开始统计，一步步减小x的值，最后将x做到&lt;= 3的范围</p><p>最后要判断x是否为3，如果为3的话则要置为0，我利用3数位全为1的特点，将其+1进位后，右移2位。如果为3，则得到的是1。将其再加上x，如若x是1或2，则还是不变，但如果是3，它又会进位到4，那么我们只要再与上0x3，则会得到0，即为想要的结果。</p></blockquote><hr><h3 id="3-float-f2i—float转int"><a href="#3-float-f2i—float转int" class="headerlink" title="3. float_f2i—float转int"></a><strong>3. float_f2i—float转int</strong></h3><p><strong>题目：</strong></p><pre><code>输入一个按二进制位储存的float（以unsigned表示），将其转为int输出。(NaN,inf，溢出直接返回参数)</code></pre><p><strong>可使用操作：</strong> 所有的整型操作，包括 ||, &amp;&amp;. 以及 if, while</p><p><strong>最大操作数限制：</strong> 30</p><p><strong>使用操作数：</strong> 17</p><p><strong>代码：</strong><br><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">float_f2i</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">int</span> sign, <span class="hljs-built_in">exp</span>, frac, res;   <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> tmp;   <span class="hljs-keyword">if</span>(!uf)      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   sign = uf &amp; <span class="hljs-number">0x80000000</span>;   <span class="hljs-built_in">exp</span> = uf &amp; <span class="hljs-number">0x7f800000</span>;   frac = (uf &amp; <span class="hljs-number">0x007fffff</span>) | <span class="hljs-number">0x00800000</span>;   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> == <span class="hljs-number">0x7f800000</span>) <span class="hljs-comment">//NaN and inf</span>      <span class="hljs-keyword">return</span> <span class="hljs-number">0x80000000</span>u;   <span class="hljs-built_in">exp</span> &gt;&gt;= <span class="hljs-number">23</span>;   <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> &lt; <span class="hljs-number">127</span>)      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">158</span>)      <span class="hljs-keyword">return</span> <span class="hljs-number">0x80000000</span>u;   <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">exp</span> &gt; <span class="hljs-number">150</span>)      tmp = frac &lt;&lt; (<span class="hljs-built_in">exp</span> - <span class="hljs-number">150</span>);   <span class="hljs-keyword">else</span>      tmp = frac &gt;&gt; (<span class="hljs-number">150</span> - <span class="hljs-built_in">exp</span>);         <span class="hljs-keyword">if</span>(sign)      res = ~tmp + <span class="hljs-number">1</span>;   <span class="hljs-keyword">else</span>      res = tmp;      <span class="hljs-keyword">return</span> res | sign;&#125;</code></pre></p><p><strong>分析：</strong></p><blockquote><p>这题特殊情况比较多，把NaN和inf处理一下，然后注意一下溢出情况，即取出来的exp - bias &gt; 31，肯定超过2^31整型储存的最大值，直接返回0x80000000u，然后对于exp小于127的，其指数是负数，直接返回int值为0。对于在exp - bias 在 0 到 31 之间的，由于frac只有23位，所以要将注意一下讨论23的情况。</p><p>最后把取出来的符号位对一下，如果负数取反加一，正数直接等，最后再或上符号位，返回答案。</p></blockquote><hr><h2 id="结果截图"><a href="#结果截图" class="headerlink" title="结果截图"></a><strong>结果截图</strong></h2><h3 id="bits-c"><a href="#bits-c" class="headerlink" title="bits.c"></a><strong>bits.c</strong></h3><p><img src="/2020/11/05/ICS/ICS_Lab1/ICS_Lab1/bits_btest.JPG" alt="bits_btest"></p><p><img src="/2020/11/05/ICS/ICS_Lab1/ICS_Lab1/bits_dlc.png" alt="bits_dlc"></p><h3 id="bits-honor-c"><a href="#bits-honor-c" class="headerlink" title="bits_honor.c"></a><strong>bits_honor.c</strong></h3><p><img src="/2020/11/05/ICS/ICS_Lab1/ICS_Lab1/bits_honor_btest.JPG" alt="bits_honor_btest"></p><p><img src="/2020/11/05/ICS/ICS_Lab1/ICS_Lab1/bits_honor_dlc.png" alt="bits_honor_dlc"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr><p><a href="https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E5%8F%B3%E7%A7%BB/3711081?fr=aladdin">https://baike.baidu.com/item/%E7%AE%97%E6%9C%AF%E5%8F%B3%E7%A7%BB/3711081?fr=aladdin</a><br><a href="https://blog.csdn.net/jiahonghao2002/article/details/108223366">https://blog.csdn.net/jiahonghao2002/article/details/108223366</a><br><a href="https://leetcode-cn.com/problems/reverse-bits/solution/dian-dao-er-jin-zhi-wei-by-leetcode/">https://leetcode-cn.com/problems/reverse-bits/solution/dian-dao-er-jin-zhi-wei-by-leetcode/</a><br><a href="http://homepage.cs.uiowa.edu/~jones/bcd/mod.shtml#exmod3">http://homepage.cs.uiowa.edu/~jones/bcd/mod.shtml#exmod3</a><br><a href="https://www.zhihu.com/question/38206659/answer/763034261">https://www.zhihu.com/question/38206659/answer/763034261</a><br><a href="https://blog.csdn.net/xindaxinda123/article/details/95617758">https://blog.csdn.net/xindaxinda123/article/details/95617758</a><br><a href="https://www.runoob.com/w3cnote/32-float-storage.html">https://www.runoob.com/w3cnote/32-float-storage.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bits</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/11/05/hello-world/"/>
    <url>/2020/11/05/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="第一篇博客用以测试"><a href="#第一篇博客用以测试" class="headerlink" title="第一篇博客用以测试"></a>第一篇博客用以测试</h2><h3 id="一、-下面是一段C-代码"><a href="#一、-下面是一段C-代码" class="headerlink" title="一、 下面是一段C++代码"></a>一、 下面是一段C++代码</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Hello World!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre><h3 id="二、-下面是一段表格"><a href="#二、-下面是一段表格" class="headerlink" title="二、 下面是一段表格"></a>二、 下面是一段表格</h3><div class="table-container"><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td></tr></tbody></table></div><h3 id="三、-下面是一段-Latex"><a href="#三、-下面是一段-Latex" class="headerlink" title="三、 下面是一段 Latex"></a>三、 下面是一段 Latex</h3><script type="math/tex; mode=display">E= mc^2</script><h3 id="四、下面是一张图片"><a href="#四、下面是一张图片" class="headerlink" title="四、下面是一张图片"></a>四、下面是一张图片</h3><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcRP-ciAYVH8UlH3ZaZC3NkN3ow9CrG36O5crg&amp;usqp=CAU" alt></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
